import { SyntaxNode } from "web-tree-sitter";
import {
  cascadingMatcher,
  chainedMatcher,
  createPatternMatchers,
  leadingMatcher,
  matcher,
  trailingMatcher,
  typeMatcher,
  conditionMatcher,
  patternMatcher,
} from "../util/nodeMatchers";
import { NodeMatcherAlternative } from "../typings/Types";
import { SimpleScopeTypeType } from "@cursorless/common";
import { nodeFinder, typedNodeFinder } from "../util/nodeFinders";
import { delimitedSelector, childRangeSelector } from "../util/nodeSelectors";
import { patternFinder } from "../util/nodeFinders";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-c-sharp/master/src/node-types.json \
//   | jq '.[] | select(.type == "_statement" or .type == "_declaration") | [.subtypes[].type]'
const STATEMENT_TYPES = [
  "class_declaration",
  "constructor_declaration",
  "conversion_operator_declaration",
  "delegate_declaration",
  "destructor_declaration",
  "enum_declaration",
  "event_declaration",
  "event_field_declaration",
  "field_declaration",
  "indexer_declaration",
  "interface_declaration",
  "method_declaration",
  "namespace_declaration",
  "operator_declaration",
  "property_declaration",
  "record_declaration",
  "struct_declaration",
  "using_directive",
  "block",
  "break_statement",
  "checked_statement",
  "continue_statement",
  "do_statement",
  "empty_statement",
  "expression_statement",
  "fixed_statement",
  "for_each_statement",
  "for_statement",
  "goto_statement",
  "if_statement",
  "labeled_statement",
  "local_declaration_statement",
  "local_function_statement",
  "lock_statement",
  "return_statement",
  "switch_statement",
  "throw_statement",
  "try_statement",
  "unsafe_statement",
  "using_statement",
  "while_statement",
  "yield_statement",
];

const NAMED_FUNCTION_TYPES = [
  "delegate_declaration",
  "local_function_statement",
  "method_declaration",
];

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-c-sharp/master/src/node-types.json \
// jq '.[] | select(has("children")) | select(any(.children.types[]; .type == "initializer_expression")) | .type'
// this is then filtered by hand to separate arrays from objects
const LIST_TYPES_WITH_INITIALIZERS_AS_CHILDREN = [
  "array_creation_expression",
  "implicit_array_creation_expression",
  "implicit_stack_alloc_array_creation_expression",
  "stack_alloc_array_creation_expression",
];

const OBJECT_TYPES_WITH_INITIALIZERS_AS_CHILDREN = [
  "implicit_object_creation_expression",
];

// Every array or map initializer contains its contents in a initializer_expression.
// There appears to be no distinction between dictionaries and arrays as far as the syntax tree goes.
// that means some of the commands for maps may work on arrays, and some of the commands for arrays may work on maps.
const getChildInitializerNode = (node: SyntaxNode) =>
  node.children.find((child) => child.type === "initializer_expression") ??
  null;

const getInitializerNode = (node: SyntaxNode) =>
  node.childForFieldName("initializer");

const makeDelimitedSelector = (leftType: string, rightType: string) =>
  delimitedSelector(
    (node) =>
      node.type === "," || node.type === leftType || node.type === rightType,
    ", ",
  );

const getMapMatchers = {
  map: cascadingMatcher(
    chainedMatcher([
      typedNodeFinder(...OBJECT_TYPES_WITH_INITIALIZERS_AS_CHILDREN),
      getChildInitializerNode,
    ]),
    chainedMatcher([
      typedNodeFinder("object_creation_expression"),
      getInitializerNode,
    ]),
  ),
  collectionKey: chainedMatcher([
    typedNodeFinder("assignment_expression"),
    (node: SyntaxNode) => node.childForFieldName("left"),
  ]),
  value: leadingMatcher(
    [
      "variable_declaration?.variable_declarator[1][0]!",
      "assignment_expression[right]",
    ],
    ["assignment_operator"],
  ),
  list: cascadingMatcher(
    chainedMatcher([
      typedNodeFinder(...LIST_TYPES_WITH_INITIALIZERS_AS_CHILDREN),
      getChildInitializerNode,
    ]),
    chainedMatcher([
      typedNodeFinder("object_creation_expression"),
      (node: SyntaxNode) => node.childForFieldName("initializer"),
    ]),
  ),
  string: typeMatcher("string_literal"),
};

const nodeMatchers: Partial<
  Record<SimpleScopeTypeType, NodeMatcherAlternative>
> = {
  ...getMapMatchers,
  ifStatement: "if_statement",
  class: "class_declaration",
  className: "class_declaration[name]",
  condition: cascadingMatcher(
    conditionMatcher("*[condition]"),
    patternMatcher("while_statement[0]"),
  ),
  switchStatementSubject: [
    "switch_statement.tuple_expression!",
    "switch_statement[value]",
  ],
  statement: STATEMENT_TYPES,
  anonymousFunction: "lambda_expression",
  functionCall: ["invocation_expression", "object_creation_expression"],
  functionCallee: cascadingMatcher(
    patternMatcher("invocation_expression[function]"),
    matcher(
      patternFinder("object_creation_expression"),
      childRangeSelector(["argument_list"], []),
    ),
  ),
  argumentOrParameter: matcher(
    nodeFinder(
      (node) =>
        node.parent?.type === "argument_list" || node.type === "parameter",
    ),
    makeDelimitedSelector("(", ")"),
  ),
  namedFunction: NAMED_FUNCTION_TYPES,
  functionName: NAMED_FUNCTION_TYPES.map((t) => t + "[name]"),
  comment: "comment",
  regularExpression: "regex",
  type: trailingMatcher(["*[type]"]),
  name: [
    "variable_declaration?.variable_declarator.identifier!",
    "assignment_expression[left]",
    "*[name]",
  ],
};

export default createPatternMatchers(nodeMatchers);
