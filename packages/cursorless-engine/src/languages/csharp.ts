import type { SyntaxNode } from "web-tree-sitter";
import {
  cascadingMatcher,
  chainedMatcher,
  createPatternMatchers,
  leadingMatcher,
  matcher,
  trailingMatcher,
} from "../util/nodeMatchers";
import { NodeMatcherAlternative } from "../typings/Types";
import { SimpleScopeTypeType } from "@cursorless/common";
import { nodeFinder, typedNodeFinder } from "../util/nodeFinders";
import { delimitedSelector } from "../util/nodeSelectors";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-c-sharp/master/src/node-types.json \
// jq '.[] | select(has("children")) | select(any(.children.types[]; .type == "initializer_expression")) | .type'
// this is then filtered by hand to separate arrays from objects
const LIST_TYPES_WITH_INITIALIZERS_AS_CHILDREN = [
  "array_creation_expression",
  "implicit_array_creation_expression",
  "implicit_stack_alloc_array_creation_expression",
  "stack_alloc_array_creation_expression",
];

const OBJECT_TYPES_WITH_INITIALIZERS_AS_CHILDREN = [
  "implicit_object_creation_expression",
];

// Every array or map initializer contains its contents in a initializer_expression.
// There appears to be no distinction between dictionaries and arrays as far as the syntax tree goes.
// that means some of the commands for maps may work on arrays, and some of the commands for arrays may work on maps.
const getChildInitializerNode = (node: SyntaxNode) =>
  node.children.find((child) => child.type === "initializer_expression") ??
  null;

const getInitializerNode = (node: SyntaxNode) =>
  node.childForFieldName("initializer");

const makeDelimitedSelector = (leftType: string, rightType: string) =>
  delimitedSelector(
    (node) =>
      node.type === "," || node.type === leftType || node.type === rightType,
    ", ",
  );

const getMapMatchers = {
  map: cascadingMatcher(
    chainedMatcher([
      typedNodeFinder(...OBJECT_TYPES_WITH_INITIALIZERS_AS_CHILDREN),
      getChildInitializerNode,
    ]),
    chainedMatcher([
      typedNodeFinder("object_creation_expression"),
      getInitializerNode,
    ]),
  ),
  collectionKey: chainedMatcher([
    typedNodeFinder("assignment_expression"),
    (node: SyntaxNode) => node.childForFieldName("left"),
  ]),
  value: leadingMatcher(
    [
      "variable_declaration?.variable_declarator[1][0]!",
      "assignment_expression[right]",
    ],
    ["assignment_operator"],
  ),
  list: cascadingMatcher(
    chainedMatcher([
      typedNodeFinder(...LIST_TYPES_WITH_INITIALIZERS_AS_CHILDREN),
      getChildInitializerNode,
    ]),
    chainedMatcher([
      typedNodeFinder("object_creation_expression"),
      (node: SyntaxNode) => node.childForFieldName("initializer"),
    ]),
  ),
};

const nodeMatchers: Partial<
  Record<SimpleScopeTypeType, NodeMatcherAlternative>
> = {
  ...getMapMatchers,
  argumentOrParameter: matcher(
    nodeFinder(
      (node) =>
        node.parent?.type === "argument_list" || node.type === "parameter",
    ),
    makeDelimitedSelector("(", ")"),
  ),
  type: trailingMatcher(["*[type]"]),
  name: [
    "variable_declaration?.variable_declarator.identifier!",
    "assignment_expression[left]",
    "*[name]",
  ],
};

export default createPatternMatchers(nodeMatchers);
