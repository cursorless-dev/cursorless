"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values2) {
        var index = -1, length = values2.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current2 = iteratee(array[index]);
          if (current2 !== undefined2) {
            result = result === undefined2 ? current2 : result + current2;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map4) {
        var index = -1, result = Array(map4.size);
        map4.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set3) {
        var index = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set3) {
        var index = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString2 = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject3(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry2 = entries[index];
            this.set(entry2[0], entry2[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry2 = entries[index];
            this.set(entry2[0], entry2[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry2 = entries[index];
            this.set(entry2[0], entry2[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values3) {
          var index = -1, length = values3 == null ? 0 : values3.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values3[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack2(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs2 = data.__data__;
            if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
              pairs2.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs2);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack2.prototype.clear = stackClear;
        Stack2.prototype["delete"] = stackDelete;
        Stack2.prototype.get = stackGet;
        Stack2.prototype.has = stackHas;
        Stack2.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get3(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject3(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack2());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet2(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap2(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values3, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values3 = arrayMap(values3, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values3.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values3 = new SetCache(values3);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values3[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values3, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current2 = iteratee2(value);
            if (current2 != null && (computed === undefined2 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
              var computed = current2, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path8) {
          path8 = castPath(path8, object);
          var index = 0, length = path8.length;
          while (object != null && index < length) {
            object = object[toKey(path8[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path8, args) {
          path8 = castPath(path8, object);
          object = parent(object, path8);
          var func = object == null ? object : object[toKey(last2(path8))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack2());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack2());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack2();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject3(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity3;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject3(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path8, srcValue) {
          if (isKey(path8) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path8), srcValue);
          }
          return function(object) {
            var objValue = get3(object, path8);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path8) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack2());
            if (isObject3(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject3(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity3];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path8) {
            return hasIn(object, path8);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path8 = paths[index], value = baseGet(object, path8);
            if (predicate(value, path8)) {
              baseSet(result2, castPath(path8, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path8) {
          return function(object) {
            return baseGet(object, path8);
          };
        }
        function basePullAll(array, values3, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values3.length, seen = array;
          if (array === values3) {
            values3 = copyArray(values3);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values3[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string2, n) {
          var result2 = "";
          if (!string2 || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string2;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string2 += string2;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity3), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values2(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path8, value, customizer) {
          if (!isObject3(object)) {
            return object;
          }
          path8 = castPath(path8, object);
          var index = -1, length = path8.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path8[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject3(objValue) ? objValue : isIndex(path8[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity3 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity3 : function(func, string2) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity3, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set4 = iteratee2 ? null : createSet(array);
            if (set4) {
              return setToArray(set4);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path8) {
          path8 = castPath(path8, object);
          object = parent(object, path8);
          return object == null || delete object[toKey(last2(path8))];
        }
        function baseUpdate(object, path8, updater, customizer) {
          return baseSet(object, path8, updater(baseGet(object, path8)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions2) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions2, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values3, assignFunc) {
          var index = -1, length = props.length, valsLength = values3.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values3[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity3;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString2(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString2(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback2) {
          return function(string2) {
            return arrayReduce(words(deburr2(string2).replace(reApos, "")), callback2, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject3(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values3) {
          return new Set2(values3);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject3(objValue) && isObject3(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject3(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten13), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map5, key) {
          var data = map5.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path8, hasFunc) {
          path8 = castPath(path8, object);
          var index = -1, length = path8.length, result2 = false;
          while (++index < length) {
            var key = toKey(path8[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject3(object)) {
            return false;
          }
          var type2 = typeof index;
          if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject3(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path8) {
          return path8.length < 2 ? object : baseGet(object, baseSlice(path8, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count2 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count2 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match2, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat3() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values3) {
          var iteratee2 = last2(values3);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values3) {
          var comparator = last2(values3);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex3(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten13(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs2) {
          var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {};
          while (++index < length) {
            var pair = pairs2[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last2(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join9(array, separator2) {
          return array == null ? "" : nativeJoin.call(array, separator2);
        }
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull8 = baseRest(pullAll);
        function pullAll(array, values3) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
        }
        function pullAllBy(array, values3, iteratee2) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values3, comparator) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy2(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq5(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith3(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip9 = baseRest(unzip);
        function zipObject(props, values3) {
          return baseZipObject(props || [], values3 || [], assignValue);
        }
        function zipObjectDeep(props, values3) {
          return baseZipObject(props || [], values3 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray2(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast2 = createFind(findLastIndex3);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map4(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map4(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map4(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy5 = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path8, args) {
          var index = -1, isFunc = typeof path8 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path8, value, args) : baseInvoke(value, path8, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map4(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle2(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString3(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy3 = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject3(options2)) {
            leading = !!options2.leading;
            maxing = "maxWait" in options2;
            maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer2 = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options2) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject3(options2)) {
            leading = "leading" in options2 ? !!options2.leading : leading;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep2(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject3(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual5(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject3(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject3(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject3(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull2(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject3(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString2;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString3(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString3(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject3(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject3(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary2 = reIsBinary.test(value);
          return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get3(object, path8, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path8);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has2(object, path8) {
          return object != null && hasPath(object, path8, baseHas);
        }
        function hasIn(object, path8) {
          return object != null && hasPath(object, path8, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity3));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues2(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge4 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path8) {
            path8 = castPath(path8, object);
            isDeep || (isDeep = path8.length > 1);
            return path8;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy2(object, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy2(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path8) {
            return predicate(value, path8[0]);
          });
        }
        function result(object, path8, defaultValue) {
          path8 = castPath(path8, object);
          var index = -1, length = path8.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path8[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set3(object, path8, value) {
          return object == null ? object : baseSet(object, path8, value);
        }
        function setWith(object, path8, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path8, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject3(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path8) {
          return object == null ? true : baseUnset(object, path8);
        }
        function update(object, path8, updater) {
          return object == null ? object : baseUpdate(object, path8, castFunction(updater));
        }
        function updateWith(object, path8, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path8, castFunction(updater), customizer);
        }
        function values2(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string2) {
          return upperFirst(toString2(string2).toLowerCase());
        }
        function deburr2(string2) {
          string2 = toString2(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string2, target, position) {
          string2 = toString2(string2);
          target = baseToString(target);
          var length = string2.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        function escape2(string2) {
          string2 = toString2(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        function escapeRegExp6(string2) {
          string2 = toString2(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string2, length, chars) {
          string2 = toString2(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          if (!length || strLength >= length) {
            return string2;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string2, length, chars) {
          string2 = toString2(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
        }
        function padStart2(string2, length, chars) {
          string2 = toString2(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
        }
        function parseInt2(string2, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix || 0);
        }
        function repeat3(string2, n, guard) {
          if (guard ? isIterateeCall(string2, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString2(string2), n);
        }
        function replace() {
          var args = arguments, string2 = toString2(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string2, separator2, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator2, limit)) {
            separator2 = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString2(string2);
          if (string2 && (typeof separator2 == "string" || separator2 != null && !isRegExp(separator2))) {
            separator2 = baseToString(separator2);
            if (!separator2 && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator2, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString2(string2);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        function template(string2, options2, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string2, options2, guard)) {
            options2 = undefined2;
          }
          string2 = toString2(string2);
          options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim(string2, chars, guard) {
          string2 = toString2(string2);
          if (string2 && (guard || chars === undefined2)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string2, chars, guard) {
          string2 = toString2(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string2, chars, guard) {
          string2 = toString2(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string2, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject3(options2)) {
            var separator2 = "separator" in options2 ? options2.separator : separator2;
            length = "length" in options2 ? toInteger(options2.length) : length;
            omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string2 = toString2(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string2;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator2 === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator2)) {
            if (string2.slice(end).search(separator2)) {
              var match2, substring = result2;
              if (!separator2.global) {
                separator2 = RegExp2(separator2.source, toString2(reFlags.exec(separator2)) + "g");
              }
              separator2.lastIndex = 0;
              while (match2 = separator2.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator2), end) != end) {
            var index = result2.lastIndexOf(separator2);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape3(string2) {
          string2 = toString2(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string2, pattern, guard) {
          string2 = toString2(string2);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs2) {
          var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
          pairs2 = !length ? [] : arrayMap(pairs2, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs2[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow2 = createFlow();
        var flowRight = createFlow(true);
        function identity3(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path8, srcValue) {
          return baseMatchesProperty(path8, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path8, args) {
          return function(object) {
            return baseInvoke(object, path8, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path8) {
            return baseInvoke(object, path8, args);
          };
        });
        function mixin(object, source, options2) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options2 == null && !(isObject3(source) && (methodNames.length || !props.length))) {
            options2 = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject3(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                  actions2.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path8) {
          return isKey(path8) ? baseProperty(toKey(path8)) : basePropertyDeep(path8);
        }
        function propertyOf(object) {
          return function(path8) {
            return object == null ? undefined2 : baseGet(object, path8);
          };
        }
        var range4 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString2(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max2(array) {
          return array && array.length ? baseExtremum(array, identity3, baseGt) : undefined2;
        }
        function maxBy2(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity3);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min2(array) {
          return array && array.length ? baseExtremum(array, identity3, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum2(array) {
          return array && array.length ? baseSum(array, identity3) : 0;
        }
        function sumBy2(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat3;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults2;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer2;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten13;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow2;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy5;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map4;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues2;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge4;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick2;
        lodash.pickBy = pickBy2;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull8;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range4;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set3;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle2;
        lodash.slice = slice;
        lodash.sortBy = sortBy3;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray2;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq5;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith3;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values2;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip9;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep2;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr2;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp6;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast2;
        lodash.findLastIndex = findLastIndex3;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get3;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has2;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity3;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual5;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger2;
        lodash.isLength = isLength;
        lodash.isMap = isMap2;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject3;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject3;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet2;
        lodash.isString = isString3;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join9;
        lodash.kebabCase = kebabCase;
        lodash.last = last2;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max2;
        lodash.maxBy = maxBy2;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min2;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart2;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat3;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy2;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum2;
        lodash.sumBy = sumBy2;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString2;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape3;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type2
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity3);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path8, args) {
          if (typeof path8 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path8, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// ../../node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js
var require_immutability_helper = __commonJS({
  "../../node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function stringifiable(obj) {
      return typeof obj === "object" && !("toString" in obj) ? Object.prototype.toString.call(obj).slice(8, -1) : obj;
    }
    var isProduction = typeof process === "object" && process.env.NODE_ENV === "production";
    function invariant5(condition, message) {
      if (!condition) {
        if (isProduction) {
          throw new Error("Invariant failed");
        }
        throw new Error(message());
      }
    }
    exports2.invariant = invariant5;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var splice = Array.prototype.splice;
    var toString2 = Object.prototype.toString;
    function type2(obj) {
      return toString2.call(obj).slice(8, -1);
    }
    var assign = Object.assign || /* istanbul ignore next */
    function(target, source) {
      getAllKeys(source).forEach(function(key) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      });
      return target;
    };
    var getAllKeys = typeof Object.getOwnPropertySymbols === "function" ? function(obj) {
      return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
    } : function(obj) {
      return Object.keys(obj);
    };
    function copy(object) {
      return Array.isArray(object) ? assign(object.constructor(object.length), object) : type2(object) === "Map" ? new Map(object) : type2(object) === "Set" ? new Set(object) : object && typeof object === "object" ? assign(Object.create(Object.getPrototypeOf(object)), object) : object;
    }
    var Context = (
      /** @class */
      function() {
        function Context2() {
          this.commands = assign({}, defaultCommands);
          this.update = this.update.bind(this);
          this.update.extend = this.extend = this.extend.bind(this);
          this.update.isEquals = function(x, y) {
            return x === y;
          };
          this.update.newContext = function() {
            return new Context2().update;
          };
        }
        Object.defineProperty(Context2.prototype, "isEquals", {
          get: function() {
            return this.update.isEquals;
          },
          set: function(value) {
            this.update.isEquals = value;
          },
          enumerable: true,
          configurable: true
        });
        Context2.prototype.extend = function(directive, fn) {
          this.commands[directive] = fn;
        };
        Context2.prototype.update = function(object, $spec) {
          var _this = this;
          var spec = typeof $spec === "function" ? { $apply: $spec } : $spec;
          if (!(Array.isArray(object) && Array.isArray(spec))) {
            invariant5(!Array.isArray(spec), function() {
              return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
            });
          }
          invariant5(typeof spec === "object" && spec !== null, function() {
            return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(_this.commands).join(", ") + ".");
          });
          var nextObject = object;
          getAllKeys(spec).forEach(function(key) {
            if (hasOwnProperty.call(_this.commands, key)) {
              var objectWasNextObject = object === nextObject;
              nextObject = _this.commands[key](spec[key], nextObject, spec, object);
              if (objectWasNextObject && _this.isEquals(nextObject, object)) {
                nextObject = object;
              }
            } else {
              var nextValueForKey = type2(object) === "Map" ? _this.update(object.get(key), spec[key]) : _this.update(object[key], spec[key]);
              var nextObjectValue = type2(nextObject) === "Map" ? nextObject.get(key) : nextObject[key];
              if (!_this.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === "undefined" && !hasOwnProperty.call(object, key)) {
                if (nextObject === object) {
                  nextObject = copy(object);
                }
                if (type2(nextObject) === "Map") {
                  nextObject.set(key, nextValueForKey);
                } else {
                  nextObject[key] = nextValueForKey;
                }
              }
            }
          });
          return nextObject;
        };
        return Context2;
      }()
    );
    exports2.Context = Context;
    var defaultCommands = {
      $push: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$push");
        return value.length ? nextObject.concat(value) : nextObject;
      },
      $unshift: function(value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, "$unshift");
        return value.length ? value.concat(nextObject) : nextObject;
      },
      $splice: function(value, nextObject, spec, originalObject) {
        invariantSplices(nextObject, spec);
        value.forEach(function(args) {
          invariantSplice(args);
          if (nextObject === originalObject && args.length) {
            nextObject = copy(originalObject);
          }
          splice.apply(nextObject, args);
        });
        return nextObject;
      },
      $set: function(value, _nextObject, spec) {
        invariantSet(spec);
        return value;
      },
      $toggle: function(targets, nextObject) {
        invariantSpecArray(targets, "$toggle");
        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
        targets.forEach(function(target) {
          nextObjectCopy[target] = !nextObject[target];
        });
        return nextObjectCopy;
      },
      $unset: function(value, nextObject, _spec, originalObject) {
        invariantSpecArray(value, "$unset");
        value.forEach(function(key) {
          if (Object.hasOwnProperty.call(nextObject, key)) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            delete nextObject[key];
          }
        });
        return nextObject;
      },
      $add: function(values2, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$add");
        invariantSpecArray(values2, "$add");
        if (type2(nextObject) === "Map") {
          values2.forEach(function(_a) {
            var key = _a[0], value = _a[1];
            if (nextObject === originalObject && nextObject.get(key) !== value) {
              nextObject = copy(originalObject);
            }
            nextObject.set(key, value);
          });
        } else {
          values2.forEach(function(value) {
            if (nextObject === originalObject && !nextObject.has(value)) {
              nextObject = copy(originalObject);
            }
            nextObject.add(value);
          });
        }
        return nextObject;
      },
      $remove: function(value, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, "$remove");
        invariantSpecArray(value, "$remove");
        value.forEach(function(key) {
          if (nextObject === originalObject && nextObject.has(key)) {
            nextObject = copy(originalObject);
          }
          nextObject.delete(key);
        });
        return nextObject;
      },
      $merge: function(value, nextObject, _spec, originalObject) {
        invariantMerge(nextObject, value);
        getAllKeys(value).forEach(function(key) {
          if (value[key] !== nextObject[key]) {
            if (nextObject === originalObject) {
              nextObject = copy(originalObject);
            }
            nextObject[key] = value[key];
          }
        });
        return nextObject;
      },
      $apply: function(value, original) {
        invariantApply(value);
        return value(original);
      }
    };
    var defaultContext = new Context();
    exports2.isEquals = defaultContext.update.isEquals;
    exports2.extend = defaultContext.extend;
    exports2.default = defaultContext.update;
    exports2.default.default = module2.exports = assign(exports2.default, exports2);
    function invariantPushAndUnshift(value, spec, command) {
      invariant5(Array.isArray(value), function() {
        return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value) + ".";
      });
      invariantSpecArray(spec[command], command);
    }
    function invariantSpecArray(spec, command) {
      invariant5(Array.isArray(spec), function() {
        return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". Did you forget to wrap your parameter in an array?";
      });
    }
    function invariantSplices(value, spec) {
      invariant5(Array.isArray(value), function() {
        return "Expected $splice target to be an array; got " + stringifiable(value);
      });
      invariantSplice(spec.$splice);
    }
    function invariantSplice(value) {
      invariant5(Array.isArray(value), function() {
        return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value) + ". Did you forget to wrap your parameters in an array?";
      });
    }
    function invariantApply(fn) {
      invariant5(typeof fn === "function", function() {
        return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + ".";
      });
    }
    function invariantSet(spec) {
      invariant5(Object.keys(spec).length === 1, function() {
        return "Cannot have more than one key in an object with $set";
      });
    }
    function invariantMerge(target, specValue) {
      invariant5(specValue && typeof specValue === "object", function() {
        return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue);
      });
      invariant5(target && typeof target === "object", function() {
        return "update(): $merge expects a target of type 'object'; got " + stringifiable(target);
      });
    }
    function invariantMapOrSet(target, command) {
      var typeOfTarget = type2(target);
      invariant5(typeOfTarget === "Map" || typeOfTarget === "Set", function() {
        return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget);
      });
    }
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode_codepoint.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports2.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports2.default = decodeCodePoint;
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports2.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports2.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports2.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors2;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str2, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str2.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str2, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str2, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str2, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str2, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str2, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str2, offset);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str2, offset) {
          if (offset >= str2.length) {
            return -1;
          }
          if ((str2.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str2, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str2, offset);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str2, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str2.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str2, offset) {
          var startIdx = offset;
          while (offset < str2.length) {
            var char = str2.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str2, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str2, offset) {
          var startIdx = offset;
          while (offset < str2.length) {
            var char = str2.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str2, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str2, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str2, offset) {
          var decodeTree = this.decodeTree;
          var current2 = decodeTree[this.treeIndex];
          var valueLength = (current2 & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str2.length; offset++, this.excess++) {
            var char = str2.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current2, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current2 = decodeTree[this.treeIndex];
            valueLength = (current2 & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }()
    );
    exports2.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str2) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str2);
      });
      return function decodeWithTrie(str2, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str2.indexOf("&", offset)) >= 0) {
          ret += str2.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str2,
            // Skip the "&"
            offset + 1
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str2.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current2, nodeIdx, char) {
      var branchCount = (current2 & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current2 & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports2.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str2, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str2, mode);
    }
    exports2.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str2) {
      return htmlDecoder(str2, DecodingMode.Attribute);
    }
    exports2.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str2) {
      return htmlDecoder(str2, DecodingMode.Strict);
    }
    exports2.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str2) {
      return xmlDecoder(str2, DecodingMode.Strict);
    }
    exports2.decodeXML = decodeXML;
  }
});

// ../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/Tokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QuoteType = void 0;
    var decode_js_1 = require_decode();
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
      CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
      CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
      CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes2[CharCodes2["Space"] = 32] = "Space";
      CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
      CharCodes2[CharCodes2["Number"] = 35] = "Number";
      CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
      CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
      CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
      CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
      CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
      CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
      CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
      CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
      CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
      CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
      CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
      CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
      CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
      CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
      CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
      CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
      CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
      CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
      CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
      CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes || (CharCodes = {}));
    var State2;
    (function(State3) {
      State3[State3["Text"] = 1] = "Text";
      State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
      State3[State3["InTagName"] = 3] = "InTagName";
      State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
      State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
      State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
      State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
      State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
      State3[State3["InAttributeName"] = 9] = "InAttributeName";
      State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
      State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
      State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
      State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
      State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
      State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
      State3[State3["InDeclaration"] = 16] = "InDeclaration";
      State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
      State3[State3["BeforeComment"] = 18] = "BeforeComment";
      State3[State3["CDATASequence"] = 19] = "CDATASequence";
      State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
      State3[State3["InCommentLike"] = 21] = "InCommentLike";
      State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
      State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
      State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
      State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
      State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
      State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
      State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
      State3[State3["InHexEntity"] = 29] = "InHexEntity";
    })(State2 || (State2 = {}));
    function isWhitespace2(c) {
      return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
    }
    function isEndOfTagSection(c) {
      return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace2(c);
    }
    function isNumber(c) {
      return c >= CharCodes.Zero && c <= CharCodes.Nine;
    }
    function isASCIIAlpha(c) {
      return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
    }
    function isHexDigit(c) {
      return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
    }
    var QuoteType;
    (function(QuoteType2) {
      QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
      QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
      QuoteType2[QuoteType2["Single"] = 2] = "Single";
      QuoteType2[QuoteType2["Double"] = 3] = "Double";
    })(QuoteType = exports2.QuoteType || (exports2.QuoteType = {}));
    var Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    };
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2(_a, cbs) {
          var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
          this.cbs = cbs;
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.isSpecial = false;
          this.running = true;
          this.offset = 0;
          this.currentSequence = void 0;
          this.sequenceIndex = 0;
          this.trieIndex = 0;
          this.trieCurrent = 0;
          this.entityResult = 0;
          this.entityExcess = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
        }
        Tokenizer2.prototype.reset = function() {
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.currentSequence = void 0;
          this.running = true;
          this.offset = 0;
        };
        Tokenizer2.prototype.write = function(chunk) {
          this.offset += this.buffer.length;
          this.buffer = chunk;
          this.parse();
        };
        Tokenizer2.prototype.end = function() {
          if (this.running)
            this.finish();
        };
        Tokenizer2.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer2.prototype.resume = function() {
          this.running = true;
          if (this.index < this.buffer.length + this.offset) {
            this.parse();
          }
        };
        Tokenizer2.prototype.getIndex = function() {
          return this.index;
        };
        Tokenizer2.prototype.getSectionStart = function() {
          return this.sectionStart;
        };
        Tokenizer2.prototype.stateText = function(c) {
          if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
            if (this.index > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State2.BeforeTagName;
            this.sectionStart = this.index;
          } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateSpecialStartSequence = function(c) {
          var isEnd = this.sequenceIndex === this.currentSequence.length;
          var isMatch = isEnd ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            isEndOfTagSection(c)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (c | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!isMatch) {
            this.isSpecial = false;
          } else if (!isEnd) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0;
          this.state = State2.InTagName;
          this.stateInTagName(c);
        };
        Tokenizer2.prototype.stateInSpecialTag = function(c) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (c === CharCodes.Gt || isWhitespace2(c)) {
              var endOfText = this.index - this.currentSequence.length;
              if (this.sectionStart < endOfText) {
                var actualIndex = this.index;
                this.index = endOfText;
                this.cbs.ontext(this.sectionStart, endOfText);
                this.index = actualIndex;
              }
              this.isSpecial = false;
              this.sectionStart = endOfText + 2;
              this.stateInClosingTagName(c);
              return;
            }
            this.sequenceIndex = 0;
          }
          if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
          } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
              if (this.decodeEntities && c === CharCodes.Amp) {
                this.state = State2.BeforeEntity;
              }
            } else if (this.fastForwardTo(CharCodes.Lt)) {
              this.sequenceIndex = 1;
            }
          } else {
            this.sequenceIndex = Number(c === CharCodes.Lt);
          }
        };
        Tokenizer2.prototype.stateCDATASequence = function(c) {
          if (c === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
              this.state = State2.InCommentLike;
              this.currentSequence = Sequences.CdataEnd;
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
            }
          } else {
            this.sequenceIndex = 0;
            this.state = State2.InDeclaration;
            this.stateInDeclaration(c);
          }
        };
        Tokenizer2.prototype.fastForwardTo = function(c) {
          while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
              return true;
            }
          }
          this.index = this.buffer.length + this.offset - 1;
          return false;
        };
        Tokenizer2.prototype.stateInCommentLike = function(c) {
          if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
              if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, this.index, 2);
              } else {
                this.cbs.oncomment(this.sectionStart, this.index, 2);
              }
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
              this.state = State2.Text;
            }
          } else if (this.sequenceIndex === 0) {
            if (this.fastForwardTo(this.currentSequence[0])) {
              this.sequenceIndex = 1;
            }
          } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            this.sequenceIndex = 0;
          }
        };
        Tokenizer2.prototype.isTagStartChar = function(c) {
          return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
        };
        Tokenizer2.prototype.startSpecial = function(sequence, offset) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset;
          this.state = State2.SpecialStartSequence;
        };
        Tokenizer2.prototype.stateBeforeTagName = function(c) {
          if (c === CharCodes.ExclamationMark) {
            this.state = State2.BeforeDeclaration;
            this.sectionStart = this.index + 1;
          } else if (c === CharCodes.Questionmark) {
            this.state = State2.InProcessingInstruction;
            this.sectionStart = this.index + 1;
          } else if (this.isTagStartChar(c)) {
            var lower = c | 32;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
              this.startSpecial(Sequences.TitleEnd, 3);
            } else {
              this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
            }
          } else if (c === CharCodes.Slash) {
            this.state = State2.BeforeClosingTagName;
          } else {
            this.state = State2.Text;
            this.stateText(c);
          }
        };
        Tokenizer2.prototype.stateInTagName = function(c) {
          if (isEndOfTagSection(c)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          }
        };
        Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
          if (isWhitespace2(c)) {
          } else if (c === CharCodes.Gt) {
            this.state = State2.Text;
          } else {
            this.state = this.isTagStartChar(c) ? State2.InClosingTagName : State2.InSpecialComment;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInClosingTagName = function(c) {
          if (c === CharCodes.Gt || isWhitespace2(c)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterClosingTagName;
            this.stateAfterClosingTagName(c);
          }
        };
        Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
          if (c === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
              this.state = State2.InSpecialTag;
              this.sequenceIndex = 0;
            } else {
              this.state = State2.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
          } else if (c === CharCodes.Slash) {
            this.state = State2.InSelfClosingTag;
          } else if (!isWhitespace2(c)) {
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
          if (c === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false;
          } else if (!isWhitespace2(c)) {
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          }
        };
        Tokenizer2.prototype.stateInAttributeName = function(c) {
          if (c === CharCodes.Eq || isEndOfTagSection(c)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterAttributeName;
            this.stateAfterAttributeName(c);
          }
        };
        Tokenizer2.prototype.stateAfterAttributeName = function(c) {
          if (c === CharCodes.Eq) {
            this.state = State2.BeforeAttributeValue;
          } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          } else if (!isWhitespace2(c)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
          if (c === CharCodes.DoubleQuote) {
            this.state = State2.InAttributeValueDq;
            this.sectionStart = this.index + 1;
          } else if (c === CharCodes.SingleQuote) {
            this.state = State2.InAttributeValueSq;
            this.sectionStart = this.index + 1;
          } else if (!isWhitespace2(c)) {
            this.sectionStart = this.index;
            this.state = State2.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c);
          }
        };
        Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
          if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
            this.state = State2.BeforeAttributeName;
          } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
          this.handleInAttributeValue(c, CharCodes.DoubleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
          this.handleInAttributeValue(c, CharCodes.SingleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
          if (isWhitespace2(c) || c === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
          } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
          if (c === CharCodes.OpeningSquareBracket) {
            this.state = State2.CDATASequence;
            this.sequenceIndex = 0;
          } else {
            this.state = c === CharCodes.Dash ? State2.BeforeComment : State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInDeclaration = function(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeComment = function(c) {
          if (c === CharCodes.Dash) {
            this.state = State2.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
          } else {
            this.state = State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInSpecialComment = function(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
          var lower = c | 32;
          if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
          } else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
          } else {
            this.state = State2.InTagName;
            this.stateInTagName(c);
          }
        };
        Tokenizer2.prototype.stateBeforeEntity = function(c) {
          this.entityExcess = 1;
          this.entityResult = 0;
          if (c === CharCodes.Number) {
            this.state = State2.BeforeNumericEntity;
          } else if (c === CharCodes.Amp) {
          } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State2.InNamedEntity;
            this.stateInNamedEntity(c);
          }
        };
        Tokenizer2.prototype.stateInNamedEntity = function(c) {
          this.entityExcess += 1;
          this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
          if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            var valueLength = (masked >> 14) - 1;
            if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
              this.trieIndex += valueLength;
            } else {
              var entityStart = this.index - this.entityExcess + 1;
              if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
              }
              this.entityResult = this.trieIndex;
              this.trieIndex += valueLength;
              this.entityExcess = 0;
              this.sectionStart = this.index + 1;
              if (valueLength === 0) {
                this.emitNamedEntity();
              }
            }
          }
        };
        Tokenizer2.prototype.emitNamedEntity = function() {
          this.state = this.baseState;
          if (this.entityResult === 0) {
            return;
          }
          var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
          switch (valueLength) {
            case 1: {
              this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
              break;
            }
            case 2: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              break;
            }
            case 3: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        };
        Tokenizer2.prototype.stateBeforeNumericEntity = function(c) {
          if ((c | 32) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State2.InHexEntity;
          } else {
            this.state = State2.InNumericEntity;
            this.stateInNumericEntity(c);
          }
        };
        Tokenizer2.prototype.emitNumericEntity = function(strict) {
          var entityStart = this.index - this.entityExcess - 1;
          var numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
          if (numberStart !== this.index) {
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
          }
          this.state = this.baseState;
        };
        Tokenizer2.prototype.stateInNumericEntity = function(c) {
          if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c)) {
            this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.stateInHexEntity = function(c) {
          if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c)) {
            this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
            this.entityExcess++;
          } else if (isHexDigit(c)) {
            this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
        };
        Tokenizer2.prototype.cleanup = function() {
          if (this.running && this.sectionStart !== this.index) {
            if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
              this.cbs.ontext(this.sectionStart, this.index);
              this.sectionStart = this.index;
            } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = this.index;
            }
          }
        };
        Tokenizer2.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        };
        Tokenizer2.prototype.parse = function() {
          while (this.shouldContinue()) {
            var c = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case State2.Text: {
                this.stateText(c);
                break;
              }
              case State2.SpecialStartSequence: {
                this.stateSpecialStartSequence(c);
                break;
              }
              case State2.InSpecialTag: {
                this.stateInSpecialTag(c);
                break;
              }
              case State2.CDATASequence: {
                this.stateCDATASequence(c);
                break;
              }
              case State2.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(c);
                break;
              }
              case State2.InAttributeName: {
                this.stateInAttributeName(c);
                break;
              }
              case State2.InCommentLike: {
                this.stateInCommentLike(c);
                break;
              }
              case State2.InSpecialComment: {
                this.stateInSpecialComment(c);
                break;
              }
              case State2.BeforeAttributeName: {
                this.stateBeforeAttributeName(c);
                break;
              }
              case State2.InTagName: {
                this.stateInTagName(c);
                break;
              }
              case State2.InClosingTagName: {
                this.stateInClosingTagName(c);
                break;
              }
              case State2.BeforeTagName: {
                this.stateBeforeTagName(c);
                break;
              }
              case State2.AfterAttributeName: {
                this.stateAfterAttributeName(c);
                break;
              }
              case State2.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(c);
                break;
              }
              case State2.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(c);
                break;
              }
              case State2.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(c);
                break;
              }
              case State2.AfterClosingTagName: {
                this.stateAfterClosingTagName(c);
                break;
              }
              case State2.BeforeSpecialS: {
                this.stateBeforeSpecialS(c);
                break;
              }
              case State2.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(c);
                break;
              }
              case State2.InSelfClosingTag: {
                this.stateInSelfClosingTag(c);
                break;
              }
              case State2.InDeclaration: {
                this.stateInDeclaration(c);
                break;
              }
              case State2.BeforeDeclaration: {
                this.stateBeforeDeclaration(c);
                break;
              }
              case State2.BeforeComment: {
                this.stateBeforeComment(c);
                break;
              }
              case State2.InProcessingInstruction: {
                this.stateInProcessingInstruction(c);
                break;
              }
              case State2.InNamedEntity: {
                this.stateInNamedEntity(c);
                break;
              }
              case State2.BeforeEntity: {
                this.stateBeforeEntity(c);
                break;
              }
              case State2.InHexEntity: {
                this.stateInHexEntity(c);
                break;
              }
              case State2.InNumericEntity: {
                this.stateInNumericEntity(c);
                break;
              }
              default: {
                this.stateBeforeNumericEntity(c);
              }
            }
            this.index++;
          }
          this.cleanup();
        };
        Tokenizer2.prototype.finish = function() {
          if (this.state === State2.InNamedEntity) {
            this.emitNamedEntity();
          }
          if (this.sectionStart < this.index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer2.prototype.handleTrailingData = function() {
          var endIndex = this.buffer.length + this.offset;
          if (this.state === State2.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, endIndex, 0);
            } else {
              this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
          } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName) {
          } else {
            this.cbs.ontext(this.sectionStart, endIndex);
          }
        };
        Tokenizer2.prototype.emitPartial = function(start, endIndex) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
          } else {
            this.cbs.ontext(start, endIndex);
          }
        };
        Tokenizer2.prototype.emitCodePoint = function(cp) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribentity(cp);
          } else {
            this.cbs.ontextentity(cp);
          }
        };
        return Tokenizer2;
      }()
    );
    exports2.default = Tokenizer;
  }
});

// ../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/Parser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = void 0;
    var Tokenizer_js_1 = __importStar(require_Tokenizer());
    var decode_js_1 = require_decode();
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
    var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
    var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
    var openImpliesClose = /* @__PURE__ */ new Map([
      ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
      ["th", /* @__PURE__ */ new Set(["th"])],
      ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
      ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
      ["li", /* @__PURE__ */ new Set(["li"])],
      ["p", pTag],
      ["h1", pTag],
      ["h2", pTag],
      ["h3", pTag],
      ["h4", pTag],
      ["h5", pTag],
      ["h6", pTag],
      ["select", formTags],
      ["input", formTags],
      ["output", formTags],
      ["button", formTags],
      ["datalist", formTags],
      ["textarea", formTags],
      ["option", /* @__PURE__ */ new Set(["option"])],
      ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
      ["dd", ddtTags],
      ["dt", ddtTags],
      ["address", pTag],
      ["article", pTag],
      ["aside", pTag],
      ["blockquote", pTag],
      ["details", pTag],
      ["div", pTag],
      ["dl", pTag],
      ["fieldset", pTag],
      ["figcaption", pTag],
      ["figure", pTag],
      ["footer", pTag],
      ["form", pTag],
      ["header", pTag],
      ["hr", pTag],
      ["main", pTag],
      ["nav", pTag],
      ["ol", pTag],
      ["pre", pTag],
      ["section", pTag],
      ["table", pTag],
      ["ul", pTag],
      ["rt", rtpTags],
      ["rp", rtpTags],
      ["tbody", tableSectionTags],
      ["tfoot", tableSectionTags]
    ]);
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser = (
      /** @class */
      function() {
        function Parser2(cbs, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var _a, _b, _c, _d, _e;
          this.options = options2;
          this.startIndex = 0;
          this.endIndex = 0;
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.buffers = [];
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a = options2.lowerCaseTags) !== null && _a !== void 0 ? _a : !options2.xmlMode;
          this.lowerCaseAttributeNames = (_b = options2.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options2.xmlMode;
          this.tokenizer = new ((_c = options2.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser2.prototype.ontext = function(start, endIndex) {
          var _a, _b;
          var data = this.getSlice(start, endIndex);
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
          this.startIndex = endIndex;
        };
        Parser2.prototype.ontextentity = function(cp) {
          var _a, _b;
          var index = this.tokenizer.getSectionStart();
          this.endIndex = index - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
          this.startIndex = index;
        };
        Parser2.prototype.isVoidElement = function(name) {
          return !this.options.xmlMode && voidElements.has(name);
        };
        Parser2.prototype.onopentagname = function(start, endIndex) {
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          this.emitOpenTag(name);
        };
        Parser2.prototype.emitOpenTag = function(name) {
          var _a, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name;
          var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
          if (impliesClose) {
            while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
              var element = this.stack.pop();
              (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
            }
          }
          if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name)) {
              this.foreignContext.push(false);
            }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser2.prototype.endOpenTag = function(isImplied) {
          var _a, _b;
          this.startIndex = this.openTagStart;
          if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
        };
        Parser2.prototype.onopentagend = function(endIndex) {
          this.endIndex = endIndex;
          this.endOpenTag(false);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onclosetag = function(start, endIndex) {
          var _a, _b, _c, _d, _e, _f;
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
          }
          if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                var count2 = this.stack.length - pos;
                while (count2--) {
                  this.cbs.onclosetag(this.stack.pop(), count2 !== 0);
                }
              } else
                this.stack.length = pos;
            } else if (!this.options.xmlMode && name === "p") {
              this.emitOpenTag("p");
              this.closeCurrentTag(true);
            }
          } else if (!this.options.xmlMode && name === "br") {
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onselfclosingtag = function(endIndex) {
          this.endIndex = endIndex;
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            this.startIndex = endIndex + 1;
          } else {
            this.onopentagend(endIndex);
          }
        };
        Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
          var _a, _b;
          var name = this.tagname;
          this.endOpenTag(isOpenImplied);
          if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
          }
        };
        Parser2.prototype.onattribname = function(start, endIndex) {
          this.startIndex = start;
          var name = this.getSlice(start, endIndex);
          this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
        };
        Parser2.prototype.onattribdata = function(start, endIndex) {
          this.attribvalue += this.getSlice(start, endIndex);
        };
        Parser2.prototype.onattribentity = function(cp) {
          this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
        };
        Parser2.prototype.onattribend = function(quote, endIndex) {
          var _a, _b;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribvalue = "";
        };
        Parser2.prototype.getInstructionName = function(value) {
          var index = value.search(reNameEnd);
          var name = index < 0 ? value : value.substr(0, index);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          return name;
        };
        Parser2.prototype.ondeclaration = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncomment = function(start, endIndex, offset) {
          var _a, _b, _c, _d;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncdata = function(start, endIndex, offset) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex - offset);
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onend = function() {
          var _a, _b;
          if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
              ;
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        Parser2.prototype.reset = function() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack.length = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this.buffers.length = 0;
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
        };
        Parser2.prototype.parseComplete = function(data) {
          this.reset();
          this.end(data);
        };
        Parser2.prototype.getSlice = function(start, end) {
          while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
          }
          var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
          while (end - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            slice += this.buffers[0].slice(0, end - this.bufferOffset);
          }
          return slice;
        };
        Parser2.prototype.shiftBuffer = function() {
          this.bufferOffset += this.buffers[0].length;
          this.writeIndex--;
          this.buffers.shift();
        };
        Parser2.prototype.write = function(chunk) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
          }
          this.buffers.push(chunk);
          if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
          }
        };
        Parser2.prototype.end = function(chunk) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
            return;
          }
          if (chunk)
            this.write(chunk);
          this.ended = true;
          this.tokenizer.end();
        };
        Parser2.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser2.prototype.resume = function() {
          this.tokenizer.resume();
          while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
          }
          if (this.ended)
            this.tokenizer.end();
        };
        Parser2.prototype.parseChunk = function(chunk) {
          this.write(chunk);
        };
        Parser2.prototype.done = function(chunk) {
          this.end(chunk);
        };
        return Parser2;
      }()
    );
    exports2.Parser = Parser;
  }
});

// ../../node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports2.isTag = isTag;
    exports2.Root = ElementType.Root;
    exports2.Text = ElementType.Text;
    exports2.Directive = ElementType.Directive;
    exports2.Comment = ElementType.Comment;
    exports2.Script = ElementType.Script;
    exports2.Style = ElementType.Style;
    exports2.Tag = ElementType.Tag;
    exports2.CDATA = ElementType.CDATA;
    exports2.Doctype = ElementType.Doctype;
  }
});

// ../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/node.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.CDATA = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node = (
      /** @class */
      function() {
        function Node2() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node2.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node2.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node2;
      }()
    );
    exports2.Node = Node;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node)
    );
    exports2.DataNode = DataNode;
    var Text2 = (
      /** @class */
      function(_super) {
        __extends(Text3, _super);
        function Text3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text3.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text3;
      }(DataNode)
    );
    exports2.Text = Text2;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      }(DataNode)
    );
    exports2.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports2.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node)
    );
    exports2.NodeWithChildren = NodeWithChildren;
    var CDATA = (
      /** @class */
      function(_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      }(NodeWithChildren)
    );
    exports2.CDATA = CDATA;
    var Document = (
      /** @class */
      function(_super) {
        __extends(Document2, _super);
        function Document2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document2.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document2;
      }(NodeWithChildren)
    );
    exports2.Document = Document;
    var Element = (
      /** @class */
      function(_super) {
        __extends(Element2, _super);
        function Element2(name, attribs, children, type2) {
          if (children === void 0) {
            children = [];
          }
          if (type2 === void 0) {
            type2 = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type2;
          return _this;
        }
        Object.defineProperty(Element2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element2;
      }(NodeWithChildren)
    );
    exports2.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports2.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports2.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports2.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports2.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports2.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports2.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports2.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text2(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports2.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
      }
      return children;
    }
  }
});

// ../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node();
    __exportStar(require_node(), exports2);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback2, options2, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options2 === "function") {
            elementCB = options2;
            options2 = defaultOpts;
          }
          if (typeof callback2 === "object") {
            options2 = callback2;
            callback2 = void 0;
          }
          this.callback = callback2 !== null && callback2 !== void 0 ? callback2 : null;
          this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type2 = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type2);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports2.DomHandler = DomHandler;
    exports2.default = DomHandler;
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/encode-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
      }
      return arr;
    }
    exports2.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
    exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str2, index) {
      return str2.codePointAt(index);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c, index) {
        return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
      }
    );
    function encodeXML(str2) {
      var ret = "";
      var lastIdx = 0;
      var match2;
      while ((match2 = exports2.xmlReplacer.exec(str2)) !== null) {
        var i = match2.index;
        var char = str2.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str2.substring(lastIdx, i) + next;
          lastIdx = i + 1;
        } else {
          ret += "".concat(str2.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str2, i).toString(16), ";");
          lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str2.substr(lastIdx);
    }
    exports2.encodeXML = encodeXML;
    exports2.escape = encodeXML;
    function getEscaper(regex, map4) {
      return function escape2(data) {
        var match2;
        var lastIdx = 0;
        var result = "";
        while (match2 = regex.exec(data)) {
          if (lastIdx !== match2.index) {
            result += data.substring(lastIdx, match2.index);
          }
          result += map4.get(match2[0].charCodeAt(0));
          lastIdx = match2.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/encode.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeNonAsciiHTML = exports2.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports2.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports2.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str2) {
      var ret = "";
      var lastIdx = 0;
      var match2;
      while ((match2 = regExp.exec(str2)) !== null) {
        var i = match2.index;
        ret += str2.substring(lastIdx, i);
        var char = str2.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i + 1 < str2.length) {
            var nextChar = str2.charCodeAt(i + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str2, i);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str2.substr(lastIdx);
    }
  }
});

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
    function decode(data, options2) {
      if (options2 === void 0) {
        options2 = EntityLevel.XML;
      }
      var level = typeof options2 === "number" ? options2 : options2.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options2 === "object" ? options2.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports2.decode = decode;
    function decodeStrict(data, options2) {
      var _a;
      if (options2 === void 0) {
        options2 = EntityLevel.XML;
      }
      var opts = typeof options2 === "number" ? { level: options2 } : options2;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports2.decodeStrict = decodeStrict;
    function encode(data, options2) {
      if (options2 === void 0) {
        options2 = EntityLevel.XML;
      }
      var opts = typeof options2 === "number" ? { level: options2 } : options2;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports2.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// ../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeNames = exports2.elementNames = void 0;
    exports2.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports2.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// ../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.render = void 0;
    var ElementType = __importStar(require_lib());
    var entities_1 = require_lib3();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options2);
      }
      return output;
    }
    exports2.render = render;
    exports2.default = render;
    function renderNode(node, options2) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options2);
        case ElementType.Doctype:
        case ElementType.Directive:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options2);
        case ElementType.Text:
          return renderText(node, options2);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/stringify.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.innerText = exports2.textContent = exports2.getText = exports2.getInnerHTML = exports2.getOuterHTML = void 0;
    var domhandler_1 = require_lib2();
    var dom_serializer_1 = __importDefault(require_lib4());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options2) {
      return (0, dom_serializer_1.default)(node, options2);
    }
    exports2.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options2) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options2);
      }).join("") : "";
    }
    exports2.getInnerHTML = getInnerHTML;
    function getText2(node) {
      if (Array.isArray(node))
        return node.map(getText2).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText2(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText2(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.getText = getText2;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.innerText = innerText;
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/traversal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prevElementSibling = exports2.nextElementSibling = exports2.getName = exports2.hasAttrib = exports2.getAttributeValue = exports2.getSiblings = exports2.getParent = exports2.getChildren = void 0;
    var domhandler_1 = require_lib2();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    exports2.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports2.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports2.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports2.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports2.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports2.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports2.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports2.prevElementSibling = prevElementSibling;
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/manipulation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepend = exports2.prependChild = exports2.append = exports2.appendChild = exports2.replaceElement = exports2.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    exports2.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    exports2.replaceElement = replaceElement;
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports2.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports2.append = append;
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports2.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports2.prepend = prepend;
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/querying.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findAll = exports2.existsOne = exports2.findOne = exports2.findOneChild = exports2.find = exports2.filter = void 0;
    var domhandler_1 = require_lib2();
    function filter2(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    exports2.filter = filter2;
    function find(test, nodes, recurse, limit) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports2.find = find;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports2.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i = 0; i < nodes.length && !elem; i++) {
        var node = nodes[i];
        if (!(0, domhandler_1.isTag)(node)) {
          continue;
        } else if (test(node)) {
          elem = node;
        } else if (recurse && node.children.length > 0) {
          elem = findOne(test, node.children, true);
        }
      }
      return elem;
    }
    exports2.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
      });
    }
    exports2.existsOne = existsOne;
    function findAll(test, nodes) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem))
          continue;
        if (test(elem))
          result.push(elem);
        if (elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports2.findAll = findAll;
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/legacy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getElementsByTagType = exports2.getElementsByTagName = exports2.getElementById = exports2.getElements = exports2.testElement = void 0;
    var domhandler_1 = require_lib2();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type2) {
        if (typeof type2 === "function") {
          return function(elem) {
            return type2(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type2;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest(options2) {
      var funcs = Object.keys(options2).map(function(key) {
        var value = options2[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options2, node) {
      var test = compileTest(options2);
      return test ? test(node) : true;
    }
    exports2.testElement = testElement;
    function getElements(options2, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options2);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports2.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports2.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    exports2.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type2, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type2), nodes, recurse, limit);
    }
    exports2.getElementsByTagType = getElementsByTagType;
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
    var domhandler_1 = require_lib2();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports2.removeSubsets = removeSubsets;
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current2 = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current2) {
        aParents.unshift(current2);
        current2 = current2.parent;
      }
      current2 = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current2) {
        bParents.unshift(current2);
        current2 = current2.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    exports2.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
      });
      nodes.sort(function(a, b) {
        var relative2 = compareDocumentPosition(a, b);
        if (relative2 & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative2 & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports2.uniqueSort = uniqueSort;
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/feeds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFeed = void 0;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports2.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry2 = { media: getMediaElements(children) };
          addConditionally(entry2, "id", "id", children);
          addConditionally(entry2, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry2.link = href2;
          }
          var description = fetch("summary", children) || fetch("content", children);
          if (description) {
            entry2.description = description;
          }
          var pubDate = fetch("updated", children);
          if (pubDate) {
            entry2.pubDate = new Date(pubDate);
          }
          return entry2;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry2 = { media: getMediaElements(children) };
          addConditionally(entry2, "id", "guid", children);
          addConditionally(entry2, "title", "title", children);
          addConditionally(entry2, "link", "link", children);
          addConditionally(entry2, "description", "description", children);
          var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
          if (pubDate)
            entry2.pubDate = new Date(pubDate);
          return entry2;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// ../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
    __exportStar(require_stringify(), exports2);
    __exportStar(require_traversal(), exports2);
    __exportStar(require_manipulation(), exports2);
    __exportStar(require_querying(), exports2);
    __exportStar(require_legacy(), exports2);
    __exportStar(require_helpers(), exports2);
    __exportStar(require_feeds(), exports2);
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// ../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomUtils = exports2.parseFeed = exports2.getFeed = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DefaultHandler = exports2.DomHandler = exports2.Parser = void 0;
    var Parser_js_1 = require_Parser();
    var Parser_js_2 = require_Parser();
    Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
      return Parser_js_2.Parser;
    } });
    var domhandler_1 = require_lib2();
    var domhandler_2 = require_lib2();
    Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_2.DomHandler;
    } });
    function parseDocument(data, options2) {
      var handler = new domhandler_1.DomHandler(void 0, options2);
      new Parser_js_1.Parser(handler, options2).end(data);
      return handler.root;
    }
    exports2.parseDocument = parseDocument;
    function parseDOM(data, options2) {
      return parseDocument(data, options2).children;
    }
    exports2.parseDOM = parseDOM;
    function createDomStream(callback2, options2, elementCallback) {
      var handler = new domhandler_1.DomHandler(callback2, options2, elementCallback);
      return new Parser_js_1.Parser(handler, options2);
    }
    exports2.createDomStream = createDomStream;
    var Tokenizer_js_1 = require_Tokenizer();
    Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault(Tokenizer_js_1).default;
    } });
    exports2.ElementType = __importStar(require_lib());
    var domutils_1 = require_lib5();
    var domutils_2 = require_lib5();
    Object.defineProperty(exports2, "getFeed", { enumerable: true, get: function() {
      return domutils_2.getFeed;
    } });
    var parseFeedDefaultOptions = { xmlMode: true };
    function parseFeed(feed, options2) {
      if (options2 === void 0) {
        options2 = parseFeedDefaultOptions;
      }
      return (0, domutils_1.getFeed)(parseDOM(feed, options2));
    }
    exports2.parseFeed = parseFeed;
    exports2.DomUtils = __importStar(require_lib5());
  }
});

// ../../node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string2) => {
      if (typeof string2 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// ../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object = __commonJS({
  "../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isObject3(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function isPlainObject3(o) {
      var ctor, prot;
      if (isObject3(o) === false)
        return false;
      ctor = o.constructor;
      if (ctor === void 0)
        return true;
      prot = ctor.prototype;
      if (isObject3(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    exports2.isPlainObject = isPlainObject3;
  }
});

// ../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options2) {
      return options2.clone !== false && options2.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options2) : value;
    }
    function defaultArrayMerge(target, source, options2) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options2);
      });
    }
    function getMergeFunction(key, options2) {
      if (!options2.customMerge) {
        return deepmerge;
      }
      var customMerge = options2.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options2) {
      var destination = {};
      if (options2.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options2);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options2.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options2)(target[key], source[key], options2);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options2);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options2) {
      options2 = options2 || {};
      options2.arrayMerge = options2.arrayMerge || defaultArrayMerge;
      options2.isMergeableObject = options2.isMergeableObject || isMergeableObject;
      options2.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options2);
      } else if (sourceIsArray) {
        return options2.arrayMerge(target, source, options2);
      } else {
        return mergeObject(target, source, options2);
      }
    }
    deepmerge.all = function deepmergeAll(array, options2) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options2);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// ../../node_modules/.pnpm/parse-srcset@1.0.2/node_modules/parse-srcset/src/parse-srcset.js
var require_parse_srcset = __commonJS({
  "../../node_modules/.pnpm/parse-srcset@1.0.2/node_modules/parse-srcset/src/parse-srcset.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.parseSrcset = factory();
      }
    })(exports2, function() {
      return function(input) {
        function isSpace(c2) {
          return c2 === " " || // space
          c2 === "	" || // horizontal tab
          c2 === "\n" || // new line
          c2 === "\f" || // form feed
          c2 === "\r";
        }
        function collectCharacters(regEx) {
          var chars, match2 = regEx.exec(input.substring(pos));
          if (match2) {
            chars = match2[0];
            pos += chars.length;
            return chars;
          }
        }
        var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
        while (true) {
          collectCharacters(regexLeadingCommasOrSpaces);
          if (pos >= inputLength) {
            return candidates;
          }
          url = collectCharacters(regexLeadingNotSpaces);
          descriptors = [];
          if (url.slice(-1) === ",") {
            url = url.replace(regexTrailingCommas, "");
            parseDescriptors();
          } else {
            tokenize2();
          }
        }
        function tokenize2() {
          collectCharacters(regexLeadingSpaces);
          currentDescriptor = "";
          state = "in descriptor";
          while (true) {
            c = input.charAt(pos);
            if (state === "in descriptor") {
              if (isSpace(c)) {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                  currentDescriptor = "";
                  state = "after descriptor";
                }
              } else if (c === ",") {
                pos += 1;
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else if (c === "(") {
                currentDescriptor = currentDescriptor + c;
                state = "in parens";
              } else if (c === "") {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c;
              }
            } else if (state === "in parens") {
              if (c === ")") {
                currentDescriptor = currentDescriptor + c;
                state = "in descriptor";
              } else if (c === "") {
                descriptors.push(currentDescriptor);
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c;
              }
            } else if (state === "after descriptor") {
              if (isSpace(c)) {
              } else if (c === "") {
                parseDescriptors();
                return;
              } else {
                state = "in descriptor";
                pos -= 1;
              }
            }
            pos += 1;
          }
        }
        function parseDescriptors() {
          var pError = false, w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;
          for (i = 0; i < descriptors.length; i++) {
            desc = descriptors[i];
            lastChar = desc[desc.length - 1];
            value = desc.substring(0, desc.length - 1);
            intVal = parseInt(value, 10);
            floatVal = parseFloat(value);
            if (regexNonNegativeInteger.test(value) && lastChar === "w") {
              if (w || d) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                w = intVal;
              }
            } else if (regexFloatingPoint.test(value) && lastChar === "x") {
              if (w || d || h) {
                pError = true;
              }
              if (floatVal < 0) {
                pError = true;
              } else {
                d = floatVal;
              }
            } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
              if (h || d) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                h = intVal;
              }
            } else {
              pError = true;
            }
          }
          if (!pError) {
            candidate.url = url;
            if (w) {
              candidate.w = w;
            }
            if (d) {
              candidate.d = d;
            }
            if (h) {
              candidate.h = h;
            }
            candidates.push(candidate);
          } else if (console && console.log) {
            console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
          }
        }
      };
    });
  }
});

// ../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "../../node_modules/.pnpm/picocolors@1.0.0/node_modules/picocolors/picocolors.js"(exports2, module2) {
    var tty = require("tty");
    var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
    var formatter = (open2, close, replace = open2) => (input) => {
      let string2 = "" + input;
      let index = string2.indexOf(close, open2.length);
      return ~index ? open2 + replaceClose(string2, close, replace, index) + close : open2 + string2 + close;
    };
    var replaceClose = (string2, close, replace, index) => {
      let start = string2.substring(0, index) + replace;
      let end = string2.substring(index + close.length);
      let nextIndex = end.indexOf(close);
      return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
    };
    var createColors = (enabled = isColorSupported) => ({
      isColorSupported: enabled,
      reset: enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String,
      bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
      dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
      italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
      underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
      inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
      hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
      strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
      black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
      red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
      green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
      yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
      blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
      magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
      cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
      white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
      gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
      bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
      bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
      bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
      bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
      bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
      bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
      bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
      bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
    });
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/tokenize.js"(exports2, module2) {
    "use strict";
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module2.exports = function tokenizer(input, options2 = {}) {
      let css = input.css.valueOf();
      let ignore = options2.ignoreErrors;
      let code, next, quote, content, escape2;
      let escaped, escapePos, prev, n, currentToken;
      let length = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos);
        switch (code) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n = css.charCodeAt(pos + 1);
            if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["string", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape2 = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape2 = !escape2;
            }
            code = css.charCodeAt(next + 1);
            if (escape2 && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        endOfFile,
        nextToken,
        position
      };
    };
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/terminal-highlight.js
var require_terminal_highlight = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/terminal-highlight.js"(exports2, module2) {
    "use strict";
    var pico = require_picocolors();
    var tokenizer = require_tokenize();
    var Input;
    function registerInput(dependant) {
      Input = dependant;
    }
    var HIGHLIGHT_THEME = {
      ";": pico.yellow,
      ":": pico.yellow,
      "(": pico.cyan,
      ")": pico.cyan,
      "[": pico.yellow,
      "]": pico.yellow,
      "{": pico.yellow,
      "}": pico.yellow,
      "at-word": pico.cyan,
      "brackets": pico.cyan,
      "call": pico.cyan,
      "class": pico.yellow,
      "comment": pico.gray,
      "hash": pico.magenta,
      "string": pico.green
    };
    function getTokenType([type2, value], processor) {
      if (type2 === "word") {
        if (value[0] === ".") {
          return "class";
        }
        if (value[0] === "#") {
          return "hash";
        }
      }
      if (!processor.endOfFile()) {
        let next = processor.nextToken();
        processor.back(next);
        if (next[0] === "brackets" || next[0] === "(")
          return "call";
      }
      return type2;
    }
    function terminalHighlight(css) {
      let processor = tokenizer(new Input(css), { ignoreErrors: true });
      let result = "";
      while (!processor.endOfFile()) {
        let token = processor.nextToken();
        let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
        if (color) {
          result += token[1].split(/\r?\n/).map((i) => color(i)).join("\n");
        } else {
          result += token[1];
        }
      }
      return result;
    }
    terminalHighlight.registerInput = registerInput;
    module2.exports = terminalHighlight;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
    "use strict";
    var pico = require_picocolors();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = class _CssSyntaxError extends Error {
      constructor(message, line, column, source, file, plugin) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin) {
          this.plugin = plugin;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          if (typeof line === "number") {
            this.line = line;
            this.column = column;
          } else {
            this.line = line.line;
            this.column = line.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color) {
        if (!this.source)
          return "";
        let css = this.source;
        if (color == null)
          color = pico.isColorSupported;
        if (terminalHighlight) {
          if (color)
            css = terminalHighlight(css);
        }
        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark, aside;
        if (color) {
          let { bold, gray, red } = pico.createColors(true);
          mark = (text) => bold(red(text));
          aside = (text) => gray(text);
        } else {
          mark = aside = (str2) => str2;
        }
        return lines.slice(start, end).map((line, index) => {
          let number = start + 1 + index;
          let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === this.line) {
            let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + line;
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module2.exports = CssSyntaxError;
    CssSyntaxError.default = CssSyntaxError;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports.isClean = Symbol("isClean");
    module2.exports.my = Symbol("my");
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringifier.js"(exports2, module2) {
    "use strict";
    var DEFAULT_RAW = {
      after: "\n",
      beforeClose: "\n",
      beforeComment: "\n",
      beforeDecl: "\n",
      beforeOpen: " ",
      beforeRule: "\n",
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function capitalize(str2) {
      return str2[0].toUpperCase() + str2.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      atrule(node, semicolon) {
        let name = "@" + node.name;
        let params = node.params ? this.rawValue(node, "params") : "";
        if (typeof node.raws.afterName !== "undefined") {
          name += node.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node.nodes) {
          this.block(node, name + params);
        } else {
          let end = (node.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name + params + end, node);
        }
      }
      beforeAfter(node, detect) {
        let value;
        if (node.type === "decl") {
          value = this.raw(node, null, "beforeDecl");
        } else if (node.type === "comment") {
          value = this.raw(node, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node, null, "beforeRule");
        } else {
          value = this.raw(node, null, "beforeClose");
        }
        let buf = node.parent;
        let depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value.includes("\n")) {
          let indent = this.raw(node, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth; step++)
              value += indent;
          }
        }
        return value;
      }
      block(node, start) {
        let between = this.raw(node, "between", "beforeOpen");
        this.builder(start + between + "{", node, "start");
        let after;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after = this.raw(node, "after");
        } else {
          after = this.raw(node, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node, "end");
      }
      body(node) {
        let last2 = node.nodes.length - 1;
        while (last2 > 0) {
          if (node.nodes[last2].type !== "comment")
            break;
          last2 -= 1;
        }
        let semicolon = this.raw(node, "semicolon");
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last2 !== i || semicolon);
        }
      }
      comment(node) {
        let left = this.raw(node, "left", "commentLeft");
        let right = this.raw(node, "right", "commentRight");
        this.builder("/*" + left + node.text + right + "*/", node);
      }
      decl(node, semicolon) {
        let between = this.raw(node, "between", "colon");
        let string2 = node.prop + between + this.rawValue(node, "value");
        if (node.important) {
          string2 += node.raws.important || " !important";
        }
        if (semicolon)
          string2 += ";";
        this.builder(string2, node);
      }
      document(node) {
        this.body(node);
      }
      raw(node, own, detect) {
        let value;
        if (!detect)
          detect = own;
        if (own) {
          value = node.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        let parent = node.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root = node.root();
        if (!root.rawCache)
          root.rawCache = {};
        if (typeof root.rawCache[detect] !== "undefined") {
          return root.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node, detect);
        } else {
          let method = "raw" + capitalize(detect);
          if (this[method]) {
            value = this[method](root, node);
          } else {
            root.walk((i) => {
              value = i.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root.rawCache[detect] = value;
        return value;
      }
      rawBeforeClose(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length > 0) {
            if (typeof i.raws.after !== "undefined") {
              value = i.raws.after;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeComment(root, node) {
        let value;
        root.walkComments((i) => {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeDecl(root, node) {
        let value;
        root.walkDecls((i) => {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeRule");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeOpen(root) {
        let value;
        root.walk((i) => {
          if (i.type !== "decl") {
            value = i.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawBeforeRule(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && (i.parent !== root || root.first !== i)) {
            if (typeof i.raws.before !== "undefined") {
              value = i.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawColon(root) {
        let value;
        root.walkDecls((i) => {
          if (typeof i.raws.between !== "undefined") {
            value = i.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      }
      rawEmptyBody(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length === 0) {
            value = i.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawIndent(root) {
        if (root.raws.indent)
          return root.raws.indent;
        let value;
        root.walk((i) => {
          let p = i.parent;
          if (p && p !== root && p.parent && p.parent === root) {
            if (typeof i.raws.before !== "undefined") {
              let parts = i.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value;
      }
      rawSemicolon(root) {
        let value;
        root.walk((i) => {
          if (i.nodes && i.nodes.length && i.last.type === "decl") {
            value = i.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawValue(node, prop) {
        let value = node[prop];
        let raw = node.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      }
      root(node) {
        this.body(node);
        if (node.raws.after)
          this.builder(node.raws.after);
      }
      rule(node) {
        this.block(node, this.rawValue(node, "selector"));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, "end");
        }
      }
      stringify(node, semicolon) {
        if (!this[node.type]) {
          throw new Error(
            "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
          );
        }
        this[node.type](node, semicolon);
      }
    };
    module2.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/stringify.js"(exports2, module2) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify2(node, builder) {
      let str2 = new Stringifier(builder);
      str2.stringify(node);
    }
    module2.exports = stringify2;
    stringify2.default = stringify2;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/node.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/node.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var CssSyntaxError = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify2 = require_stringify2();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i)) {
          continue;
        }
        if (i === "proxyCache")
          continue;
        let value = obj[i];
        let type2 = typeof value;
        if (i === "parent" && type2 === "object") {
          if (parent)
            cloned[i] = parent;
        } else if (i === "source") {
          cloned[i] = value;
        } else if (Array.isArray(value)) {
          cloned[i] = value.map((j) => cloneNode(j, cloned));
        } else {
          if (type2 === "object" && value !== null)
            value = cloneNode(value);
          cloned[i] = value;
        }
      }
      return cloned;
    }
    var Node = class {
      constructor(defaults2 = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults2) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node of defaults2[name]) {
              if (typeof node.clone === "function") {
                this.append(node.clone());
              } else {
                this.append(node);
              }
            }
          } else {
            this[name] = defaults2[name];
          }
        }
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
          );
        }
        return error;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      error(message, opts = {}) {
        if (this.source) {
          let { end, start } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { column: start.column, line: start.line },
            { column: end.column, line: end.line },
            opts
          );
        }
        return new CssSyntaxError(message);
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
            prop === "text") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      next() {
        if (!this.parent)
          return void 0;
        let index = this.parent.index(this);
        return this.parent.nodes[index + 1];
      }
      positionBy(opts, stringRepresentation) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index, stringRepresentation);
        } else if (opts.word) {
          stringRepresentation = this.toString();
          let index = stringRepresentation.indexOf(opts.word);
          if (index !== -1)
            pos = this.positionInside(index, stringRepresentation);
        }
        return pos;
      }
      positionInside(index, stringRepresentation) {
        let string2 = stringRepresentation || this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;
        for (let i = 0; i < index; i++) {
          if (string2[i] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return { column, line };
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index = this.parent.index(this);
        return this.parent.nodes[index - 1];
      }
      rangeBy(opts) {
        let start = {
          column: this.source.start.column,
          line: this.source.start.line
        };
        let end = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: start.column + 1,
          line: start.line
        };
        if (opts.word) {
          let stringRepresentation = this.toString();
          let index = stringRepresentation.indexOf(opts.word);
          if (index !== -1) {
            start = this.positionInside(index, stringRepresentation);
            end = this.positionInside(index + opts.word.length, stringRepresentation);
          }
        } else {
          if (opts.start) {
            start = {
              column: opts.start.column,
              line: opts.start.line
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              column: opts.end.column,
              line: opts.end.line
            };
          } else if (typeof opts.endIndex === "number") {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { column: start.column + 1, line: start.line };
        }
        return { end, start };
      }
      raw(prop, defaultType) {
        let str2 = new Stringifier();
        return str2.raw(this, prop, defaultType);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node of nodes) {
            if (node === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node);
              bookmark = node;
            } else {
              this.parent.insertBefore(bookmark, node);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      root() {
        let result = this;
        while (result.parent && result.parent.type !== "document") {
          result = result.parent;
        }
        return result;
      }
      toJSON(_, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value = this[name];
          if (Array.isArray(value)) {
            fixed[name] = value.map((i) => {
              if (typeof i === "object" && i.toJSON) {
                return i.toJSON(null, inputs);
              } else {
                return i;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name] = value.toJSON(null, inputs);
          } else if (name === "source") {
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              end: value.end,
              inputId,
              start: value.start
            };
          } else {
            fixed[name] = value;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      toString(stringifier = stringify2) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result = "";
        stringifier(this, (i) => {
          result += i;
        });
        return result;
      }
      warn(result, text, opts) {
        let data = { node: this };
        for (let i in opts)
          data[i] = opts[i];
        return result.warn(text, data);
      }
      get proxyOf() {
        return this;
      }
    };
    module2.exports = Node;
    Node.default = Node;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/declaration.js"(exports2, module2) {
    "use strict";
    var Node = require_node2();
    var Declaration = class extends Node {
      constructor(defaults2) {
        if (defaults2 && typeof defaults2.value !== "undefined" && typeof defaults2.value !== "string") {
          defaults2 = { ...defaults2, value: String(defaults2.value) };
        }
        super(defaults2);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module2.exports = Declaration;
    Declaration.default = Declaration;
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize2 = lruMemoize(function normalize3(aPath) {
      var path8 = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path8 = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path8);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path8.indexOf("/", start);
        if (i === -1) {
          parts.push(path8.slice(start));
          break;
        } else {
          parts.push(path8.slice(start, i));
          while (i < path8.length && path8[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path8 = parts.join("/");
      if (path8 === "") {
        path8 = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path8;
        return urlGenerate(url);
      }
      return path8;
    });
    exports2.normalize = normalize2;
    function join9(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join9;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative2;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity3(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity3 : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity3 : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str2) {
      return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join9(urlGenerate(parsed), sourceURL);
      }
      return normalize2(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/array-set.js"(exports2) {
    var util2 = require_util();
    var has2 = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set3 = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set3.add(aArray[i], aAllowDuplicates);
      }
      return set3;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has2.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util2.toSetString(aStr);
        return has2.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util2.toSetString(aStr);
        if (has2.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/mapping-list.js"(exports2) {
    var util2 = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util2.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util2 = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util2.getArg(aArgs, "file", null);
      this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
      this._ignoreInvalidMapping = util2.getArg(aArgs, "ignoreInvalidMapping", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot
      }));
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util2.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util2.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util2.getArg(aArgs, "generated");
      var original = util2.getArg(aArgs, "original", null);
      var source = util2.getArg(aArgs, "source", null);
      var name = util2.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
          return;
        }
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util2.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util2.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util2.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util2.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util2.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util2.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util2.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        var message = "Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        });
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util2.relative(aSourceRoot, source);
        }
        var key = util2.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map4 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map4.file = this._file;
      }
      if (this._sourceRoot != null) {
        map4.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map4.sourcesContent = this._generateSourcesContent(map4.sources, map4.sourceRoot);
      }
      return map4;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/quick-sort.js"(exports2) {
    function SortTemplate(comparator) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator2, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator2(ary[j], pivot, false) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q2 = i + 1;
          doQuickSort(ary, comparator2, p, q2 - 1);
          doQuickSort(ary, comparator2, q2 + 1, r);
        }
      }
      return doQuickSort;
    }
    function cloneSort(comparator) {
      let template = SortTemplate.toString();
      let templateFn = new Function(`return ${template}`)();
      return templateFn(comparator);
    }
    var sortCache = /* @__PURE__ */ new WeakMap();
    exports2.quickSort = function(ary, comparator, start = 0) {
      let doQuickSort = sortCache.get(comparator);
      if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
      }
      doQuickSort(ary, comparator, start, ary.length - 1);
    };
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/source-map-consumer.js"(exports2) {
    var util2 = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      var boundCallback = aCallback.bind(context);
      var names = this._names;
      var sources = this._sources;
      var sourceMapURL = this._sourceMapURL;
      for (var i = 0, n = mappings.length; i < n; i++) {
        var mapping = mappings[i];
        var source = mapping.source === null ? null : sources.at(mapping.source);
        source = util2.computeSourceURL(sourceRoot, source, sourceMapURL);
        boundCallback({
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : names.at(mapping.name)
        });
      }
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util2.getArg(aArgs, "line");
      var needle = {
        source: util2.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util2.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap, "version");
      var sources = util2.getArg(sourceMap, "sources");
      var names = util2.getArg(sourceMap, "names", []);
      var sourceRoot = util2.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util2.getArg(sourceMap, "sourcesContent", null);
      var mappings = util2.getArg(sourceMap, "mappings");
      var file = util2.getArg(sourceMap, "file", null);
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      if (sourceRoot) {
        sourceRoot = util2.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util2.normalize).map(function(source) {
        return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source) ? util2.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util2.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var compareGenerated = util2.compareByGeneratedPositionsDeflatedNoLine;
    function sortGenerated(array, start) {
      let l = array.length;
      let n = array.length - start;
      if (n <= 1) {
        return;
      } else if (n == 2) {
        let a = array[start];
        let b = array[start + 1];
        if (compareGenerated(a, b) > 0) {
          array[start] = b;
          array[start + 1] = a;
        }
      } else if (n < 20) {
        for (let i = start; i < l; i++) {
          for (let j = i; j > start; j--) {
            let a = array[j - 1];
            let b = array[j];
            if (compareGenerated(a, b) <= 0) {
              break;
            }
            array[j - 1] = b;
            array[j] = a;
          }
        }
      } else {
        quickSort(array, compareGenerated, start);
      }
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str2, segment, end, value;
      let subarrayStart = 0;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
          sortGenerated(generatedMappings, subarrayStart);
          subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str2 = aStr.slice(index, end);
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            let currentSource = mapping.source;
            while (originalMappings.length <= currentSource) {
              originalMappings.push(null);
            }
            if (originalMappings[currentSource] === null) {
              originalMappings[currentSource] = [];
            }
            originalMappings[currentSource].push(mapping);
          }
        }
      }
      sortGenerated(generatedMappings, subarrayStart);
      this.__generatedMappings = generatedMappings;
      for (var i = 0; i < originalMappings.length; i++) {
        if (originalMappings[i] != null) {
          quickSort(originalMappings[i], util2.compareByOriginalPositionsNoSource);
        }
      }
      this.__originalMappings = [].concat(...originalMappings);
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util2.compareByGeneratedPositionsDeflated,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util2.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util2.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util2.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util2.getArg(mapping, "originalLine", null),
            column: util2.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util2.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util2.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util2.getArg(aArgs, "line"),
        originalColumn: util2.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap, "version");
      var sections = util2.getArg(sourceMap, "sections");
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util2.getArg(s, "offset");
        var offsetLine = util2.getArg(offset, "line");
        var offsetColumn = util2.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content || content === "") {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util2.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util2.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util2 = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util2.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str2 = "";
      this.walk(function(chunk) {
        str2 += chunk;
      });
      return str2;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map4 = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map4.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map4.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map4.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map4.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map4 };
    };
    exports2.SourceNode = SourceNode;
  }
});

// ../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "../../node_modules/.pnpm/source-map-js@1.2.0/node_modules/source-map-js/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// ../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/non-secure/index.cjs"(exports2, module2) {
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet2, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i = size;
        while (i--) {
          id += alphabet2[Math.random() * alphabet2.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module2.exports = { nanoid, customAlphabet };
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/previous-map.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { existsSync: existsSync2, readFileSync } = require("fs");
    var { dirname: dirname4, join: join9 } = require("path");
    function fromBase64(str2) {
      if (Buffer) {
        return Buffer.from(str2, "base64").toString();
      } else {
        return window.atob(str2);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname4(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(map4) {
        if (typeof map4 !== "object")
          return false;
        return typeof map4.mappings === "string" || typeof map4._mappings === "string" || Array.isArray(map4.sections);
      }
      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments)
          return;
        let start = css.lastIndexOf(comments.pop());
        let end = css.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css.substring(start, end));
        }
      }
      loadFile(path8) {
        this.root = dirname4(path8);
        if (existsSync2(path8)) {
          this.mapFile = path8;
          return readFileSync(path8, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map4 = this.loadFile(prevPath);
              if (!map4) {
                throw new Error(
                  "Unable to load previous source map: " + prevPath.toString()
                );
              }
              return map4;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error(
              "Unsupported previous source map format: " + prev.toString()
            );
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map4 = this.annotation;
          if (file)
            map4 = join9(dirname4(file), map4);
          return this.loadFile(map4);
        }
      }
      startWith(string2, start) {
        if (!string2)
          return false;
        return string2.substr(0, start.length) === start;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    };
    module2.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/input.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath: fileURLToPath3, pathToFileURL } = require("url");
    var { isAbsolute, resolve } = require("path");
    var { nanoid } = require_non_secure();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve && isAbsolute);
    var Input = class {
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map4 = new PreviousMap(this.css, opts);
          if (map4.text) {
            this.map = map4;
            let file = map4.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      error(message, line, column, opts = {}) {
        let result, endLine, endColumn;
        if (line && typeof line === "object") {
          let start = line;
          let end = column;
          if (typeof start.offset === "number") {
            let pos = this.fromOffset(start.offset);
            line = pos.line;
            column = pos.col;
          } else {
            line = start.line;
            column = start.column;
          }
          if (typeof end.offset === "number") {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }
        let origin = this.origin(line, column, endLine, endColumn);
        if (origin) {
          result = new CssSyntaxError(
            message,
            origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
            origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result = new CssSyntaxError(
            message,
            endLine === void 0 ? line : { column, line },
            endLine === void 0 ? column : { column: endColumn, line: endLine },
            this.css,
            this.file,
            opts.plugin
          );
        }
        result.input = { column, endColumn, endLine, line, source: this.css };
        if (this.file) {
          if (pathToFileURL) {
            result.input.url = pathToFileURL(this.file).toString();
          }
          result.input.file = this.file;
        }
        return result;
      }
      fromOffset(offset) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i = 0, l = lines.length; i < l; i++) {
            lineToIndex[i] = prevIndex;
            prevIndex += lines[i].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min2 = 0;
        if (offset >= lastLine) {
          min2 = lineToIndex.length - 1;
        } else {
          let max2 = lineToIndex.length - 2;
          let mid;
          while (min2 < max2) {
            mid = min2 + (max2 - min2 >> 1);
            if (offset < lineToIndex[mid]) {
              max2 = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min2 = mid + 1;
            } else {
              min2 = mid;
              break;
            }
          }
        }
        return {
          col: offset - lineToIndex[min2] + 1,
          line: min2 + 1
        };
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      origin(line, column, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ column, line });
        if (!from.source)
          return false;
        let to;
        if (typeof endLine === "number") {
          to = consumer.originalPositionFor({ column: endColumn, line: endLine });
        }
        let fromUrl;
        if (isAbsolute(from.source)) {
          fromUrl = pathToFileURL(from.source);
        } else {
          fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
          );
        }
        let result = {
          column: from.column,
          endColumn: to && to.column,
          endLine: to && to.line,
          line: from.line,
          url: fromUrl.toString()
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath3) {
            result.file = fileURLToPath3(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from.source);
        if (source)
          result.source = source;
        return result;
      }
      toJSON() {
        let json2 = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json2[name] = this[name];
          }
        }
        if (this.map) {
          json2.map = { ...this.map };
          if (json2.map.consumerCache) {
            json2.map.consumerCache = void 0;
          }
        }
        return json2;
      }
      get from() {
        return this.file || this.id;
      }
    };
    module2.exports = Input;
    Input.default = Input;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input);
    }
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/map-generator.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { dirname: dirname4, relative: relative2, resolve, sep: sep3 } = require("path");
    var { pathToFileURL } = require("url");
    var Input = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname4 && resolve && relative2 && sep3);
    var MapGenerator = class {
      constructor(stringify2, root, opts, cssString) {
        this.stringify = stringify2;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
        this.css = cssString;
        this.originalCSS = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        this.memoizedFileURLs = /* @__PURE__ */ new Map();
        this.memoizedPaths = /* @__PURE__ */ new Map();
        this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root = prev.root || dirname4(prev.file);
          let map4;
          if (this.mapOpts.sourcesContent === false) {
            map4 = new SourceMapConsumer(prev.text);
            if (map4.sourcesContent) {
              map4.sourcesContent = null;
            }
          } else {
            map4 = prev.consumer();
          }
          this.map.applySourceMap(map4, from, this.toUrl(this.path(root)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node;
          for (let i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== "comment")
              continue;
            if (node.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result = "";
          this.stringify(this.root, (i) => {
            result += i;
          });
          return [result];
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev, {
            ignoreInvalidMapping: true
          });
        } else {
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        });
        let line = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        };
        let lines, last2;
        this.stringify(this.root, (str2, node, type2) => {
          this.css += str2;
          if (node && type2 !== "end") {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node.source && node.source.start) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.start.line;
              mapping.original.column = node.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str2.match(/\n/g);
          if (lines) {
            line += lines.length;
            last2 = str2.lastIndexOf("\n");
            column = str2.length - last2;
          } else {
            column += str2.length;
          }
          if (node && type2 !== "start") {
            let p = node.parent || { raws: {} };
            let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
            if (!childless || node !== p.last || p.raws.semicolon) {
              if (node.source && node.source.end) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.end.line;
                mapping.original.column = node.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.annotation);
        }
        return true;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.inline);
        }
        return true;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.withContent());
        }
        return true;
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      path(file) {
        if (this.mapOpts.absolute)
          return file;
        if (file.charCodeAt(0) === 60)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        let cached = this.memoizedPaths.get(file);
        if (cached)
          return cached;
        let from = this.opts.to ? dirname4(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname4(resolve(from, this.mapOpts.annotation));
        }
        let path8 = relative2(from, file);
        this.memoizedPaths.set(file, path8);
        return path8;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node) => {
              if (node.source && node.source.input.map) {
                let map4 = node.source.input.map;
                if (!this.previousMaps.includes(map4)) {
                  this.previousMaps.push(map4);
                }
              }
            });
          } else {
            let input = new Input(this.originalCSS, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node) => {
            if (node.source) {
              let from = node.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                this.map.setSourceContent(fromUrl, node.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from, this.css);
        }
      }
      sourcePath(node) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node.source.input.from);
        } else {
          return this.toUrl(this.path(node.source.input.from));
        }
      }
      toBase64(str2) {
        if (Buffer) {
          return Buffer.from(str2).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str2)));
        }
      }
      toFileUrl(path8) {
        let cached = this.memoizedFileURLs.get(path8);
        if (cached)
          return cached;
        if (pathToFileURL) {
          let fileURL = pathToFileURL(path8).toString();
          this.memoizedFileURLs.set(path8, fileURL);
          return fileURL;
        } else {
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
        }
      }
      toUrl(path8) {
        let cached = this.memoizedURLs.get(path8);
        if (cached)
          return cached;
        if (sep3 === "\\") {
          path8 = path8.replace(/\\/g, "/");
        }
        let url = encodeURI(path8).replace(/[#?]/g, encodeURIComponent);
        this.memoizedURLs.set(path8, url);
        return url;
      }
    };
    module2.exports = MapGenerator;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/comment.js"(exports2, module2) {
    "use strict";
    var Node = require_node2();
    var Comment = class extends Node {
      constructor(defaults2) {
        super(defaults2);
        this.type = "comment";
      }
    };
    module2.exports = Comment;
    Comment.default = Comment;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/container.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var Declaration = require_declaration();
    var Comment = require_comment();
    var Node = require_node2();
    var parse2;
    var Rule;
    var AtRule;
    var Root;
    function cleanSource(nodes) {
      return nodes.map((i) => {
        if (i.nodes)
          i.nodes = cleanSource(i.nodes);
        delete i.source;
        return i;
      });
    }
    function markDirtyUp(node) {
      node[isClean] = false;
      if (node.proxyOf.nodes) {
        for (let i of node.proxyOf.nodes) {
          markDirtyUp(i);
        }
      }
    }
    var Container = class _Container extends Node {
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node of nodes)
            this.proxyOf.nodes.push(node);
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node of this.nodes)
            node.cleanRaws(keepBetween);
        }
      }
      each(callback2) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index = this.indexes[iterator];
          result = callback2(this.proxyOf.nodes[index], index);
          if (result === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (!node[prop]) {
              return node[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node[prop](
                  ...args.map((i) => {
                    if (typeof i === "function") {
                      return (child, index) => i(child.toProxy(), index);
                    } else {
                      return i;
                    }
                  })
                );
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node[prop](
                  (child, ...other) => cb(child.toProxy(), ...other)
                );
              };
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else if (prop === "nodes") {
              return node.nodes.map((i) => i.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node[prop].toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value) {
            if (node[prop] === value)
              return true;
            node[prop] = value;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      insertAfter(exist, add) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex + 1, 0, node);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (existIndex < index) {
            this.indexes[id] = index + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertBefore(exist, add) {
        let existIndex = this.index(exist);
        let type2 = existIndex === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type2).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex, 0, node);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (existIndex <= index) {
            this.indexes[id] = index + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse2(nodes).nodes);
        } else if (typeof nodes === "undefined") {
          nodes = [];
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i of nodes) {
            if (i.parent)
              i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i of nodes) {
            if (i.parent)
              i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i) => {
          if (!i[my])
            _Container.rebuild(i);
          i = i.proxyOf;
          if (i.parent)
            i.parent.removeChild(i);
          if (i[isClean])
            markDirtyUp(i);
          if (typeof i.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i.parent = this.proxyOf;
          return i;
        });
        return processed;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node of nodes)
            this.proxyOf.nodes.unshift(node);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      removeAll() {
        for (let node of this.proxyOf.nodes)
          node.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index;
        for (let id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        this.markDirty();
        return this;
      }
      replaceValues(pattern, opts, callback2) {
        if (!callback2) {
          callback2 = opts;
          opts = {};
        }
        this.walkDecls((decl) => {
          if (opts.props && !opts.props.includes(decl.prop))
            return;
          if (opts.fast && !decl.value.includes(opts.fast))
            return;
          decl.value = decl.value.replace(pattern, callback2);
        });
        this.markDirty();
        return this;
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      walk(callback2) {
        return this.each((child, i) => {
          let result;
          try {
            result = callback2(child, i);
          } catch (e) {
            throw child.addToError(e);
          }
          if (result !== false && child.walk) {
            result = child.walk(callback2);
          }
          return result;
        });
      }
      walkAtRules(name, callback2) {
        if (!callback2) {
          callback2 = name;
          return this.walk((child, i) => {
            if (child.type === "atrule") {
              return callback2(child, i);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback2(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "atrule" && child.name === name) {
            return callback2(child, i);
          }
        });
      }
      walkComments(callback2) {
        return this.walk((child, i) => {
          if (child.type === "comment") {
            return callback2(child, i);
          }
        });
      }
      walkDecls(prop, callback2) {
        if (!callback2) {
          callback2 = prop;
          return this.walk((child, i) => {
            if (child.type === "decl") {
              return callback2(child, i);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback2(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback2(child, i);
          }
        });
      }
      walkRules(selector, callback2) {
        if (!callback2) {
          callback2 = selector;
          return this.walk((child, i) => {
            if (child.type === "rule") {
              return callback2(child, i);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback2(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback2(child, i);
          }
        });
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
    };
    Container.registerParse = (dependant) => {
      parse2 = dependant;
    };
    Container.registerRule = (dependant) => {
      Rule = dependant;
    };
    Container.registerAtRule = (dependant) => {
      AtRule = dependant;
    };
    Container.registerRoot = (dependant) => {
      Root = dependant;
    };
    module2.exports = Container;
    Container.default = Container;
    Container.rebuild = (node) => {
      if (node.type === "atrule") {
        Object.setPrototypeOf(node, AtRule.prototype);
      } else if (node.type === "rule") {
        Object.setPrototypeOf(node, Rule.prototype);
      } else if (node.type === "decl") {
        Object.setPrototypeOf(node, Declaration.prototype);
      } else if (node.type === "comment") {
        Object.setPrototypeOf(node, Comment.prototype);
      } else if (node.type === "root") {
        Object.setPrototypeOf(node, Root.prototype);
      }
      node[my] = true;
      if (node.nodes) {
        node.nodes.forEach((child) => {
          Container.rebuild(child);
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/document.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor2;
    var Document = class extends Container {
      constructor(defaults2) {
        super({ type: "document", ...defaults2 });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor2(), this, opts);
        return lazy.stringify();
      }
    };
    Document.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document.registerProcessor = (dependant) => {
      Processor2 = dependant;
    };
    module2.exports = Document;
    Document.default = Document;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warn-once.js"(exports2, module2) {
    "use strict";
    var printed = {};
    module2.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/warning.js"(exports2, module2) {
    "use strict";
    var Warning = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let range4 = opts.node.rangeBy(opts);
          this.line = range4.start.line;
          this.column = range4.start.column;
          this.endLine = range4.end.line;
          this.endColumn = range4.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module2.exports = Warning;
    Warning.default = Warning;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/result.js"(exports2, module2) {
    "use strict";
    var Warning = require_warning();
    var Result = class {
      constructor(processor, root, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i) => i.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module2.exports = Result;
    Result.default = Result;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/at-rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var AtRule = class extends Container {
      constructor(defaults2) {
        super(defaults2);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children);
      }
    };
    module2.exports = AtRule;
    AtRule.default = AtRule;
    Container.registerAtRule(AtRule);
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/root.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor2;
    var Root = class extends Container {
      constructor(defaults2) {
        super(defaults2);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      normalize(child, sample, type2) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type2 === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node of nodes) {
              node.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      removeChild(child, ignore) {
        let index = this.index(child);
        if (!ignore && index === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index].raws.before;
        }
        return super.removeChild(child);
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor2(), this, opts);
        return lazy.stringify();
      }
    };
    Root.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root.registerProcessor = (dependant) => {
      Processor2 = dependant;
    };
    module2.exports = Root;
    Root.default = Root;
    Container.registerRoot(Root);
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/list.js"(exports2, module2) {
    "use strict";
    var list = {
      comma(string2) {
        return list.split(string2, [","], true);
      },
      space(string2) {
        let spaces = [" ", "\n", "	"];
        return list.split(string2, spaces);
      },
      split(string2, separators, last2) {
        let array = [];
        let current2 = "";
        let split = false;
        let func = 0;
        let inQuote = false;
        let prevQuote = "";
        let escape2 = false;
        for (let letter of string2) {
          if (escape2) {
            escape2 = false;
          } else if (letter === "\\") {
            escape2 = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split = true;
          }
          if (split) {
            if (current2 !== "")
              array.push(current2.trim());
            current2 = "";
            split = false;
          } else {
            current2 += letter;
          }
        }
        if (last2 || current2 !== "")
          array.push(current2.trim());
        return array;
      }
    };
    module2.exports = list;
    list.default = list;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var list = require_list();
    var Rule = class extends Container {
      constructor(defaults2) {
        super(defaults2);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list.comma(this.selector);
      }
      set selectors(values2) {
        let match2 = this.selector ? this.selector.match(/,\s*/) : null;
        let sep3 = match2 ? match2[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values2.join(sep3);
      }
    };
    module2.exports = Rule;
    Rule.default = Rule;
    Container.registerRule(Rule);
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parser.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var tokenizer = require_tokenize();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Root = require_root();
    var Rule = require_rule();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i = tokens.length - 1; i >= 0; i--) {
        let token = tokens[i];
        let pos = token[3] || token[2];
        if (pos)
          return pos;
      }
    }
    var Parser = class {
      constructor(input) {
        this.input = input;
        this.root = new Root();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(token) {
        let node = new AtRule();
        node.name = token[1].slice(1);
        if (node.name === "") {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2]);
        let type2;
        let prev;
        let shift;
        let last2 = false;
        let open2 = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type2 = token[0];
          if (type2 === "(" || type2 === "[") {
            brackets.push(type2 === "(" ? ")" : "]");
          } else if (type2 === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type2 === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type2 === ";") {
              node.source.end = this.getPosition(token[2]);
              node.source.end.offset++;
              this.semicolon = true;
              break;
            } else if (type2 === "{") {
              open2 = true;
              break;
            } else if (type2 === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node.source.end = this.getPosition(prev[3] || prev[2]);
                  node.source.end.offset++;
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last2 = true;
            break;
          }
        }
        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, "params", params);
          if (last2) {
            token = params[params.length - 1];
            node.source.end = this.getPosition(token[3] || token[2]);
            node.source.end.offset++;
            this.spaces = node.raws.between;
            node.raws.between = "";
          }
        } else {
          node.raws.afterName = "";
          node.params = "";
        }
        if (open2) {
          node.nodes = [];
          this.current = node;
        }
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token;
        for (let j = colon - 1; j >= 0; j--) {
          token = tokens[j];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error(
          "Missed semicolon",
          token[0] === "word" ? token[3] + 1 : token[2]
        );
      }
      colon(tokens) {
        let brackets = 0;
        let token, type2, prev;
        for (let [i, element] of tokens.entries()) {
          token = element;
          type2 = token[0];
          if (type2 === "(") {
            brackets += 1;
          }
          if (type2 === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type2 === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i;
            }
          }
          prev = token;
        }
        return false;
      }
      comment(token) {
        let node = new Comment();
        this.init(node, token[2]);
        node.source.end = this.getPosition(token[3] || token[2]);
        node.source.end.offset++;
        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = "";
          node.raws.left = text;
          node.raws.right = "";
        } else {
          let match2 = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node.text = match2[2];
          node.raws.left = match2[1];
          node.raws.right = match2[3];
        }
      }
      createTokenizer() {
        this.tokenizer = tokenizer(this.input);
      }
      decl(tokens, customProperty) {
        let node = new Declaration();
        this.init(node, tokens[0][2]);
        let last2 = tokens[tokens.length - 1];
        if (last2[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node.source.end = this.getPosition(
          last2[3] || last2[2] || findLastWithPosition(tokens)
        );
        node.source.end.offset++;
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = this.getPosition(tokens[0][2]);
        node.prop = "";
        while (tokens.length) {
          let type2 = tokens[0][0];
          if (type2 === ":" || type2 === "space" || type2 === "comment") {
            break;
          }
          node.prop += tokens.shift()[1];
        }
        node.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }
        if (node.prop[0] === "_" || node.prop[0] === "*") {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }
        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i = tokens.length - 1; i >= 0; i--) {
          token = tokens[i];
          if (token[1].toLowerCase() === "!important") {
            node.important = true;
            let string2 = this.stringFrom(tokens, i);
            string2 = this.spacesFromEnd(tokens) + string2;
            if (string2 !== " !important")
              node.raws.important = string2;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache = tokens.slice(0);
            let str2 = "";
            for (let j = i; j > 0; j--) {
              let type2 = cache[j][0];
              if (str2.trim().indexOf("!") === 0 && type2 !== "space") {
                break;
              }
              str2 = cache.pop()[1] + str2;
            }
            if (str2.trim().indexOf("!") === 0) {
              node.important = true;
              node.raws.important = str2;
              tokens = cache;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
        if (hasWord) {
          node.raws.between += firstSpaces.map((i) => i[1]).join("");
          firstSpaces = [];
        }
        this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
        if (node.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      doubleColon(token) {
        throw this.input.error(
          "Double colon",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
      emptyRule(token) {
        let node = new Rule();
        this.init(node, token[2]);
        node.selector = "";
        node.raws.between = "";
        this.current = node;
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current.source.end.offset++;
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      // Helpers
      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          column: pos.col,
          line: pos.line,
          offset
        };
      }
      init(node, offset) {
        this.current.push(node);
        node.source = {
          input: this.input,
          start: this.getPosition(offset)
        };
        node.raws.before = this.spaces;
        this.spaces = "";
        if (node.type !== "comment")
          this.semicolon = false;
      }
      other(start) {
        let end = false;
        let type2 = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token = start;
        while (token) {
          type2 = token[0];
          tokens.push(token);
          if (type2 === "(" || type2 === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type2 === "(" ? ")" : "]");
          } else if (customProperty && colon && type2 === "{") {
            if (!bracket)
              bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type2 === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type2 === "{") {
              this.rule(tokens);
              return;
            } else if (type2 === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type2 === ":") {
              colon = true;
            }
          } else if (type2 === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== "space" && token !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(node, prop, tokens, customProperty) {
        let token, type2;
        let length = tokens.length;
        let value = "";
        let clean = true;
        let next, prev;
        for (let i = 0; i < length; i += 1) {
          token = tokens[i];
          type2 = token[0];
          if (type2 === "space" && i === length - 1 && !customProperty) {
            clean = false;
          } else if (type2 === "comment") {
            prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
            next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value.slice(-1) === ",") {
                clean = false;
              } else {
                value += token[1];
              }
            } else {
              clean = false;
            }
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i) => all + i[1], "");
          node.raws[prop] = { raw, value };
        }
        node[prop] = value;
      }
      rule(tokens) {
        tokens.pop();
        let node = new Rule();
        this.init(node, tokens[0][2]);
        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, "selector", tokens);
        this.current = node;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      // Errors
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result = "";
        for (let i = from; i < tokens.length; i++) {
          result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      unclosedBracket(bracket) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        );
      }
      unexpectedClose(token) {
        throw this.input.error(
          "Unexpected }",
          { offset: token[2] },
          { offset: token[2] + 1 }
        );
      }
      unknownWord(tokens) {
        throw this.input.error(
          "Unknown word",
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        );
      }
      unnamedAtrule(node, token) {
        throw this.input.error(
          "At-rule without name",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
    };
    module2.exports = Parser;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/parse.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var Parser = require_parser();
    var Input = require_input();
    function parse2(css, opts) {
      let input = new Input(css, opts);
      let parser = new Parser(input);
      try {
        parser.parse();
      } catch (e) {
        if (process.env.NODE_ENV !== "production") {
          if (e.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e;
      }
      return parser.root;
    }
    module2.exports = parse2;
    parse2.default = parse2;
    Container.registerParse(parse2);
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify2 = require_stringify2();
    var Container = require_container();
    var Document = require_document();
    var warnOnce = require_warn_once();
    var Result = require_result();
    var parse2 = require_parse();
    var Root = require_root();
    var TYPE_TO_CLASS_NAME = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    };
    var PLUGIN_PROPS = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    };
    var NOT_VISITORS = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node) {
      let key = false;
      let type2 = TYPE_TO_CLASS_NAME[node.type];
      if (node.type === "decl") {
        key = node.prop.toLowerCase();
      } else if (node.type === "atrule") {
        key = node.name.toLowerCase();
      }
      if (key && node.append) {
        return [
          type2,
          type2 + "-" + key,
          CHILDREN,
          type2 + "Exit",
          type2 + "Exit-" + key
        ];
      } else if (key) {
        return [type2, type2 + "-" + key, type2 + "Exit", type2 + "Exit-" + key];
      } else if (node.append) {
        return [type2, CHILDREN, type2 + "Exit"];
      } else {
        return [type2, type2 + "Exit"];
      }
    }
    function toStack(node) {
      let events;
      if (node.type === "document") {
        events = ["Document", CHILDREN, "DocumentExit"];
      } else if (node.type === "root") {
        events = ["Root", CHILDREN, "RootExit"];
      } else {
        events = getEvents(node);
      }
      return {
        eventIndex: 0,
        events,
        iterator: 0,
        node,
        visitorIndex: 0,
        visitors: []
      };
    }
    function cleanMarks(node) {
      node[isClean] = false;
      if (node.nodes)
        node.nodes.forEach((i) => cleanMarks(i));
      return node;
    }
    var postcss = {};
    var LazyResult = class _LazyResult {
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root = cleanMarks(css);
        } else if (css instanceof _LazyResult || css instanceof Result) {
          root = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser = parse2;
          if (opts.syntax)
            parser = opts.syntax.parse;
          if (opts.parser)
            parser = opts.parser;
          if (parser.parse)
            parser = parser.parse;
          try {
            root = parser(css, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root && !root[my]) {
            Container.rebuild(root);
          }
        }
        this.result = new Result(processor, root, opts);
        this.helpers = { ...postcss, postcss, result: this.result };
        this.plugins = this.processor.plugins.map((plugin) => {
          if (typeof plugin === "object" && plugin.prepare) {
            return { ...plugin, ...plugin.prepare(this.result) };
          } else {
            return plugin;
          }
        });
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node) {
        let plugin = this.result.lastPlugin;
        try {
          if (node)
            node.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin.postcssPlugin;
            error.setMessage();
          } else if (plugin.postcssVersion) {
            if (process.env.NODE_ENV !== "production") {
              let pluginName = plugin.postcssPlugin;
              let pluginVer = plugin.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a = pluginVer.split(".");
              let b = runtimeVer.split(".");
              if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                console.error(
                  "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                );
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error;
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin, type2, cb) => {
          if (!this.listeners[type2])
            this.listeners[type2] = [];
          this.listeners[type2].push([plugin, cb]);
        };
        for (let plugin of this.plugins) {
          if (typeof plugin === "object") {
            for (let event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === "object") {
                  for (let filter2 in plugin[event]) {
                    if (filter2 === "*") {
                      add(plugin, event, plugin[event][filter2]);
                    } else {
                      add(
                        plugin,
                        event + "-" + filter2.toLowerCase(),
                        plugin[event][filter2]
                      );
                    }
                  }
                } else if (typeof plugin[event] === "function") {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i = 0; i < this.plugins.length; i++) {
          let plugin = this.plugins[i];
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            let stack = [toStack(root)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e) {
                  let node = stack[stack.length - 1].node;
                  throw this.handleError(e, node);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin;
              try {
                if (root.type === "document") {
                  let roots = root.nodes.map(
                    (subRoot) => visitor(subRoot, this.helpers)
                  );
                  await Promise.all(roots);
                } else {
                  await visitor(root, this.helpers);
                }
              } catch (e) {
                throw this.handleError(e);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      runOnRoot(plugin) {
        this.result.lastPlugin = plugin;
        try {
          if (typeof plugin === "object" && plugin.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map(
                (root) => plugin.Once(root, this.helpers)
              );
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin.Once(this.result.root, this.helpers);
          } else if (typeof plugin === "function") {
            return plugin(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str2 = stringify2;
        if (opts.syntax)
          str2 = opts.syntax.stringify;
        if (opts.stringifier)
          str2 = opts.stringifier;
        if (str2.stringify)
          str2 = str2.stringify;
        let map4 = new MapGenerator(str2, this.result.root, this.result.opts);
        let data = map4.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin of this.plugins) {
          let promise = this.runOnRoot(plugin);
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            this.walkSync(root);
          }
          if (this.listeners.OnceExit) {
            if (root.type === "document") {
              for (let subRoot of root.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root);
            }
          }
        }
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (process.env.NODE_ENV !== "production") {
          if (!("from" in this.opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this.css;
      }
      visitSync(visitors, node) {
        for (let [plugin, visitor] of visitors) {
          this.result.lastPlugin = plugin;
          let promise;
          try {
            promise = visitor(node, this.helpers);
          } catch (e) {
            throw this.handleError(e, node.proxyOf);
          }
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            return true;
          }
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      }
      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node, visitors } = visit;
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin;
          try {
            return visitor(node.toProxy(), this.helpers);
          } catch (e) {
            throw this.handleError(e, node);
          }
        }
        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while (child = node.nodes[node.indexes[iterator]]) {
            node.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit.iterator = 0;
          delete node.indexes[iterator];
        }
        let events = visit.events;
        while (visit.eventIndex < events.length) {
          let event = events[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node.nodes && node.nodes.length) {
              node[isClean] = true;
              visit.iterator = node.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
      walkSync(node) {
        node[isClean] = true;
        let events = getEvents(node);
        for (let event of events) {
          if (event === CHILDREN) {
            if (node.nodes) {
              node.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node.toProxy()))
                return;
            }
          }
        }
      }
      warnings() {
        return this.sync().warnings();
      }
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss = dependant;
    };
    module2.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root.registerLazyResult(LazyResult);
    Document.registerLazyResult(LazyResult);
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
    "use strict";
    var MapGenerator = require_map_generator();
    var stringify2 = require_stringify2();
    var warnOnce = require_warn_once();
    var parse2 = require_parse();
    var Result = require_result();
    var NoWorkResult = class {
      constructor(processor, css, opts) {
        css = css.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css;
        this._opts = opts;
        this._map = void 0;
        let root;
        let str2 = stringify2;
        this.result = new Result(this._processor, root, this._opts);
        this.result.css = css;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map4 = new MapGenerator(str2, root, this._opts, css);
        if (map4.isMap()) {
          let [generatedCSS, generatedMap] = map4.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        } else {
          map4.clearAnnotation();
          this.result.css = map4.css;
        }
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (process.env.NODE_ENV !== "production") {
          if (!("from" in this._opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root;
        let parser = parse2;
        try {
          root = parser(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root;
          return root;
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
    };
    module2.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/processor.js"(exports2, module2) {
    "use strict";
    var NoWorkResult = require_no_work_result();
    var LazyResult = require_lazy_result();
    var Document = require_document();
    var Root = require_root();
    var Processor2 = class {
      constructor(plugins2 = []) {
        this.version = "8.4.38";
        this.plugins = this.normalize(plugins2);
      }
      normalize(plugins2) {
        let normalized = [];
        for (let i of plugins2) {
          if (i.postcss === true) {
            i = i();
          } else if (i.postcss) {
            i = i.postcss;
          }
          if (typeof i === "object" && Array.isArray(i.plugins)) {
            normalized = normalized.concat(i.plugins);
          } else if (typeof i === "object" && i.postcssPlugin) {
            normalized.push(i);
          } else if (typeof i === "function") {
            normalized.push(i);
          } else if (typeof i === "object" && (i.parse || i.stringify)) {
            if (process.env.NODE_ENV !== "production") {
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
            }
          } else {
            throw new Error(i + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
      process(css, opts = {}) {
        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
          return new NoWorkResult(this, css, opts);
        } else {
          return new LazyResult(this, css, opts);
        }
      }
      use(plugin) {
        this.plugins = this.plugins.concat(this.normalize([plugin]));
        return this;
      }
    };
    module2.exports = Processor2;
    Processor2.default = Processor2;
    Root.registerProcessor(Processor2);
    Document.registerProcessor(Processor2);
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Input = require_input();
    var Root = require_root();
    var Rule = require_rule();
    function fromJSON(json2, inputs) {
      if (Array.isArray(json2))
        return json2.map((n) => fromJSON(n));
      let { inputs: ownInputs, ...defaults2 } = json2;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults2.nodes) {
        defaults2.nodes = json2.nodes.map((n) => fromJSON(n, inputs));
      }
      if (defaults2.source) {
        let { inputId, ...source } = defaults2.source;
        defaults2.source = source;
        if (inputId != null) {
          defaults2.source.input = inputs[inputId];
        }
      }
      if (defaults2.type === "root") {
        return new Root(defaults2);
      } else if (defaults2.type === "decl") {
        return new Declaration(defaults2);
      } else if (defaults2.type === "rule") {
        return new Rule(defaults2);
      } else if (defaults2.type === "comment") {
        return new Comment(defaults2);
      } else if (defaults2.type === "atrule") {
        return new AtRule(defaults2);
      } else {
        throw new Error("Unknown node type: " + json2.type);
      }
    }
    module2.exports = fromJSON;
    fromJSON.default = fromJSON;
  }
});

// ../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "../../node_modules/.pnpm/postcss@8.4.38/node_modules/postcss/lib/postcss.js"(exports2, module2) {
    "use strict";
    var CssSyntaxError = require_css_syntax_error();
    var Declaration = require_declaration();
    var LazyResult = require_lazy_result();
    var Container = require_container();
    var Processor2 = require_processor();
    var stringify2 = require_stringify2();
    var fromJSON = require_fromJSON();
    var Document = require_document();
    var Warning = require_warning();
    var Comment = require_comment();
    var AtRule = require_at_rule();
    var Result = require_result();
    var Input = require_input();
    var parse2 = require_parse();
    var list = require_list();
    var Rule = require_rule();
    var Root = require_root();
    var Node = require_node2();
    function postcss(...plugins2) {
      if (plugins2.length === 1 && Array.isArray(plugins2[0])) {
        plugins2 = plugins2[0];
      }
      return new Processor2(plugins2);
    }
    postcss.plugin = function plugin(name, initializer) {
      let warningPrinted = false;
      function creator(...args) {
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          console.warn(
            name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (process.env.LANG && process.env.LANG.startsWith("cn")) {
            console.warn(
              name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new Processor2().version;
        return transformer;
      }
      let cache;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache)
            cache = creator();
          return cache;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss.stringify = stringify2;
    postcss.parse = parse2;
    postcss.fromJSON = fromJSON;
    postcss.list = list;
    postcss.comment = (defaults2) => new Comment(defaults2);
    postcss.atRule = (defaults2) => new AtRule(defaults2);
    postcss.decl = (defaults2) => new Declaration(defaults2);
    postcss.rule = (defaults2) => new Rule(defaults2);
    postcss.root = (defaults2) => new Root(defaults2);
    postcss.document = (defaults2) => new Document(defaults2);
    postcss.CssSyntaxError = CssSyntaxError;
    postcss.Declaration = Declaration;
    postcss.Container = Container;
    postcss.Processor = Processor2;
    postcss.Document = Document;
    postcss.Comment = Comment;
    postcss.Warning = Warning;
    postcss.AtRule = AtRule;
    postcss.Result = Result;
    postcss.Input = Input;
    postcss.Rule = Rule;
    postcss.Root = Root;
    postcss.Node = Node;
    LazyResult.registerPostcss(postcss);
    module2.exports = postcss;
    postcss.default = postcss;
  }
});

// ../../node_modules/.pnpm/sanitize-html@2.13.0/node_modules/sanitize-html/index.js
var require_sanitize_html = __commonJS({
  "../../node_modules/.pnpm/sanitize-html@2.13.0/node_modules/sanitize-html/index.js"(exports2, module2) {
    var htmlparser = require_lib6();
    var escapeStringRegexp = require_escape_string_regexp();
    var { isPlainObject: isPlainObject3 } = require_is_plain_object();
    var deepmerge = require_cjs();
    var parseSrcset = require_parse_srcset();
    var { parse: postcssParse } = require_postcss();
    var mediaTags = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ];
    var vulnerableTags = ["script", "style"];
    function each2(obj, cb) {
      if (obj) {
        Object.keys(obj).forEach(function(key) {
          cb(obj[key], key);
        });
      }
    }
    function has2(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function filter2(a, cb) {
      const n = [];
      each2(a, function(v) {
        if (cb(v)) {
          n.push(v);
        }
      });
      return n;
    }
    function isEmptyObject(obj) {
      for (const key in obj) {
        if (has2(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function stringifySrcset(parsedSrcset) {
      return parsedSrcset.map(function(part) {
        if (!part.url) {
          throw new Error("URL missing");
        }
        return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
      }).join(", ");
    }
    module2.exports = sanitizeHtml;
    var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
    function sanitizeHtml(html, options2, _recursing) {
      if (html == null) {
        return "";
      }
      if (typeof html === "number") {
        html = html.toString();
      }
      let result = "";
      let tempResult = "";
      function Frame(tag, attribs) {
        const that = this;
        this.tag = tag;
        this.attribs = attribs || {};
        this.tagPosition = result.length;
        this.text = "";
        this.mediaChildren = [];
        this.updateParentNodeText = function() {
          if (stack.length) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.text += that.text;
          }
        };
        this.updateParentNodeMediaChildren = function() {
          if (stack.length && mediaTags.includes(this.tag)) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.mediaChildren.push(this.tag);
          }
        };
      }
      options2 = Object.assign({}, sanitizeHtml.defaults, options2);
      options2.parser = Object.assign({}, htmlParserDefaults, options2.parser);
      const tagAllowed = function(name) {
        return options2.allowedTags === false || (options2.allowedTags || []).indexOf(name) > -1;
      };
      vulnerableTags.forEach(function(tag) {
        if (tagAllowed(tag) && !options2.allowVulnerableTags) {
          console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
        }
      });
      const nonTextTagsArray = options2.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let allowedAttributesMap;
      let allowedAttributesGlobMap;
      if (options2.allowedAttributes) {
        allowedAttributesMap = {};
        allowedAttributesGlobMap = {};
        each2(options2.allowedAttributes, function(attributes, tag) {
          allowedAttributesMap[tag] = [];
          const globRegex = [];
          attributes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else {
              allowedAttributesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        });
      }
      const allowedClassesMap = {};
      const allowedClassesGlobMap = {};
      const allowedClassesRegexMap = {};
      each2(options2.allowedClasses, function(classes, tag) {
        if (allowedAttributesMap) {
          if (!has2(allowedAttributesMap, tag)) {
            allowedAttributesMap[tag] = [];
          }
          allowedAttributesMap[tag].push("class");
        }
        allowedClassesMap[tag] = classes;
        if (Array.isArray(classes)) {
          const globRegex = [];
          allowedClassesMap[tag] = [];
          allowedClassesRegexMap[tag] = [];
          classes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else if (obj instanceof RegExp) {
              allowedClassesRegexMap[tag].push(obj);
            } else {
              allowedClassesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        }
      });
      const transformTagsMap = {};
      let transformTagsAll;
      each2(options2.transformTags, function(transform, tag) {
        let transFun;
        if (typeof transform === "function") {
          transFun = transform;
        } else if (typeof transform === "string") {
          transFun = sanitizeHtml.simpleTransform(transform);
        }
        if (tag === "*") {
          transformTagsAll = transFun;
        } else {
          transformTagsMap[tag] = transFun;
        }
      });
      let depth;
      let stack;
      let skipMap;
      let transformMap;
      let skipText;
      let skipTextDepth;
      let addedText = false;
      initializeState();
      const parser = new htmlparser.Parser({
        onopentag: function(name, attribs) {
          if (options2.enforceHtmlBoundary && name === "html") {
            initializeState();
          }
          if (skipText) {
            skipTextDepth++;
            return;
          }
          const frame = new Frame(name, attribs);
          stack.push(frame);
          let skip = false;
          const hasText = !!frame.text;
          let transformedTag;
          if (has2(transformTagsMap, name)) {
            transformedTag = transformTagsMap[name](name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (transformedTag.text !== void 0) {
              frame.innerText = transformedTag.text;
            }
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (transformTagsAll) {
            transformedTag = transformTagsAll(name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (!tagAllowed(name) || options2.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options2.nestingLimit != null && depth >= options2.nestingLimit) {
            skip = true;
            skipMap[depth] = true;
            if (options2.disallowedTagsMode === "discard" || options2.disallowedTagsMode === "completelyDiscard") {
              if (nonTextTagsArray.indexOf(name) !== -1) {
                skipText = true;
                skipTextDepth = 1;
              }
            }
            skipMap[depth] = true;
          }
          depth++;
          if (skip) {
            if (options2.disallowedTagsMode === "discard" || options2.disallowedTagsMode === "completelyDiscard") {
              return;
            }
            tempResult = result;
            result = "";
          }
          result += "<" + name;
          if (name === "script") {
            if (options2.allowedScriptHostnames || options2.allowedScriptDomains) {
              frame.innerText = "";
            }
          }
          if (!allowedAttributesMap || has2(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
            each2(attribs, function(value, a) {
              if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
                delete frame.attribs[a];
                return;
              }
              if (value === "" && !options2.allowedEmptyAttributes.includes(a) && (options2.nonBooleanAttributes.includes(a) || options2.nonBooleanAttributes.includes("*"))) {
                delete frame.attribs[a];
                return;
              }
              let passedAllowedAttributesMapCheck = false;
              if (!allowedAttributesMap || has2(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a) !== -1 || has2(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a)) {
                passedAllowedAttributesMapCheck = true;
              } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                for (const o of allowedAttributesMap[name]) {
                  if (isPlainObject3(o) && o.name && o.name === a) {
                    passedAllowedAttributesMapCheck = true;
                    let newValue = "";
                    if (o.multiple === true) {
                      const splitStrArray = value.split(" ");
                      for (const s of splitStrArray) {
                        if (o.values.indexOf(s) !== -1) {
                          if (newValue === "") {
                            newValue = s;
                          } else {
                            newValue += " " + s;
                          }
                        }
                      }
                    } else if (o.values.indexOf(value) >= 0) {
                      newValue = value;
                    }
                    value = newValue;
                  }
                }
              }
              if (passedAllowedAttributesMapCheck) {
                if (options2.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
                  if (naughtyHref(name, value)) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (name === "script" && a === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (options2.allowedScriptHostnames || options2.allowedScriptDomains) {
                      const allowedHostname = (options2.allowedScriptHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options2.allowedScriptDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (name === "iframe" && a === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (parsed.isRelativeUrl) {
                      allowed = has2(options2, "allowIframeRelativeUrls") ? options2.allowIframeRelativeUrls : !options2.allowedIframeHostnames && !options2.allowedIframeDomains;
                    } else if (options2.allowedIframeHostnames || options2.allowedIframeDomains) {
                      const allowedHostname = (options2.allowedIframeHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options2.allowedIframeDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === "srcset") {
                  try {
                    let parsed = parseSrcset(value);
                    parsed.forEach(function(value2) {
                      if (naughtyHref("srcset", value2.url)) {
                        value2.evil = true;
                      }
                    });
                    parsed = filter2(parsed, function(v) {
                      return !v.evil;
                    });
                    if (!parsed.length) {
                      delete frame.attribs[a];
                      return;
                    } else {
                      value = stringifySrcset(filter2(parsed, function(v) {
                        return !v.evil;
                      }));
                      frame.attribs[a] = value;
                    }
                  } catch (e) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === "class") {
                  const allowedSpecificClasses = allowedClassesMap[name];
                  const allowedWildcardClasses = allowedClassesMap["*"];
                  const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                  const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                  const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                  const allowedClassesGlobs = [
                    allowedSpecificClassesGlob,
                    allowedWildcardClassesGlob
                  ].concat(allowedSpecificClassesRegex).filter(function(t) {
                    return t;
                  });
                  if (allowedSpecificClasses && allowedWildcardClasses) {
                    value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                  } else {
                    value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                  }
                  if (!value.length) {
                    delete frame.attribs[a];
                    return;
                  }
                }
                if (a === "style") {
                  if (options2.parseStyleAttributes) {
                    try {
                      const abstractSyntaxTree = postcssParse(name + " {" + value + "}", { map: false });
                      const filteredAST = filterCss(abstractSyntaxTree, options2.allowedStyles);
                      value = stringifyStyleAttributes(filteredAST);
                      if (value.length === 0) {
                        delete frame.attribs[a];
                        return;
                      }
                    } catch (e) {
                      if (typeof window !== "undefined") {
                        console.warn('Failed to parse "' + name + " {" + value + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`);
                      }
                      delete frame.attribs[a];
                      return;
                    }
                  } else if (options2.allowedStyles) {
                    throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
                  }
                }
                result += " " + a;
                if (value && value.length) {
                  result += '="' + escapeHtml(value, true) + '"';
                } else if (options2.allowedEmptyAttributes.includes(a)) {
                  result += '=""';
                }
              } else {
                delete frame.attribs[a];
              }
            });
          }
          if (options2.selfClosing.indexOf(name) !== -1) {
            result += " />";
          } else {
            result += ">";
            if (frame.innerText && !hasText && !options2.textFilter) {
              result += escapeHtml(frame.innerText);
              addedText = true;
            }
          }
          if (skip) {
            result = tempResult + escapeHtml(result);
            tempResult = "";
          }
        },
        ontext: function(text) {
          if (skipText) {
            return;
          }
          const lastFrame = stack[stack.length - 1];
          let tag;
          if (lastFrame) {
            tag = lastFrame.tag;
            text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
          }
          if (options2.disallowedTagsMode === "completelyDiscard" && !tagAllowed(tag)) {
            text = "";
          } else if ((options2.disallowedTagsMode === "discard" || options2.disallowedTagsMode === "completelyDiscard") && (tag === "script" || tag === "style")) {
            result += text;
          } else {
            const escaped = escapeHtml(text, false);
            if (options2.textFilter && !addedText) {
              result += options2.textFilter(escaped, tag);
            } else if (!addedText) {
              result += escaped;
            }
          }
          if (stack.length) {
            const frame = stack[stack.length - 1];
            frame.text += text;
          }
        },
        onclosetag: function(name, isImplied) {
          if (skipText) {
            skipTextDepth--;
            if (!skipTextDepth) {
              skipText = false;
            } else {
              return;
            }
          }
          const frame = stack.pop();
          if (!frame) {
            return;
          }
          if (frame.tag !== name) {
            stack.push(frame);
            return;
          }
          skipText = options2.enforceHtmlBoundary ? name === "html" : false;
          depth--;
          const skip = skipMap[depth];
          if (skip) {
            delete skipMap[depth];
            if (options2.disallowedTagsMode === "discard" || options2.disallowedTagsMode === "completelyDiscard") {
              frame.updateParentNodeText();
              return;
            }
            tempResult = result;
            result = "";
          }
          if (transformMap[depth]) {
            name = transformMap[depth];
            delete transformMap[depth];
          }
          if (options2.exclusiveFilter && options2.exclusiveFilter(frame)) {
            result = result.substr(0, frame.tagPosition);
            return;
          }
          frame.updateParentNodeMediaChildren();
          frame.updateParentNodeText();
          if (
            // Already output />
            options2.selfClosing.indexOf(name) !== -1 || // Escaped tag, closing tag is implied
            isImplied && !tagAllowed(name) && ["escape", "recursiveEscape"].indexOf(options2.disallowedTagsMode) >= 0
          ) {
            if (skip) {
              result = tempResult;
              tempResult = "";
            }
            return;
          }
          result += "</" + name + ">";
          if (skip) {
            result = tempResult + escapeHtml(result);
            tempResult = "";
          }
          addedText = false;
        }
      }, options2.parser);
      parser.write(html);
      parser.end();
      return result;
      function initializeState() {
        result = "";
        depth = 0;
        stack = [];
        skipMap = {};
        transformMap = {};
        skipText = false;
        skipTextDepth = 0;
      }
      function escapeHtml(s, quote) {
        if (typeof s !== "string") {
          s = s + "";
        }
        if (options2.parser.decodeEntities) {
          s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s = s.replace(/"/g, "&quot;");
          }
        }
        s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (quote) {
          s = s.replace(/"/g, "&quot;");
        }
        return s;
      }
      function naughtyHref(name, href) {
        href = href.replace(/[\x00-\x20]+/g, "");
        while (true) {
          const firstIndex = href.indexOf("<!--");
          if (firstIndex === -1) {
            break;
          }
          const lastIndex = href.indexOf("-->", firstIndex + 4);
          if (lastIndex === -1) {
            break;
          }
          href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
        }
        const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!matches) {
          if (href.match(/^[/\\]{2}/)) {
            return !options2.allowProtocolRelative;
          }
          return false;
        }
        const scheme = matches[1].toLowerCase();
        if (has2(options2.allowedSchemesByTag, name)) {
          return options2.allowedSchemesByTag[name].indexOf(scheme) === -1;
        }
        return !options2.allowedSchemes || options2.allowedSchemes.indexOf(scheme) === -1;
      }
      function parseUrl(value) {
        value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
        if (value.startsWith("relative:")) {
          throw new Error("relative: exploit attempt");
        }
        let base = "relative://relative-site";
        for (let i = 0; i < 100; i++) {
          base += `/${i}`;
        }
        const parsed = new URL(value, base);
        const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
        return {
          isRelativeUrl,
          url: parsed
        };
      }
      function filterCss(abstractSyntaxTree, allowedStyles) {
        if (!allowedStyles) {
          return abstractSyntaxTree;
        }
        const astRules = abstractSyntaxTree.nodes[0];
        let selectedRule;
        if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
          selectedRule = deepmerge(
            allowedStyles[astRules.selector],
            allowedStyles["*"]
          );
        } else {
          selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
        }
        if (selectedRule) {
          abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
        }
        return abstractSyntaxTree;
      }
      function stringifyStyleAttributes(filteredAST) {
        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
          extractedAttributes.push(
            `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
          );
          return extractedAttributes;
        }, []).join(";");
      }
      function filterDeclarations(selectedRule) {
        return function(allowedDeclarationsList, attributeObject) {
          if (has2(selectedRule, attributeObject.prop)) {
            const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
              return regularExpression.test(attributeObject.value);
            });
            if (matchesRegex) {
              allowedDeclarationsList.push(attributeObject);
            }
          }
          return allowedDeclarationsList;
        };
      }
      function filterClasses(classes, allowed, allowedGlobs) {
        if (!allowed) {
          return classes;
        }
        classes = classes.split(/\s+/);
        return classes.filter(function(clss) {
          return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob2) {
            return glob2.test(clss);
          });
        }).join(" ");
      }
    }
    var htmlParserDefaults = {
      decodeEntities: true
    };
    sanitizeHtml.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        // Text content
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "main",
        "ol",
        "p",
        "pre",
        "ul",
        // Inline text semantics
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        // Table content
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      // Tags that cannot be boolean
      nonBooleanAttributes: [
        "abbr",
        "accept",
        "accept-charset",
        "accesskey",
        "action",
        "allow",
        "alt",
        "as",
        "autocapitalize",
        "autocomplete",
        "blocking",
        "charset",
        "cite",
        "class",
        "color",
        "cols",
        "colspan",
        "content",
        "contenteditable",
        "coords",
        "crossorigin",
        "data",
        "datetime",
        "decoding",
        "dir",
        "dirname",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "fetchpriority",
        "for",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formtarget",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "http-equiv",
        "id",
        "imagesizes",
        "imagesrcset",
        "inputmode",
        "integrity",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemtype",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "name",
        "nonce",
        "optimum",
        "pattern",
        "ping",
        "placeholder",
        "popover",
        "popovertarget",
        "popovertargetaction",
        "poster",
        "preload",
        "referrerpolicy",
        "rel",
        "rows",
        "rowspan",
        "sandbox",
        "scope",
        "shape",
        "size",
        "sizes",
        "slot",
        "span",
        "spellcheck",
        "src",
        "srcdoc",
        "srclang",
        "srcset",
        "start",
        "step",
        "style",
        "tabindex",
        "target",
        "title",
        "translate",
        "type",
        "usemap",
        "value",
        "width",
        "wrap",
        // Event handlers
        "onauxclick",
        "onafterprint",
        "onbeforematch",
        "onbeforeprint",
        "onbeforeunload",
        "onbeforetoggle",
        "onblur",
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncopy",
        "oncuechange",
        "oncut",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onpagehide",
        "onpageshow",
        "onpaste",
        "onpause",
        "onplay",
        "onplaying",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onrejectionhandled",
        "onscroll",
        "onscrollend",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwheel"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: ["href", "name", "target"],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
      },
      allowedEmptyAttributes: [
        "alt"
      ],
      // Lots of these won't come up by default because we don't allow them
      selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
      // URL schemes we permit
      allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false,
      parseStyleAttributes: true
    };
    sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge4) {
      merge4 = merge4 === void 0 ? true : merge4;
      newAttribs = newAttribs || {};
      return function(tagName, attribs) {
        let attrib;
        if (merge4) {
          for (attrib in newAttribs) {
            attribs[attrib] = newAttribs[attrib];
          }
        } else {
          attribs = newAttribs;
        }
        return {
          tagName: newTagName,
          attribs
        };
      };
    };
  }
});

// ../../node_modules/.pnpm/sbd@1.0.19/node_modules/sbd/lib/stringHelper.js
var require_stringHelper = __commonJS({
  "../../node_modules/.pnpm/sbd@1.0.19/node_modules/sbd/lib/stringHelper.js"(exports2) {
    exports2.endsWithChar = function ends_with_char(word, c) {
      if (c.length > 1) {
        return c.indexOf(word.slice(-1)) > -1;
      }
      return word.slice(-1) === c;
    };
    exports2.endsWith = function ends_with(word, end) {
      return word.slice(word.length - end.length) === end;
    };
  }
});

// ../../node_modules/.pnpm/sbd@1.0.19/node_modules/sbd/lib/Match.js
var require_Match = __commonJS({
  "../../node_modules/.pnpm/sbd@1.0.19/node_modules/sbd/lib/Match.js"(exports2) {
    var abbreviations;
    var englishAbbreviations = [
      "al",
      "adj",
      "assn",
      "Ave",
      "BSc",
      "MSc",
      "Cell",
      "Ch",
      "Co",
      "cc",
      "Corp",
      "Dem",
      "Dept",
      "ed",
      "eg",
      "Eq",
      "Eqs",
      "est",
      "est",
      "etc",
      "Ex",
      "ext",
      // + number?
      "Fig",
      "fig",
      "Figs",
      "figs",
      "i.e",
      "ie",
      "Inc",
      "inc",
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Sept",
      "Oct",
      "Nov",
      "Dec",
      "jr",
      "mi",
      "Miss",
      "Mrs",
      "Mr",
      "Ms",
      "Mol",
      "mt",
      "mts",
      "no",
      "Nos",
      "PhD",
      "MD",
      "BA",
      "MA",
      "MM",
      "pl",
      "pop",
      "pp",
      "Prof",
      "Dr",
      "pt",
      "Ref",
      "Refs",
      "Rep",
      "repr",
      "rev",
      "Sec",
      "Secs",
      "Sgt",
      "Col",
      "Gen",
      "Rep",
      "Sen",
      "Gov",
      "Lt",
      "Maj",
      "Capt",
      "St",
      "Sr",
      "sr",
      "Jr",
      "jr",
      "Rev",
      "Sun",
      "Mon",
      "Tu",
      "Tue",
      "Tues",
      "Wed",
      "Th",
      "Thu",
      "Thur",
      "Thurs",
      "Fri",
      "Sat",
      "trans",
      "Univ",
      "Viz",
      "Vol",
      "vs",
      "v"
    ];
    exports2.setAbbreviations = function(abbr) {
      if (abbr) {
        abbreviations = abbr;
      } else {
        abbreviations = englishAbbreviations;
      }
    };
    var isCapitalized = exports2.isCapitalized = function(str2) {
      return /^[A-Z][a-z].*/.test(str2) || isNumber(str2);
    };
    exports2.isSentenceStarter = function(str2) {
      return isCapitalized(str2) || /``|"|'/.test(str2.substring(0, 2));
    };
    exports2.isCommonAbbreviation = function(str2) {
      var noSymbols = str2.replace(/[-'`~!@#$%^&*()_|+=?;:'",.<>\{\}\[\]\\\/]/gi, "");
      return ~abbreviations.indexOf(noSymbols);
    };
    exports2.isTimeAbbreviation = function(word, next) {
      if (word === "a.m." || word === "p.m.") {
        var tmp = next.replace(/\W+/g, "").slice(-3).toLowerCase();
        if (tmp === "day") {
          return true;
        }
      }
      return false;
    };
    exports2.isDottedAbbreviation = function(word) {
      var matches = word.replace(/[\(\)\[\]\{\}]/g, "").match(/(.\.)*/);
      return matches && matches[0].length > 0;
    };
    exports2.isCustomAbbreviation = function(str2) {
      if (str2.length <= 3) {
        return true;
      }
      return isCapitalized(str2);
    };
    exports2.isNameAbbreviation = function(wordCount, words) {
      if (words.length > 0) {
        if (wordCount < 5 && words[0].length < 6 && isCapitalized(words[0])) {
          return true;
        }
        var capitalized = words.filter(function(str2) {
          return /[A-Z]/.test(str2.charAt(0));
        });
        return capitalized.length >= 3;
      }
      return false;
    };
    var isNumber = exports2.isNumber = function(str2, dotPos) {
      if (dotPos) {
        str2 = str2.slice(dotPos - 1, dotPos + 2);
      }
      return !isNaN(str2);
    };
    exports2.isPhoneNr = function(str2) {
      return str2.match(/^(?:(?:\+?1\s*(?:[.-]\s*)?)?(?:\(\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\s*\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\s*(?:[.-]\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\s*(?:[.-]\s*)?([0-9]{4})(?:\s*(?:#|x\.?|ext\.?|extension)\s*(\d+))?$/);
    };
    exports2.isURL = function(str2) {
      return str2.match(/[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/);
    };
    exports2.isConcatenated = function(word) {
      var i = 0;
      if ((i = word.indexOf(".")) > -1 || (i = word.indexOf("!")) > -1 || (i = word.indexOf("?")) > -1) {
        var c = word.charAt(i + 1);
        if (c.match(/[a-zA-Z].*/)) {
          return [word.slice(0, i), word.slice(i + 1)];
        }
      }
      return false;
    };
    exports2.isBoundaryChar = function(word) {
      return word === "." || word === "!" || word === "?";
    };
  }
});

// ../../node_modules/.pnpm/sbd@1.0.19/node_modules/sbd/lib/tokenizer.js
var require_tokenizer = __commonJS({
  "../../node_modules/.pnpm/sbd@1.0.19/node_modules/sbd/lib/tokenizer.js"(exports2) {
    var sanitizeHtml = require_sanitize_html();
    var stringHelper = require_stringHelper();
    var Match = require_Match();
    var newline_placeholder = " @~@ ";
    var newline_placeholder_t = newline_placeholder.trim();
    var whiteSpaceCheck = new RegExp("\\S", "");
    var addNewLineBoundaries = new RegExp("\\n+|[-#=_+*]{4,}", "g");
    var splitIntoWords = new RegExp("\\S+|\\n", "g");
    exports2.sentences = function(text, user_options) {
      if (!text || typeof text !== "string" || !text.length) {
        return [];
      }
      if (!whiteSpaceCheck.test(text)) {
        return [];
      }
      var options2 = {
        "newline_boundaries": false,
        "html_boundaries": false,
        "html_boundaries_tags": ["p", "div", "ul", "ol"],
        "sanitize": false,
        "allowed_tags": false,
        "preserve_whitespace": false,
        "abbreviations": null
      };
      if (typeof user_options === "boolean") {
        options2.newline_boundaries = true;
      } else {
        for (var k in user_options) {
          options2[k] = user_options[k];
        }
      }
      Match.setAbbreviations(options2.abbreviations);
      if (options2.newline_boundaries) {
        text = text.replace(addNewLineBoundaries, newline_placeholder);
      }
      if (options2.html_boundaries) {
        var html_boundaries_regexp = "(<br\\s*\\/?>|<\\/(" + options2.html_boundaries_tags.join("|") + ")>)";
        var re = new RegExp(html_boundaries_regexp, "g");
        text = text.replace(re, "$1" + newline_placeholder);
      }
      if (options2.sanitize || options2.allowed_tags) {
        if (!options2.allowed_tags) {
          options2.allowed_tags = [""];
        }
        text = sanitizeHtml(text, { "allowedTags": options2.allowed_tags });
      }
      var words;
      var tokens;
      if (options2.preserve_whitespace) {
        tokens = text.split(/(<br\s*\/?>|\S+|\n+)/);
        words = tokens.filter(function(token, ii) {
          return ii % 2;
        });
      } else {
        words = text.trim().match(splitIntoWords);
      }
      var wordCount = 0;
      var index = 0;
      var temp = [];
      var sentences2 = [];
      var current2 = [];
      if (!words || !words.length) {
        return [];
      }
      for (var i = 0, L = words.length; i < L; i++) {
        wordCount++;
        current2.push(words[i]);
        if (~words[i].indexOf(",")) {
          wordCount = 0;
        }
        if (Match.isBoundaryChar(words[i]) || stringHelper.endsWithChar(words[i], "?!") || words[i] === newline_placeholder_t) {
          if ((options2.newline_boundaries || options2.html_boundaries) && words[i] === newline_placeholder_t) {
            current2.pop();
          }
          sentences2.push(current2);
          wordCount = 0;
          current2 = [];
          continue;
        }
        if (stringHelper.endsWithChar(words[i], '"') || stringHelper.endsWithChar(words[i], "\u201D")) {
          words[i] = words[i].slice(0, -1);
        }
        if (stringHelper.endsWithChar(words[i], ".")) {
          if (i + 1 < L) {
            if (words[i].length === 2 && isNaN(words[i].charAt(0))) {
              continue;
            }
            if (Match.isCommonAbbreviation(words[i])) {
              continue;
            }
            if (Match.isSentenceStarter(words[i + 1])) {
              if (Match.isTimeAbbreviation(words[i], words[i + 1])) {
                continue;
              }
              if (Match.isNameAbbreviation(wordCount, words.slice(i, 6))) {
                continue;
              }
              if (Match.isNumber(words[i + 1])) {
                if (Match.isCustomAbbreviation(words[i])) {
                  continue;
                }
              }
            } else {
              if (stringHelper.endsWith(words[i], "..")) {
                continue;
              }
              if (Match.isDottedAbbreviation(words[i])) {
                continue;
              }
              if (Match.isNameAbbreviation(wordCount, words.slice(i, 5))) {
                continue;
              }
            }
          }
          sentences2.push(current2);
          current2 = [];
          wordCount = 0;
          continue;
        }
        if ((index = words[i].indexOf(".")) > -1) {
          if (Match.isNumber(words[i], index)) {
            continue;
          }
          if (Match.isDottedAbbreviation(words[i])) {
            continue;
          }
          if (Match.isURL(words[i]) || Match.isPhoneNr(words[i])) {
            continue;
          }
        }
        if (temp = Match.isConcatenated(words[i])) {
          current2.pop();
          current2.push(temp[0]);
          sentences2.push(current2);
          current2 = [];
          wordCount = 0;
          current2.push(temp[1]);
        }
      }
      if (current2.length) {
        sentences2.push(current2);
      }
      sentences2 = sentences2.filter(function(s) {
        return s.length > 0;
      });
      var result = sentences2.slice(1).reduce(function(out, sentence) {
        var lastSentence = out[out.length - 1];
        if (lastSentence.length === 1 && /^.{1,2}[.]$/.test(lastSentence[0])) {
          if (!/[.]/.test(sentence[0])) {
            out.pop();
            out.push(lastSentence.concat(sentence));
            return out;
          }
        }
        out.push(sentence);
        return out;
      }, [sentences2[0]]);
      return result.map(function(sentence, ii) {
        if (options2.preserve_whitespace && !options2.newline_boundaries && !options2.html_boundaries) {
          var tokenCount = sentence.length * 2;
          if (ii === 0) {
            tokenCount += 1;
          }
          return tokens.splice(0, tokenCount).join("");
        }
        return sentence.join(" ");
      });
    };
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate2(uuid2) {
      return typeof uuid2 === "string" && _regex.default.test(uuid2);
    }
    var _default2 = validate2;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/stringify.js
var require_stringify3 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    function stringify2(arr, offset = 0) {
      const uuid2 = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid2;
    }
    var _default2 = stringify2;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify3();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v12(options2, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options2 = options2 || {};
      let node = options2.node || _nodeId;
      let clockseq = options2.clockseq !== void 0 ? options2.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options2.random || (options2.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options2.msecs !== void 0 ? options2.msecs : Date.now();
      let nsecs = options2.nsecs !== void 0 ? options2.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options2.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options2.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default2 = v12;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default2 = parse2;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.URL = exports2.DNS = void 0;
    exports2.default = v35;
    var _stringify = require_stringify3();
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str2) {
      str2 = unescape(encodeURIComponent(str2));
      const bytes = [];
      for (let i = 0; i < str2.length; ++i) {
        bytes.push(str2.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function v35(name, version2, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version2;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default2 = md5;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v32 = (0, _v.default)("v3", 48, _md.default);
    var _default2 = v32;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/native.js
var require_native = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default2 = {
      randomUUID: _crypto.default.randomUUID
    };
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify3();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v42(options2, buf, offset) {
      if (_native.default.randomUUID && !buf && !options2) {
        return _native.default.randomUUID();
      }
      options2 = options2 || {};
      const rnds = options2.random || (options2.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default2 = v42;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default2 = sha1;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v52 = (0, _v.default)("v5", 80, _sha.default);
    var _default2 = v52;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default2 = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid2.slice(14, 15), 16);
    }
    var _default2 = version2;
    exports2.default = _default2;
  }
});

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify3());
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str2) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str2);
      if (b instanceof RegExp)
        b = maybeMatch(b, str2);
      var r = range4(a, b, str2);
      return r && {
        start: r[0],
        end: r[1],
        pre: str2.slice(0, r[0]),
        body: str2.slice(r[0] + a.length, r[1]),
        post: str2.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str2) {
      var m = str2.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range4;
    function range4(a, b, str2) {
      var begs, beg, left, right, result;
      var ai = str2.indexOf(a);
      var bi = str2.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str2.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str2.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str2.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str2) {
      return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
    }
    function escapeBraces(str2) {
      return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str2) {
      return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str2) {
      if (!str2)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str2);
      if (!m)
        return str2.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str2) {
      if (!str2)
        return [];
      if (str2.substr(0, 2) === "{}") {
        str2 = "\\{\\}" + str2.substr(2);
      }
      return expand2(escapeBraces(str2), true).map(unescapeBraces);
    }
    function embrace(str2) {
      return "{" + str2 + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str2, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str2);
      if (!m)
        return [str2];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str2 = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str2);
          }
          return [str2];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z2 = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z2 + c.slice(1);
                  else
                    c = z2 + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => entry
});
module.exports = __toCommonJS(src_exports);

// ../common/src/cursorlessCommandIds.ts
var CURSORLESS_COMMAND_ID = "cursorless.command";
var Command = class {
  constructor(baseTitle) {
    this.baseTitle = baseTitle;
  }
  get title() {
    return `Cursorless: ${this.baseTitle}`;
  }
};
var HiddenCommand = class extends Command {
  constructor() {
    super(...arguments);
    this.isVisible = false;
  }
};
var VisibleCommand = class extends Command {
  constructor() {
    super(...arguments);
    this.isVisible = true;
  }
};
var cursorlessCommandDescriptions = {
  ["cursorless.toggleDecorations"]: new VisibleCommand("Toggle decorations"),
  ["cursorless.recomputeDecorationStyles"]: new VisibleCommand(
    "Recompute decoration styles"
  ),
  ["cursorless.recordTestCase"]: new VisibleCommand("Record test case"),
  ["cursorless.recordOneTestCaseThenPause"]: new VisibleCommand(
    "Record one test case, then pause"
  ),
  ["cursorless.pauseRecording"]: new VisibleCommand(
    "Pause test case recording"
  ),
  ["cursorless.resumeRecording"]: new VisibleCommand(
    "Resume test case recording"
  ),
  ["cursorless.showDocumentation"]: new VisibleCommand("Show documentation"),
  ["cursorless.showScopeVisualizer"]: new VisibleCommand(
    "Show the scope visualizer"
  ),
  ["cursorless.hideScopeVisualizer"]: new VisibleCommand(
    "Hide the scope visualizer"
  ),
  ["cursorless.analyzeCommandHistory"]: new VisibleCommand(
    "Analyze collected command history"
  ),
  ["cursorless.command"]: new HiddenCommand("The core cursorless command"),
  ["cursorless.showQuickPick"]: new HiddenCommand(
    "Pop up a quick pick of all cursorless commands"
  ),
  ["cursorless.showCheatsheet"]: new HiddenCommand(
    "Display the cursorless cheatsheet"
  ),
  ["cursorless.internal.updateCheatsheetDefaults"]: new HiddenCommand(
    "Update the default values of the cheatsheet payload used on the website and for local development. Be sure to run this on stock community and cursorless."
  ),
  ["cursorless.private.logQuickActions"]: new HiddenCommand(
    "Log the quick actions available at the current cursor position"
  ),
  ["cursorless.takeSnapshot"]: new HiddenCommand(
    "Take a snapshot of the current editor state"
  ),
  ["cursorless.keyboard.escape"]: new HiddenCommand(
    "Should be mapped to the escape key when using cursorless keyboard. By default, exits modal keyboard mode, but changes behaviour when Cursorless is expecting a continuation keystroke.  For example, when you type a color and Cursorless is waiting for a character, it cancels the color and switches back to modal mode."
  ),
  ["cursorless.keyboard.targeted.targetHat"]: new HiddenCommand(
    "Sets the keyboard target to the given hat"
  ),
  ["cursorless.keyboard.targeted.targetScope"]: new HiddenCommand(
    "Sets the keyboard target to the scope containing the current target"
  ),
  ["cursorless.keyboard.targeted.targetSelection"]: new HiddenCommand(
    "Sets the keyboard target to the current selection"
  ),
  ["cursorless.keyboard.targeted.clearTarget"]: new HiddenCommand(
    "Clears the current keyboard target"
  ),
  ["cursorless.keyboard.targeted.runActionOnTarget"]: new HiddenCommand(
    "Run the given action on the current keyboard target"
  ),
  ["cursorless.keyboard.modal.modeOn"]: new HiddenCommand(
    "Turn on the cursorless modal mode"
  ),
  ["cursorless.keyboard.modal.modeOff"]: new HiddenCommand(
    "Turn off the cursorless modal mode"
  ),
  ["cursorless.keyboard.modal.modeToggle"]: new HiddenCommand(
    "Toggle the cursorless modal mode"
  )
};

// ../common/src/ide/fake/FakeIDE.ts
var import_lodash3 = __toESM(require_lodash(), 1);

// ../common/src/ide/fake/FakeCapabilities.ts
var FakeCapabilities = class {
  constructor() {
    this.commands = {
      clipboardCopy: void 0,
      toggleLineComment: void 0,
      indentLine: void 0,
      outdentLine: void 0,
      rename: void 0,
      quickFix: void 0,
      revealDefinition: void 0,
      revealTypeDefinition: void 0,
      showHover: void 0,
      showDebugHover: void 0,
      extractVariable: void 0,
      fold: void 0,
      highlight: { acceptsLocation: true },
      unfold: void 0,
      showReferences: void 0
    };
  }
};

// ../common/src/ide/fake/FakeClipboard.ts
var FakeClipboard = class {
  constructor() {
    this.clipboardContents = "";
  }
  async readText() {
    return this.clipboardContents;
  }
  async writeText(value) {
    this.clipboardContents = value;
  }
};

// ../common/src/ide/fake/FakeConfiguration.ts
var import_lodash2 = __toESM(require_lodash(), 1);

// ../common/src/util/Notifier.ts
var import_lodash = __toESM(require_lodash(), 1);
var Notifier = class {
  constructor() {
    this.listeners = [];
    /**
     * Notify all listeners that something has changed
     */
    this.notifyListeners = (...args) => {
      this.listeners.forEach((listener) => listener(...args));
    };
    this.registerListener = this.registerListener.bind(this);
  }
  /**
   * Register to be notified when {@link notifyListeners} is called
   * @param listener A function to be called when {@link notifyListeners} is called
   * @returns A function that can be called to unsubscribe from notifications
   */
  registerListener(listener) {
    this.listeners.push(listener);
    return {
      dispose: () => {
        (0, import_lodash.pull)(this.listeners, listener);
      }
    };
  }
};

// ../common/src/ide/types/Configuration.ts
var CONFIGURATION_DEFAULTS = {
  tokenHatSplittingMode: {
    preserveCase: false,
    lettersToPreserve: [],
    symbolsToPreserve: []
  },
  wordSeparators: ["_"],
  decorationDebounceDelayMs: 50,
  experimental: {
    snippetsDir: void 0,
    hatStability: "balanced" /* balanced */
  },
  commandHistory: false,
  debug: false
};

// ../common/src/ide/fake/FakeConfiguration.ts
var FakeConfiguration = class {
  constructor() {
    this.notifier = new Notifier();
    this.mocks = {
      ...CONFIGURATION_DEFAULTS
    };
    this.scopes = [];
    this.onDidChangeConfiguration = this.notifier.registerListener;
    this.onDidChangeConfiguration = this.onDidChangeConfiguration.bind(this);
  }
  getOwnConfiguration(path8, scope) {
    if (scope != null) {
      for (const { scope: candidateScope, values: values2 } of this.scopes) {
        if (scopeMatches(candidateScope, scope)) {
          return (0, import_lodash2.get)(values2, path8) ?? (0, import_lodash2.get)(this.mocks, path8);
        }
      }
    }
    return (0, import_lodash2.get)(this.mocks, path8);
  }
  mockConfiguration(key, value) {
    this.mocks[key] = value;
    this.notifier.notifyListeners();
  }
  mockConfigurationScope(scope, values2, noNotification = false) {
    this.scopes.push({ scope, values: values2 });
    if (!noNotification) {
      this.notifier.notifyListeners();
    }
  }
};
function scopeMatches(candidateScope, scope) {
  return candidateScope.languageId === scope.languageId;
}

// ../common/src/ide/types/State.ts
var STATE_DEFAULTS = {
  hideInferenceWarning: false
};

// ../common/src/ide/fake/FakeGlobalState.ts
var FakeGlobalState = class {
  constructor() {
    this.data = { ...STATE_DEFAULTS };
  }
  get(key) {
    return this.data[key];
  }
  set(key, value) {
    this.data[key] = value;
    return Promise.resolve();
  }
};

// ../common/src/ide/fake/FakeMessages.ts
var FakeMessages = class {
  async showMessage(_type, _id, _message, ..._options) {
    return void 0;
  }
};

// ../common/src/ide/fake/FakeIDE.ts
var FakeIDE = class {
  constructor() {
    this.configuration = new FakeConfiguration();
    this.messages = new FakeMessages();
    this.globalState = new FakeGlobalState();
    this.clipboard = new FakeClipboard();
    this.capabilities = new FakeCapabilities();
    this.runMode = "test";
    this.cursorlessVersion = "0.0.0";
    this.workspaceFolders = void 0;
    this.disposables = [];
    this.quickPickReturnValue = void 0;
    this.onDidOpenTextDocument = dummyEvent;
    this.onDidCloseTextDocument = dummyEvent;
    this.onDidChangeActiveTextEditor = dummyEvent;
    this.onDidChangeVisibleTextEditors = dummyEvent;
    this.onDidChangeTextEditorSelection = dummyEvent;
    this.onDidChangeTextEditorVisibleRanges = dummyEvent;
  }
  async flashRanges(_flashDescriptors) {
  }
  async setHighlightRanges(_highlightId, _editor, _ranges) {
  }
  mockAssetsRoot(_assetsRoot) {
    this.assetsRoot_ = _assetsRoot;
  }
  get assetsRoot() {
    if (this.assetsRoot_ == null) {
      throw Error("Field `assetsRoot` has not yet been mocked");
    }
    return this.assetsRoot_;
  }
  get activeTextEditor() {
    throw Error("Not implemented");
  }
  get activeEditableTextEditor() {
    throw Error("Not implemented");
  }
  get visibleTextEditors() {
    throw Error("Not implemented");
  }
  getEditableTextEditor(_editor) {
    throw Error("Not implemented");
  }
  findInDocument(_query, _editor) {
    throw Error("Not implemented");
  }
  findInWorkspace(_query) {
    throw Error("Not implemented");
  }
  openTextDocument(_path) {
    throw Error("Not implemented");
  }
  openUntitledTextDocument(_options) {
    throw Error("Not implemented");
  }
  setQuickPickReturnValue(value) {
    this.quickPickReturnValue = value;
  }
  async showQuickPick(_items, _options) {
    return this.quickPickReturnValue;
  }
  showInputBox(_options) {
    throw Error("Not implemented");
  }
  executeCommand(_command, ..._args) {
    throw new Error("Method not implemented.");
  }
  onDidChangeTextDocument(_listener) {
    throw Error("Not implemented");
  }
  disposeOnExit(...disposables) {
    this.disposables.push(...disposables);
    return () => (0, import_lodash3.pull)(this.disposables, ...disposables);
  }
  exit() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};
function dummyEvent() {
  return {
    dispose() {
    }
  };
}

// ../common/src/ide/spy/SpyIDE.ts
var import_lodash4 = __toESM(require_lodash(), 1);

// ../common/src/ide/PassthroughIDEBase.ts
var PassthroughIDEBase = class {
  constructor(original) {
    this.original = original;
    this.configuration = original.configuration;
    this.globalState = original.globalState;
    this.clipboard = original.clipboard;
    this.messages = original.messages;
    this.capabilities = original.capabilities;
  }
  flashRanges(flashDescriptors) {
    return this.original.flashRanges(flashDescriptors);
  }
  setHighlightRanges(highlightId, editor, ranges) {
    return this.original.setHighlightRanges(highlightId, editor, ranges);
  }
  onDidOpenTextDocument(listener, thisArgs, disposables) {
    return this.original.onDidOpenTextDocument(listener, thisArgs, disposables);
  }
  onDidCloseTextDocument(listener, thisArgs, disposables) {
    return this.original.onDidCloseTextDocument(
      listener,
      thisArgs,
      disposables
    );
  }
  onDidChangeActiveTextEditor(listener, thisArgs, disposables) {
    return this.original.onDidChangeActiveTextEditor(
      listener,
      thisArgs,
      disposables
    );
  }
  onDidChangeVisibleTextEditors(listener, thisArgs, disposables) {
    return this.original.onDidChangeVisibleTextEditors(
      listener,
      thisArgs,
      disposables
    );
  }
  onDidChangeTextEditorSelection(listener, thisArgs, disposables) {
    return this.original.onDidChangeTextEditorSelection(
      listener,
      thisArgs,
      disposables
    );
  }
  onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables) {
    return this.original.onDidChangeTextEditorVisibleRanges(
      listener,
      thisArgs,
      disposables
    );
  }
  get activeTextEditor() {
    return this.original.activeTextEditor;
  }
  get activeEditableTextEditor() {
    return this.original.activeEditableTextEditor;
  }
  get visibleTextEditors() {
    return this.original.visibleTextEditors;
  }
  get cursorlessVersion() {
    return this.original.cursorlessVersion;
  }
  get assetsRoot() {
    return this.original.assetsRoot;
  }
  get runMode() {
    return this.original.runMode;
  }
  get workspaceFolders() {
    return this.original.workspaceFolders;
  }
  findInDocument(query, editor) {
    return this.original.findInDocument(query, editor);
  }
  findInWorkspace(query) {
    return this.original.findInWorkspace(query);
  }
  openTextDocument(path8) {
    return this.original.openTextDocument(path8);
  }
  openUntitledTextDocument(options2) {
    return this.original.openUntitledTextDocument(options2);
  }
  showQuickPick(items, options2) {
    return this.original.showQuickPick(items, options2);
  }
  showInputBox(options2) {
    return this.original.showInputBox(options2);
  }
  getEditableTextEditor(editor) {
    return this.original.getEditableTextEditor(editor);
  }
  executeCommand(command, ...args) {
    return this.original.executeCommand(command, ...args);
  }
  onDidChangeTextDocument(listener) {
    return this.original.onDidChangeTextDocument(listener);
  }
  disposeOnExit(...disposables) {
    return this.original.disposeOnExit(...disposables);
  }
};

// ../common/src/util/sleep.ts
var import_util = require("util");
var sleep = (0, import_util.promisify)(setTimeout);

// ../common/src/ide/util/messages.ts
function showWarning(messages, id, message, ...options2) {
  return messages.showMessage("warning" /* warning */, id, message, ...options2);
}
function showError(messages, id, message, ...options2) {
  return messages.showMessage("error" /* error */, id, message, ...options2);
}

// ../common/src/util/splitKey.ts
function getKey(hatStyle, character) {
  return `${hatStyle}.${character}`;
}

// ../common/src/util/timeUtils.ts
var nanosecondsPerSecond = BigInt(1e9);
function hrtimeBigintToSeconds(nanoseconds, precision = BigInt(1e6)) {
  return Number(nanoseconds * precision / nanosecondsPerSecond) / Number(precision);
}

// ../common/src/util/walkAsync.ts
var path = __toESM(require("path"), 1);
var import_promises = require("fs/promises");
var import_lodash5 = __toESM(require_lodash(), 1);
var walkFiles = async (dir, fileEnding) => {
  const dirEntries = await (0, import_promises.readdir)(dir, { withFileTypes: true });
  const files = (0, import_lodash5.flatten)(
    await Promise.all(
      dirEntries.map(async (dirent) => {
        const filePath = path.join(dir, dirent.name);
        return dirent.isDirectory() ? await walkFiles(filePath) : [filePath];
      })
    )
  );
  if (fileEnding != null) {
    return files.filter((file) => file.endsWith(fileEnding));
  }
  return files;
};

// ../common/src/util/disposableFrom.ts
function disposableFrom(...disposables) {
  return {
    dispose() {
      disposables.forEach(({ dispose }) => {
        try {
          dispose();
        } catch (e) {
          console.error(e);
        }
      });
    }
  };
}

// ../common/src/util/camelCaseToAllDown.ts
function camelCaseToAllDown(input) {
  return input.replace(/([A-Z])/g, " $1").split(" ").map((word) => word.toLowerCase()).join(" ");
}

// ../common/src/types/Position.ts
var Position = class _Position {
  /**
   * @param line A zero-based line value.
   * @param character A zero-based character value.
   */
  constructor(line, character) {
    this.line = line;
    this.character = character;
  }
  /**
   * Check if this position is equal to `other`.
   *
   * @param other A position.
   * @return `true` if the line and character of the given position are equal to
   * the line and character of this position.
   */
  isEqual(other) {
    return this.line === other.line && this.character === other.character;
  }
  /**
   * Check if this position is before `other`.
   *
   * @param other A position.
   * @return `true` if position is on a smaller line
   * or on the same line on a smaller character.
   */
  isBefore(other) {
    if (this.line < other.line) {
      return true;
    }
    if (this.line > other.line) {
      return false;
    }
    return this.character < other.character;
  }
  /**
   * Check if this position is after `other`.
   *
   * @param other A position.
   * @return `true` if position is on a greater line
   * or on the same line on a greater character.
   */
  isAfter(other) {
    if (this.line > other.line) {
      return true;
    }
    if (this.line < other.line) {
      return false;
    }
    return this.character > other.character;
  }
  /**
   * Check if this position is before or equal to `other`.
   *
   * @param other A position.
   * @return `true` if position is on a smaller line
   * or on the same line on a smaller or equal character.
   */
  isBeforeOrEqual(other) {
    return this.isEqual(other) || this.isBefore(other);
  }
  /**
   * Check if this position is after or equal to `other`.
   *
   * @param other A position.
   * @return `true` if position is on a greater line
   * or on the same line on a greater or equal character.
   */
  isAfterOrEqual(other) {
    return this.isEqual(other) || this.isAfter(other);
  }
  /**
   * Compare this to `other`.
   *
   * @param other A position.
   * @return A number smaller than zero if this position is before the given position,
   * a number greater than zero if this position is after the given position, or zero when
   * this and the given position are equal.
   */
  compareTo(other) {
    if (this.isBefore(other)) {
      return -1;
    }
    if (this.isAfter(other)) {
      return 1;
    }
    return 0;
  }
  /**
   * Create a new position derived from this position.
   *
   * @param line Value that should be used as line value, default is the {@link Position.line existing value}
   * @param character Value that should be used as character value, default is the {@link Position.character existing value}
   * @return A position where line and character are replaced by the given values.
   */
  with(line, character) {
    return new _Position(line ?? this.line, character ?? this.character);
  }
  /**
   * Create a new position relative to this position.
   *
   * @param lineDelta Delta value for the line value, default is `0`.
   * @param characterDelta Delta value for the character value, default is `0`.
   * @return A position which line and character is the sum of the current line and
   * character and the corresponding deltas.
   */
  translate(lineDelta, characterDelta) {
    return new _Position(
      this.line + (lineDelta ?? 0),
      this.character + (characterDelta ?? 0)
    );
  }
  /**
   * Create a new empty range from this position.
   * @returns A {@link Range}
   */
  toEmptyRange() {
    return new Range(this, this);
  }
  /**
   * Return a concise string representation of the position.
   * @returns concise representation
   **/
  concise() {
    return `${this.line}:${this.character}`;
  }
  toString() {
    return this.concise();
  }
};
function adjustPosition(doc, pos, by) {
  return doc.positionAt(doc.offsetAt(pos) + by);
}

// ../common/src/types/Range.ts
var Range = class _Range {
  constructor(...args) {
    const [p1, p2] = (() => {
      if (args.length === 2) {
        return args;
      }
      return [new Position(args[0], args[1]), new Position(args[2], args[3])];
    })();
    if (p1.isBefore(p2)) {
      this.start = p1;
      this.end = p2;
    } else {
      this.start = p2;
      this.end = p1;
    }
  }
  /**
   * `true` if `start` and `end` are equal.
   */
  get isEmpty() {
    return this.start.isEqual(this.end);
  }
  /**
   * `true` if `start.line` and `end.line` are equal.
   */
  get isSingleLine() {
    return this.start.line === this.end.line;
  }
  /**
   * Check if `other` equals this range.
   *
   * @param other A range.
   * @return `true` when start and end are {@link Position.isEqual equal} to
   * start and end of this range.
   */
  isRangeEqual(other) {
    return this.start.isEqual(other.start) && this.end.isEqual(other.end);
  }
  /**
   * Check if a position or a range is contained in this range.
   *
   * @param positionOrRange A position or a range.
   * @return `true` if the position or range is inside or equal
   * to this range.
   */
  contains(positionOrRange) {
    const [start, end] = positionOrRange instanceof Position ? [positionOrRange, positionOrRange] : [positionOrRange.start, positionOrRange.end];
    return start.isAfterOrEqual(this.start) && end.isBeforeOrEqual(this.end);
  }
  /**
   * Intersect `range` with this range and returns a new range.
   * If the ranges are adjacent but non-overlapping, the resulting range is empty.
   * If the ranges have no overlap and are not adjacent, it returns `undefined`.
   *
   * @param other A range.
   * @return A range of the greater start and smaller end positions. Will
   * return undefined when there is no overlap.
   */
  intersection(other) {
    const start = this.start.isAfter(other.start) ? this.start : other.start;
    const end = this.end.isBefore(other.end) ? this.end : other.end;
    return start.isBeforeOrEqual(end) ? new _Range(start, end) : void 0;
  }
  /**
   * Compute the union of `other` with this range.
   *
   * @param other A range.
   * @return A range of smaller start position and the greater end position.
   */
  union(other) {
    return new _Range(
      this.start.isBefore(other.start) ? this.start : other.start,
      this.end.isAfter(other.end) ? this.end : other.end
    );
  }
  /**
   * Derive a new range from this range.
   * If the resulting range has end before start, they are swapped.
   *
   * @param start A position that should be used as start. The default value is the {@link Range.start current start}.
   * @param end A position that should be used as end. The default value is the {@link Range.end current end}.
   * @return A range derived from this range with the given start and end position.
   */
  with(start, end) {
    return new _Range(start ?? this.start, end ?? this.end);
  }
  /**
   * Construct a new selection from this range
   * @param isReversed If true active is before anchor
   * @returns A new selection
   */
  toSelection(isReversed) {
    return isReversed ? new Selection(this.end, this.start) : new Selection(this.start, this.end);
  }
  /**
   * Return a concise string representation of the range
   * @returns concise representation
   **/
  concise() {
    return `${this.start.concise()}-${this.end.concise()}`;
  }
  toString() {
    return this.concise();
  }
};

// ../common/src/types/Selection.ts
var Selection = class extends Range {
  /**
   * Is true if active position is before anchor position.
   */
  get isReversed() {
    return this.active.isBefore(this.anchor);
  }
  constructor(...args) {
    const [anchor, active] = (() => {
      if (args.length === 2) {
        return args;
      }
      return [new Position(args[0], args[1]), new Position(args[2], args[3])];
    })();
    super(anchor, active);
    this.anchor = anchor;
    this.active = active;
  }
  /**
   * Check if `other` equals this range.
   *
   * @param other A selection.
   * @return `true` when anchor and active are {@link Position.isEqual equal} to
   * anchor and active of this range.
   */
  isEqual(other) {
    return this.anchor.isEqual(other.anchor) && this.active.isEqual(other.active);
  }
  /**
   * Return a concise string representation of the selection
   * @returns concise representation
   **/
  concise() {
    return `${this.anchor.concise()}->${this.active.concise()}`;
  }
  toString() {
    return this.concise();
  }
};

// ../common/src/util/textFormatters.ts
var textFormatters = {
  camelCase(tokens) {
    if (tokens.length === 0) {
      return "";
    }
    const [first, ...rest] = tokens;
    return first + rest.map(capitalizeToken).join("");
  },
  snakeCase(tokens) {
    return tokens.join("_");
  },
  upperSnakeCase(tokens) {
    return tokens.map((token) => token.toUpperCase()).join("_");
  },
  pascalCase(tokens) {
    return tokens.map(capitalizeToken).join("");
  }
};
function capitalizeToken(token) {
  return token.length === 0 ? "" : token[0].toUpperCase() + token.substr(1);
}

// ../common/src/testUtil/fromPlainObject.ts
function plainObjectToPosition({
  line,
  character
}) {
  return new Position(line, character);
}
function plainObjectToRange({ start, end }) {
  return new Range(plainObjectToPosition(start), plainObjectToPosition(end));
}

// ../common/src/types/GeneralizedRange.ts
function toLineRange(range4) {
  return { type: "line", start: range4.start.line, end: range4.end.line };
}
function toCharacterRange({ start, end }) {
  return { type: "character", start, end };
}

// ../common/src/util/toPlainObject.ts
function rangeToPlainObject(range4) {
  return {
    start: positionToPlainObject(range4.start),
    end: positionToPlainObject(range4.end)
  };
}
function selectionToPlainObject(selection) {
  return {
    anchor: positionToPlainObject(selection.anchor),
    active: positionToPlainObject(selection.active)
  };
}
function positionToPlainObject({
  line,
  character
}) {
  return { line, character };
}

// ../common/src/util/DefaultMap.ts
var DefaultMap = class extends Map {
  /**
   * @param getDefaultValue A function that returns the default value for a given key
   */
  constructor(getDefaultValue) {
    super();
    this.getDefaultValue = getDefaultValue;
  }
  get(key) {
    const currentValue = super.get(key);
    if (currentValue != null) {
      return currentValue;
    }
    const value = this.getDefaultValue(key);
    this.set(key, value);
    return value;
  }
};

// ../common/src/util/omitByDeep.ts
var import_lodash6 = __toESM(require_lodash(), 1);

// ../common/src/util/range.ts
var import_lodash7 = __toESM(require_lodash(), 1);

// ../common/src/util/uniqWithHash.ts
var import_lodash8 = __toESM(require_lodash(), 1);
function uniqWithHash(array, isEqual5, hash) {
  if (array.length < 2) {
    return [...array];
  }
  if (array.length === 2) {
    if (isEqual5(array[0], array[1])) {
      return [array[0]];
    }
    return [...array];
  }
  const needsUniq = [];
  const hashToItems = array.reduce((acc, item) => {
    const key = hash(item);
    const items = acc.get(key);
    if (items == null) {
      acc.set(key, [item]);
      return acc;
    }
    acc.get(key).push(item);
    if (items.length === 2) {
      needsUniq.push(key);
    }
    return acc;
  }, /* @__PURE__ */ new Map());
  if (needsUniq.length === 0) {
    return [...array];
  }
  needsUniq.forEach((key) => {
    hashToItems.set(key, (0, import_lodash8.uniqWith)(hashToItems.get(key), isEqual5));
  });
  return array.flatMap((item) => {
    const key = hash(item);
    const items = hashToItems.get(key);
    if (items == null || items.length === 0) {
      return [];
    }
    const first = items[0];
    if (!isEqual5(first, item)) {
      return [];
    }
    items.shift();
    return first;
  });
}

// ../common/src/testUtil/isTesting.ts
var isTesting = () => process.env.CURSORLESS_TEST != null;

// ../common/src/testUtil/getFixturePaths.ts
var path2 = __toESM(require("path"), 1);

// ../common/src/testUtil/getCursorlessRepoRoot.ts
function getCursorlessRepoRoot() {
  const root = process.env["CURSORLESS_REPO_ROOT"];
  if (root == null) {
    throw new Error(
      "CURSORLESS_REPO_ROOT environment variable must be set to run this script"
    );
  }
  return root;
}

// ../common/src/testUtil/getFixturePaths.ts
function getFixturesPath() {
  return path2.join(getCursorlessRepoRoot(), "data", "fixtures");
}
function getFixturePath(fixturePath) {
  return path2.join(getFixturesPath(), fixturePath);
}

// ../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string2, count2) {
  var result = "", cycle;
  for (cycle = 0; cycle < count2; cycle += 1) {
    result += string2;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string2, max2) {
  return common.repeat(" ", max2 - string2.length) + string2;
}
function makeSnippet(mark, options2) {
  options2 = Object.create(options2 || null);
  if (!mark.buffer)
    return null;
  if (!options2.maxLength)
    options2.maxLength = 79;
  if (typeof options2.indent !== "number")
    options2.indent = 1;
  if (typeof options2.linesBefore !== "number")
    options2.linesBefore = 3;
  if (typeof options2.linesAfter !== "number")
    options2.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match2;
  var foundLineNo = -1;
  while (match2 = re.exec(mark.buffer)) {
    lineEnds.push(match2.index);
    lineStarts.push(match2.index + match2[0].length);
    if (mark.position <= match2.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
  for (i = 1; i <= options2.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options2.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options2.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options2.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map4) {
  var result = {};
  if (map4 !== null) {
    Object.keys(map4).forEach(function(style) {
      map4[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options2;
  this.tag = tag;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.representName = options2["representName"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.multi = options2["multi"] || false;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema3, name) {
  var result = [];
  schema3[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max2 = data.length, index = 0, hasDigits = false, ch;
  if (!max2)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max2)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max2; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match2 = YAML_DATE_REGEXP.exec(data);
  if (match2 === null)
    match2 = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match2 === null)
    throw new Error("Date resolve error");
  year = +match2[1];
  month = +match2[2] - 1;
  day = +match2[3];
  if (!match2[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match2[4];
  minute = +match2[5];
  second = +match2[6];
  if (match2[7]) {
    fraction = match2[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match2[9]) {
    tz_hour = +match2[10];
    tz_minute = +(match2[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match2[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max2 = data.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    code = map4.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map4 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map4.indexOf(input.charAt(idx));
  }
  tailbits = max2 % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map4[bits >> 18 & 63];
      result += map4[bits >> 12 & 63];
      result += map4[bits >> 6 & 63];
      result += map4[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max2 % 3;
  if (tail === 0) {
    result += map4[bits >> 18 & 63];
    result += map4[bits >> 12 & 63];
    result += map4[bits >> 6 & 63];
    result += map4[bits & 63];
  } else if (tail === 2) {
    result += map4[bits >> 10 & 63];
    result += map4[bits >> 4 & 63];
    result += map4[bits << 2 & 63];
    result += map4[64];
  } else if (tail === 1) {
    result += map4[bits >> 2 & 63];
    result += map4[bits << 4 & 63];
    result += map4[64];
    result += map4[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || _default;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match2, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match2 === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match2[1], 10);
    minor = parseInt(match2[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count2) {
  if (count2 === 1) {
    state.result += " ";
  } else if (count2 > 1) {
    state.result += common.repeat("\n", count2 - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options2) {
  if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema3, map4) {
  var result, keys, index, length, tag, style, type2;
  if (map4 === null)
    return {};
  result = {};
  keys = Object.keys(map4);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map4[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema3.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string2, handle, length;
  string2 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string2.length) + string2;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options2) {
  this.schema = options2["schema"] || _default;
  this.indent = Math.max(1, options2["indent"] || 2);
  this.noArrayIndent = options2["noArrayIndent"] || false;
  this.skipInvalid = options2["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
  this.sortKeys = options2["sortKeys"] || false;
  this.lineWidth = options2["lineWidth"] || 80;
  this.noRefs = options2["noRefs"] || false;
  this.noCompatMode = options2["noCompatMode"] || false;
  this.condenseFlow = options2["condenseFlow"] || false;
  this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options2["forceQuotes"] || false;
  this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string2, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
  while (position < length) {
    next = string2.indexOf("\n", position);
    if (next === -1) {
      line = string2.slice(position);
      position = length;
    } else {
      line = string2.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string2, pos) {
  var first = string2.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
    second = string2.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string2) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string2);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string2, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string2, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string2)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string2)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string2, level, iskey, inblock) {
  state.dump = function() {
    if (string2.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string3) {
      return testImplicitResolving(state, string3);
    }
    switch (chooseScalarStyle(
      string2,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string2;
      case STYLE_SINGLE:
        return "'" + string2.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string2) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string2, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
  var clip = string2[string2.length - 1] === "\n";
  var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string2) {
  return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
}
function foldString(string2, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string2.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string2.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string2.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
  var moreIndented;
  var match2;
  while (match2 = lineRe.exec(string2)) {
    var prefix = match2[1], line = match2[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match2;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match2 = breakRe.exec(line)) {
    next = match2.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string2) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string2, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string2[i];
      if (char >= 65536)
        result += string2[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// ../common/src/testUtil/serialize.ts
var CustomDump = class {
  constructor(data, opts) {
    this.data = data;
    this.opts = opts;
  }
  represent() {
    let result = dump(
      this.data,
      Object.assign({ replacer, schema: schema2 }, this.opts)
    );
    result = result.trim();
    if (result.includes("\n")) {
      result = "\n" + result;
    }
    return result;
  }
};
var customDumpType = new Type("!format", {
  kind: "scalar",
  resolve: () => false,
  instanceOf: CustomDump,
  represent: (d) => d.represent()
});
var schema2 = DEFAULT_SCHEMA.extend({ implicit: [customDumpType] });
var isObject2 = (value) => typeof value === "object" && value != null;
function hasSimpleChildren(value) {
  if (isObject2(value)) {
    return Object.values(value).every(
      (value2) => !isObject2(value2) && !Array.isArray(value2)
    );
  }
  if (Array.isArray(value)) {
    return value.every((value2) => !isObject2(value2) && !Array.isArray(value2));
  }
}
function replacer(key, value) {
  if (key === "") {
    return value;
  }
  if (hasSimpleChildren(value)) {
    return new CustomDump(value, { flowLevel: 0 });
  }
  return value;
}

// ../common/src/errors.ts
var UnsupportedLanguageError = class extends Error {
  constructor(languageId) {
    super(
      `Language '${languageId}' is not implemented yet; See https://www.cursorless.org/docs/contributing/adding-a-new-language/`
    );
    this.name = "UnsupportedLanguageError";
  }
};
var OutdatedExtensionError = class extends Error {
  constructor() {
    super(
      "Cursorless Talon version is ahead of Cursorless VSCode extension version. Please update Cursorless VSCode."
    );
  }
};
var NoContainingScopeError = class extends Error {
  /**
   *
   * @param scopeType The scopeType for the failed match to show to the user
   */
  constructor(scopeType) {
    super(`Couldn't find containing ${scopeType}.`);
    this.name = "NoContainingScopeError";
  }
};

// ../common/src/util/CompositeKeyMap.ts
var CompositeKeyMap = class {
  /**
   *
   * @param hashFunction A function that maps from a key to a list whose entries can be converted to string
   */
  constructor(hashFunction) {
    this.hashFunction = hashFunction;
    this.map = {};
  }
  hash(key) {
    return this.hashFunction(key).join("\0");
  }
  set(key, item) {
    this.map[this.hash(key)] = item;
    return this;
  }
  has(key) {
    return this.hash(key) in this.map;
  }
  get(key) {
    return this.map[this.hash(key)];
  }
  delete(key) {
    delete this.map[this.hash(key)];
    return this;
  }
  clear() {
    this.map = {};
    return this;
  }
};

// ../common/src/ide/normalized/NormalizedIDE.ts
var NormalizedIDE = class extends PassthroughIDEBase {
  constructor(original, fakeIde, isSilent) {
    super(original);
    this.fakeIde = fakeIde;
    this.isSilent = isSilent;
    this.messages = isSilent ? fakeIde.messages : original.messages;
    this.configuration = fakeIde.configuration;
    this.globalState = fakeIde.globalState;
    this.clipboard = fakeIde.clipboard;
    this.initializeConfiguration();
  }
  initializeConfiguration() {
    this.configuration.mockConfigurationScope(
      { languageId: "css" },
      { wordSeparators: ["_", "-"] },
      true
    );
    this.configuration.mockConfigurationScope(
      { languageId: "scss" },
      { wordSeparators: ["_", "-"] },
      true
    );
    this.configuration.mockConfigurationScope(
      { languageId: "shellscript" },
      { wordSeparators: ["_", "-"] },
      true
    );
    this.configuration.mockConfiguration("experimental", {
      hatStability: this.configuration.getOwnConfiguration(
        "experimental.hatStability"
      ),
      snippetsDir: getFixturePath("cursorless-snippets")
    });
  }
  flashRanges(flashDescriptors) {
    return this.isSilent ? this.fakeIde.flashRanges(flashDescriptors) : super.flashRanges(flashDescriptors);
  }
  setHighlightRanges(highlightId, editor, ranges) {
    return this.isSilent ? this.fakeIde.setHighlightRanges(highlightId, editor, ranges) : super.setHighlightRanges(highlightId, editor, ranges);
  }
  async showQuickPick(_items, _options) {
    return this.isSilent ? this.fakeIde.showQuickPick(_items, _options) : super.showQuickPick(_items, _options);
  }
};

// ../common/src/types/command/command.types.ts
var LATEST_VERSION = 7;

// ../common/src/types/command/PartialTargetDescriptor.types.ts
var simpleSurroundingPairNames = [
  "angleBrackets",
  "backtickQuotes",
  "curlyBrackets",
  "doubleQuotes",
  "escapedDoubleQuotes",
  "escapedParentheses",
  "escapedSquareBrackets",
  "escapedSingleQuotes",
  "parentheses",
  "singleQuotes",
  "squareBrackets"
];
var complexSurroundingPairNames = [
  "string",
  "any",
  "collectionBoundary"
];
var surroundingPairNames = [
  ...simpleSurroundingPairNames,
  ...complexSurroundingPairNames
];
var simpleScopeTypeTypes = [
  "argumentOrParameter",
  "anonymousFunction",
  "attribute",
  "branch",
  "class",
  "className",
  "collectionItem",
  "collectionKey",
  "comment",
  "private.fieldAccess",
  "functionCall",
  "functionCallee",
  "functionName",
  "ifStatement",
  "instance",
  "list",
  "map",
  "name",
  "namedFunction",
  "regularExpression",
  "statement",
  "string",
  "type",
  "value",
  "condition",
  "section",
  "sectionLevelOne",
  "sectionLevelTwo",
  "sectionLevelThree",
  "sectionLevelFour",
  "sectionLevelFive",
  "sectionLevelSix",
  "selector",
  "private.switchStatementSubject",
  "unit",
  "xmlBothTags",
  "xmlElement",
  "xmlEndTag",
  "xmlStartTag",
  // Latex scope types
  "part",
  "chapter",
  "subSection",
  "subSubSection",
  "namedParagraph",
  "subParagraph",
  "environment",
  // Text based scopes
  "character",
  "word",
  "token",
  "identifier",
  "line",
  "sentence",
  "paragraph",
  "document",
  "nonWhitespaceSequence",
  "boundedNonWhitespaceSequence",
  "url",
  "notebookCell",
  // Talon
  "command"
];
function isSimpleScopeType(scopeType) {
  return simpleScopeTypeTypes.includes(scopeType.type);
}

// ../common/src/types/command/ActionDescriptor.ts
var simpleActionNames = [
  "breakLine",
  "clearAndSetSelection",
  "copyToClipboard",
  "cutToClipboard",
  "decrement",
  "deselect",
  "editNewLineAfter",
  "editNewLineBefore",
  "experimental.setInstanceReference",
  "extractVariable",
  "findInDocument",
  "findInWorkspace",
  "foldRegion",
  "followLink",
  "increment",
  "indentLine",
  "insertCopyAfter",
  "insertCopyBefore",
  "insertEmptyLineAfter",
  "insertEmptyLineBefore",
  "insertEmptyLinesAround",
  "joinLines",
  "outdentLine",
  "randomizeTargets",
  "remove",
  "rename",
  "revealDefinition",
  "revealTypeDefinition",
  "reverseTargets",
  "scrollToBottom",
  "scrollToCenter",
  "scrollToTop",
  "setSelection",
  "setSelectionAfter",
  "setSelectionBefore",
  "showDebugHover",
  "showHover",
  "showQuickFix",
  "showReferences",
  "sortTargets",
  "toggleLineBreakpoint",
  "toggleLineComment",
  "unfoldRegion",
  "private.setKeyboardTarget",
  "private.showParseTree",
  "private.getTargets"
];
var complexActionNames = [
  "callAsFunction",
  "editNew",
  "executeCommand",
  "generateSnippet",
  "getText",
  "highlight",
  "insertSnippet",
  "moveToTarget",
  "pasteFromClipboard",
  "replace",
  "replaceWithTarget",
  "rewrapWithPairedDelimiter",
  "swapTargets",
  "wrapWithPairedDelimiter",
  "wrapWithSnippet"
];
var actionNames = [
  ...simpleActionNames,
  ...complexActionNames
];

// ../common/src/util/itertools.ts
function groupBy(list, func) {
  const map4 = /* @__PURE__ */ new Map();
  list.forEach((element) => {
    const key = func(element);
    let group;
    if (map4.has(key)) {
      group = map4.get(key);
    } else {
      group = [];
      map4.set(key, group);
    }
    group.push(element);
  });
  return map4;
}
function isEmptyIterable(iterable) {
  for (const _ of iterable) {
    return false;
  }
  return true;
}

// ../common/src/FakeCommandServerApi.ts
var FakeCommandServerApi = class {
  constructor() {
    this.signals = { prePhrase: { getVersion: async () => null } };
  }
  async getFocusedElementType() {
    return this.focusedElementType;
  }
  setFocusedElementType(focusedElementType) {
    this.focusedElementType = focusedElementType;
  }
};

// ../common/src/util/type.ts
function isString(arg) {
  return typeof arg === "string" || arg instanceof String;
}

// ../common/src/util/ensureCommandShape.ts
function ensureCommandShape(args) {
  const [spokenFormOrCommand, ...rest] = args;
  return handleLegacyCommandShape(spokenFormOrCommand, rest);
}
function handleLegacyCommandShape(spokenFormOrCommand, rest) {
  let command;
  if (isString(spokenFormOrCommand)) {
    const spokenForm = spokenFormOrCommand;
    const [action, targets, ...extraArgs] = rest;
    command = {
      version: 0,
      spokenForm,
      action,
      targets,
      extraArgs,
      usePrePhraseSnapshot: false
    };
  } else {
    command = spokenFormOrCommand;
  }
  return command;
}

// ../common/src/util/clientSupportsFallback.ts
function clientSupportsFallback(command) {
  return command.version >= 7;
}

// ../common/src/scopeSupportFacets/scopeSupportFacets.types.ts
var ScopeSupportFacetLevel = /* @__PURE__ */ ((ScopeSupportFacetLevel2) => {
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["supported"] = 0] = "supported";
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["supportedLegacy"] = 1] = "supportedLegacy";
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["unsupported"] = 2] = "unsupported";
  ScopeSupportFacetLevel2[ScopeSupportFacetLevel2["notApplicable"] = 3] = "notApplicable";
  return ScopeSupportFacetLevel2;
})(ScopeSupportFacetLevel || {});

// ../common/src/scopeSupportFacets/c.ts
var { supported, unsupported, notApplicable } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/clojure.ts
var { supported: supported2, unsupported: unsupported2, notApplicable: notApplicable2 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/cpp.ts
var { supported: supported3, unsupported: unsupported3, notApplicable: notApplicable3 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/csharp.ts
var { supported: supported4, unsupported: unsupported4, notApplicable: notApplicable4 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/css.ts
var { supported: supported5, unsupported: unsupported5, notApplicable: notApplicable5 } = ScopeSupportFacetLevel;
var cssScopeSupport = {
  "comment.line": supported5,
  "comment.block": supported5,
  "string.singleLine": supported5
};

// ../common/src/scopeSupportFacets/go.ts
var { supported: supported6, unsupported: unsupported6, notApplicable: notApplicable6 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/html.ts
var { supported: supported7, notApplicable: notApplicable7 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/java.ts
var { supported: supported8, notApplicable: notApplicable8 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/javascript.ts
var { supported: supported9, unsupported: unsupported7, notApplicable: notApplicable9 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/json.ts
var { supported: supported10 } = ScopeSupportFacetLevel;
var jsonScopeSupport = {
  "comment.line": supported10,
  "comment.block": supported10
};

// ../common/src/scopeSupportFacets/jsonc.ts
var { supported: supported11, unsupported: unsupported8, notApplicable: notApplicable10 } = ScopeSupportFacetLevel;
var jsoncScopeSupport = {
  ...jsonScopeSupport
};

// ../common/src/scopeSupportFacets/latex.ts
var { supported: supported12, unsupported: unsupported9, notApplicable: notApplicable11 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/lua.ts
var { supported: supported13, notApplicable: notApplicable12 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/markdown.ts
var { supported: supported14, unsupported: unsupported10, notApplicable: notApplicable13 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/python.ts
var { supported: supported15, supportedLegacy, notApplicable: notApplicable14 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/ruby.ts
var { supported: supported16, unsupported: unsupported11, notApplicable: notApplicable15 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/rust.ts
var { supported: supported17, unsupported: unsupported12, notApplicable: notApplicable16 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scala.ts
var { supported: supported18, unsupported: unsupported13, notApplicable: notApplicable17 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/scss.ts
var { supported: supported19, unsupported: unsupported14, notApplicable: notApplicable18 } = ScopeSupportFacetLevel;
var scssScopeSupport = {
  ...cssScopeSupport
};

// ../common/src/scopeSupportFacets/talon.ts
var { supported: supported20 } = ScopeSupportFacetLevel;

// ../common/src/scopeSupportFacets/typescript.ts
var { supported: supported21 } = ScopeSupportFacetLevel;
var typescriptScopeSupport = {
  // ...javascriptScopeSupport,
  "type.variable": supported21,
  "type.formalParameter": supported21,
  "type.return": supported21,
  "type.field": supported21,
  "type.interface": supported21,
  "type.alias": supported21,
  "name.field": supported21,
  "value.field": supported21
};

// ../common/src/scopeSupportFacets/typescriptreact.ts
var { supported: supported22, unsupported: unsupported15, notApplicable: notApplicable19 } = ScopeSupportFacetLevel;
var typescriptreactScopeSupport = {
  ...typescriptScopeSupport
};

// ../common/src/StoredTargetKey.ts
var storedTargetKeys = [
  "that",
  "source",
  "instanceReference",
  "keyboard"
];

// ../cursorless-engine/src/processTargets/targets/BaseTarget.ts
var import_lodash9 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/rangeUtils.ts
function expandToFullLine(editor, range4) {
  return new Range(
    new Position(range4.start.line, 0),
    editor.document.lineAt(range4.end).range.end
  );
}
function getRangeLength(editor, range4) {
  return range4.isEmpty ? 0 : editor.document.offsetAt(range4.end) - editor.document.offsetAt(range4.start);
}
function strictlyContains(range1, rangeOrPosition) {
  const [start, end] = rangeOrPosition instanceof Position ? [rangeOrPosition, rangeOrPosition] : [rangeOrPosition.start, rangeOrPosition.end];
  return range1.start.isBefore(start) && range1.end.isAfter(end);
}
function union(range4, ...unionWith) {
  for (const r of unionWith) {
    if (r != null) {
      range4 = range4.union(r);
    }
  }
  return range4;
}

// ../cursorless-engine/src/processTargets/targets/DestinationImpl.ts
var DestinationImpl = class _DestinationImpl {
  constructor(target, insertionMode, indentationString) {
    this.target = target;
    this.insertionMode = insertionMode;
    this.contentRange = getContentRange(target.contentRange, insertionMode);
    this.isBefore = insertionMode === "before";
    this.isLineDelimiter = target.insertionDelimiter.includes("\n");
    this.indentationString = indentationString ?? this.isLineDelimiter ? getIndentationString(target.editor, target.contentRange) : "";
    this.insertionPrefix = target.prefixRange != null ? target.editor.document.getText(target.prefixRange) : void 0;
  }
  get contentSelection() {
    return this.contentRange.toSelection(this.target.isReversed);
  }
  get editor() {
    return this.target.editor;
  }
  get insertionDelimiter() {
    return this.target.insertionDelimiter;
  }
  get isRaw() {
    return this.target.isRaw;
  }
  /**
   * Creates a new destination with the given target while preserving insertion
   * mode and indentation string from this destination. This is important
   * because our "edit new" code updates the content range of the target when
   * multiple edits are performed in the same document, but we want to insert
   * the original indentation.
   */
  withTarget(target) {
    return new _DestinationImpl(
      target,
      this.insertionMode,
      this.indentationString
    );
  }
  getEditNewActionType() {
    if (this.insertionMode === "after" && this.target.contentRange.isSingleLine && this.insertionDelimiter === "\n" && this.insertionPrefix == null) {
      return "insertLineAfter";
    }
    return "edit";
  }
  constructChangeEdit(text) {
    return this.insertionMode === "before" || this.insertionMode === "after" ? this.constructEditWithDelimiters(text) : this.constructEditWithoutDelimiters(text);
  }
  constructEditWithDelimiters(text) {
    const range4 = this.getEditRange();
    const editText2 = this.getEditText(text);
    const updateRange = (range5) => {
      return this.updateRange(range5, text);
    };
    return {
      range: range4,
      text: editText2,
      isReplace: this.insertionMode === "after",
      updateRange
    };
  }
  constructEditWithoutDelimiters(text) {
    return {
      range: this.contentRange,
      text,
      updateRange: (range4) => range4
    };
  }
  getEditRange() {
    const position = (() => {
      const insertionPosition = this.isBefore ? union(this.target.contentRange, this.target.prefixRange).start : this.target.contentRange.end;
      if (this.isLineDelimiter) {
        const line = this.editor.document.lineAt(insertionPosition);
        const nonWhitespaceCharacterIndex = this.isBefore ? line.firstNonWhitespaceCharacterIndex : line.lastNonWhitespaceCharacterIndex;
        if (insertionPosition.character === nonWhitespaceCharacterIndex) {
          return this.isBefore ? line.range.start : line.range.end;
        }
      }
      return insertionPosition;
    })();
    return new Range(position, position);
  }
  getEditText(text) {
    const insertionText = this.indentationString + (this.insertionPrefix ?? "") + text;
    return this.isBefore ? insertionText + this.insertionDelimiter : this.insertionDelimiter + insertionText;
  }
  updateRange(range4, text) {
    const baseStartOffset = this.editor.document.offsetAt(range4.start) + this.indentationString.length + (this.insertionPrefix?.length ?? 0);
    const startIndex = this.isBefore ? baseStartOffset : baseStartOffset + this.getLengthOfInsertionDelimiter();
    const endIndex = startIndex + text.length;
    return new Range(
      this.editor.document.positionAt(startIndex),
      this.editor.document.positionAt(endIndex)
    );
  }
  getLengthOfInsertionDelimiter() {
    if (this.editor.document.eol === "CRLF") {
      const matches = this.insertionDelimiter.match(/\n/g);
      if (matches != null) {
        return this.insertionDelimiter.length + matches.length;
      }
    }
    return this.insertionDelimiter.length;
  }
};
function getIndentationString(editor, range4) {
  let length = Number.MAX_SAFE_INTEGER;
  let indentationString = "";
  for (let i = range4.start.line; i <= range4.end.line; ++i) {
    const line = editor.document.lineAt(i);
    if (!line.isEmptyOrWhitespace && line.firstNonWhitespaceCharacterIndex < length) {
      length = line.firstNonWhitespaceCharacterIndex;
      indentationString = line.text.slice(0, length);
    }
  }
  return indentationString;
}
function getContentRange(contentRange, insertionMode) {
  switch (insertionMode) {
    case "before":
      return contentRange.start.toEmptyRange();
    case "after":
      return contentRange.end.toEmptyRange();
    case "to":
      return contentRange;
  }
}

// ../cursorless-engine/src/processTargets/targets/util/createContinuousRange.ts
function createContinuousRange(startTarget, endTarget, includeStart, includeEnd) {
  return createContinuousRangeFromRanges(
    startTarget.contentRange,
    endTarget.contentRange,
    includeStart,
    includeEnd
  );
}
function createContinuousRangeFromRanges(startRange, endRange, includeStart, includeEnd) {
  return new Range(
    includeStart ? startRange.start : startRange.end,
    includeEnd ? endRange.end : endRange.start
  );
}
function createContinuousLineRange(startTarget, endTarget, includeStart, includeEnd) {
  const start = includeStart ? startTarget.contentRange.start : new Position(startTarget.contentRange.end.line + 1, 0);
  const end = includeEnd ? endTarget.contentRange.end : endTarget.editor.document.lineAt(endTarget.contentRange.start.line - 1).range.end;
  return new Range(start, end);
}

// ../cursorless-engine/src/processTargets/targets/BaseTarget.ts
var BaseTarget = class _BaseTarget {
  constructor(parameters) {
    this.isLine = false;
    this.isToken = true;
    this.hasExplicitScopeType = true;
    this.hasExplicitRange = true;
    this.isRaw = false;
    this.isImplicit = false;
    this.isNotebookCell = false;
    this.isWord = false;
    this.state = {
      editor: parameters.editor,
      isReversed: parameters.isReversed,
      contentRange: parameters.contentRange,
      thatTarget: parameters.thatTarget
    };
  }
  get editor() {
    return this.state.editor;
  }
  get isReversed() {
    return this.state.isReversed;
  }
  get thatTarget() {
    return this.state.thatTarget != null ? this.state.thatTarget.thatTarget : this;
  }
  get contentText() {
    return this.editor.document.getText(this.contentRange);
  }
  get contentSelection() {
    return this.contentRange.toSelection(this.isReversed);
  }
  get contentRange() {
    return this.state.contentRange;
  }
  constructRemovalEdit() {
    return {
      range: this.getRemovalRange(),
      text: "",
      updateRange: (range4) => range4
    };
  }
  getRemovalHighlightRange() {
    return this.getRemovalRange();
  }
  withThatTarget(thatTarget) {
    return this.cloneWith({ thatTarget });
  }
  withContentRange(contentRange) {
    return this.cloneWith({ contentRange });
  }
  getInteriorStrict() {
    throw new NoContainingScopeError("interior");
  }
  getBoundaryStrict() {
    throw new NoContainingScopeError("boundary");
  }
  cloneWith(parameters) {
    const constructor = Object.getPrototypeOf(this).constructor;
    return new constructor({
      ...this.getCloneParameters(),
      ...parameters
    });
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    const { constructor } = Object.getPrototypeOf(this);
    return new constructor({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousRange(this, endTarget, true, true)
    });
  }
  isEqual(otherTarget) {
    return otherTarget instanceof _BaseTarget && (0, import_lodash9.isEqual)(this.getEqualityParameters(), otherTarget.getEqualityParameters());
  }
  /**
   * Constructs an object that can be used for determining equality between two
   * {@link BaseTarget} objects. We proceed by just getting the objects clone
   * parameters and removing the `thatTarget`.
   *
   * We would prefer to instead merge the `thatTarget`s into a list. See #780
   * for more details.
   *
   * @returns The object to be used for determining equality
   */
  getEqualityParameters() {
    const { thatTarget, ...otherCloneParameters } = this.getCloneParameters();
    return {
      ...otherCloneParameters
    };
  }
  toDestination(insertionMode) {
    return new DestinationImpl(this, insertionMode);
  }
  /**
   * Converts the target to a plain object representation.
   *
   * Note that this implementation is quite incomplete, but is suitable for
   * round-tripping {@link UntypedTarget} objects and capturing the fact that an
   * object is not an un typed target if it is not, via the {@link type}
   * attribute.  In the future, we should override this method in subclasses to
   * provide a more complete representation.
   * @returns A plain object representation of the target
   */
  toPlainObject() {
    return {
      type: this.type,
      contentRange: rangeToPlainObject(this.contentRange),
      isReversed: this.isReversed,
      hasExplicitRange: this.hasExplicitRange
    };
  }
};

// ../cursorless-engine/src/util/selectionUtils.ts
function selectionWithEditorFromRange(selection, range4) {
  return selectionWithEditorFromPositions(selection, range4.start, range4.end);
}
function selectionWithEditorFromPositions(selection, start, end) {
  return {
    editor: selection.editor,
    selection: selectionFromPositions(selection.selection, start, end)
  };
}
function selectionFromPositions(selection, start, end) {
  return !selection.isReversed ? new Selection(start, end) : new Selection(end, start);
}
function shrinkRangeToFitContent(editor, range4) {
  const { document } = editor;
  const text = document.getText(range4);
  const startDelta = text.length - text.trimStart().length;
  const endDelta = text.length - text.trimEnd().length;
  const startOffset = document.offsetAt(range4.start) + startDelta;
  const endOffset = document.offsetAt(range4.end) - endDelta;
  const start = document.positionAt(startOffset);
  const end = document.positionAt(endOffset);
  return new Range(start, end);
}

// ../cursorless-engine/src/util/tryConstructTarget.ts
function tryConstructTarget(constructor, editor, range4, isReversed) {
  return range4 == null ? void 0 : new constructor({
    editor,
    isReversed,
    contentRange: range4
  });
}

// ../cursorless-engine/src/processTargets/targets/PlainTarget.ts
var PlainTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "PlainTarget";
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
    this.isToken = parameters.isToken ?? true;
    this.insertionDelimiter = parameters.insertionDelimiter ?? "";
  }
  getCloneParameters() {
    return {
      ...this.state,
      isToken: this.isToken,
      insertionDelimiter: this.insertionDelimiter
    };
  }
};
function tryConstructPlainTarget(editor, range4, isReversed) {
  return tryConstructTarget(PlainTarget, editor, range4, isReversed);
}

// ../cursorless-engine/src/processTargets/targets/DocumentTarget.ts
var DocumentTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "DocumentTarget";
    this.insertionDelimiter = "\n";
    this.isLine = true;
  }
  getLeadingDelimiterTarget() {
    return void 0;
  }
  getTrailingDelimiterTarget() {
    return void 0;
  }
  getRemovalRange() {
    return this.contentRange;
  }
  getInteriorStrict() {
    return [
      // Use plain target instead of interior target since we want the same content and removal range for a document interior.
      new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: shrinkRangeToFitContent(this.editor, this.contentRange)
      })
    ];
  }
  getCloneParameters() {
    return this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/LineTarget.ts
var LineTarget = class _LineTarget extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "LineTarget";
    this.insertionDelimiter = "\n";
    this.isLine = true;
    this.getRemovalHighlightRange = () => this.fullLineContentRange;
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getLeadingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      getLeadingDelimiterRange(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      getTrailingDelimiterRange(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getRemovalRange() {
    const contentRemovalRange = this.fullLineContentRange;
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    return delimiterTarget == null ? contentRemovalRange : contentRemovalRange.union(delimiterTarget.contentRange);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _LineTarget({
      editor: this.editor,
      isReversed,
      contentRange: createContinuousLineRange(this, endTarget, true, true)
    });
  }
  getCloneParameters() {
    return this.state;
  }
};
function getLeadingDelimiterRange(editor, range4) {
  const { start } = range4;
  return start.line > 0 ? new Range(editor.document.lineAt(start.line - 1).range.end, range4.start) : void 0;
}
function getTrailingDelimiterRange(editor, range4) {
  const { end } = range4;
  return end.line + 1 < editor.document.lineCount ? new Range(range4.end, new Position(end.line + 1, 0)) : void 0;
}
function constructLineTarget(editor, range4, isReversed) {
  return tryConstructTarget(LineTarget, editor, range4, isReversed);
}

// ../cursorless-engine/src/processTargets/targets/NotebookCellDestination.ts
var NotebookCellDestination = class _NotebookCellDestination {
  constructor(target, insertionMode) {
    this.target = target;
    this.insertionMode = insertionMode;
  }
  get editor() {
    return this.target.editor;
  }
  get contentRange() {
    return this.target.contentRange;
  }
  get contentSelection() {
    return this.target.contentSelection;
  }
  get insertionDelimiter() {
    return this.target.insertionDelimiter;
  }
  get isRaw() {
    return this.target.isRaw;
  }
  withTarget(target) {
    return new _NotebookCellDestination(target, this.insertionMode);
  }
  getEditNewActionType() {
    throw new Error("Method not implemented.");
  }
  constructChangeEdit(_text) {
    throw new Error("Method not implemented.");
  }
};

// ../cursorless-engine/src/processTargets/targets/NotebookCellTarget.ts
var NotebookCellTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "NotebookCellTarget";
    this.insertionDelimiter = "\n";
    this.isNotebookCell = true;
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
  }
  getCloneParameters() {
    return this.state;
  }
  toDestination(insertionMode) {
    return new NotebookCellDestination(this, insertionMode);
  }
};

// ../cursorless-engine/src/processTargets/targets/ParagraphTarget.ts
var ParagraphTarget = class _ParagraphTarget extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "ParagraphTarget";
    this.insertionDelimiter = "\n\n";
    this.isLine = true;
  }
  getLeadingDelimiterTarget() {
    return constructLineTarget(
      this.editor,
      getLeadingDelimiterRange2(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return constructLineTarget(
      this.editor,
      getTrailingDelimiterRange2(this.editor, this.fullLineContentRange),
      this.isReversed
    );
  }
  getRemovalRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    const removalContentRange = delimiterTarget != null ? this.contentRange.union(delimiterTarget.contentRange) : this.contentRange;
    return new LineTarget({
      contentRange: removalContentRange,
      editor: this.editor,
      isReversed: this.isReversed
    }).getRemovalRange();
  }
  get fullLineContentRange() {
    return expandToFullLine(this.editor, this.contentRange);
  }
  getRemovalHighlightRange() {
    const delimiterTarget = this.getTrailingDelimiterTarget() ?? this.getLeadingDelimiterTarget();
    return delimiterTarget != null ? this.fullLineContentRange.union(delimiterTarget.contentRange) : this.fullLineContentRange;
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _ParagraphTarget({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousLineRange(this, endTarget, true, true)
    });
  }
  getCloneParameters() {
    return this.state;
  }
};
function getLeadingDelimiterRange2(editor, contentRange) {
  const { document } = editor;
  const startLine = document.lineAt(contentRange.start);
  const leadingLine = getPreviousNonEmptyLine(document, startLine);
  if (leadingLine != null) {
    if (leadingLine.lineNumber + 1 === startLine.lineNumber) {
      return void 0;
    }
    return new Range(
      new Position(leadingLine.lineNumber + 1, 0),
      document.lineAt(startLine.lineNumber - 1).range.end
    );
  }
  if (startLine.lineNumber > 0) {
    return new Range(
      new Position(0, 0),
      document.lineAt(startLine.lineNumber - 1).range.end
    );
  }
  return void 0;
}
function getTrailingDelimiterRange2(editor, contentRange) {
  const { document } = editor;
  const endLine = document.lineAt(contentRange.end);
  const trailingLine = getNextNonEmptyLine(document, endLine);
  if (trailingLine != null) {
    if (trailingLine.lineNumber - 1 === endLine.lineNumber) {
      return void 0;
    }
    return new Range(
      new Position(endLine.lineNumber + 1, 0),
      document.lineAt(trailingLine.lineNumber - 1).range.end
    );
  }
  if (endLine.lineNumber < document.lineCount - 1) {
    return new Range(
      new Position(endLine.lineNumber + 1, 0),
      document.lineAt(document.lineCount - 1).range.end
    );
  }
  return void 0;
}
function getPreviousNonEmptyLine(document, line) {
  while (line.lineNumber > 0) {
    const previousLine = document.lineAt(line.lineNumber - 1);
    if (!previousLine.isEmptyOrWhitespace) {
      return previousLine;
    }
    line = previousLine;
  }
  return null;
}
function getNextNonEmptyLine(document, line) {
  while (line.lineNumber + 1 < document.lineCount) {
    const nextLine = document.lineAt(line.lineNumber + 1);
    if (!nextLine.isEmptyOrWhitespace) {
      return nextLine;
    }
    line = nextLine;
  }
  return null;
}

// ../cursorless-engine/src/processTargets/targets/RawSelectionTarget.ts
var RawSelectionTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "RawSelectionTarget";
    this.insertionDelimiter = "";
    this.isRaw = true;
    this.isToken = false;
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
    this.getCloneParameters = () => this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/InteriorTarget.ts
var InteriorTarget = class _InteriorTarget extends BaseTarget {
  constructor(parameters) {
    super({
      ...parameters,
      contentRange: shrinkRangeToFitContent(
        parameters.editor,
        parameters.fullInteriorRange
      )
    });
    this.type = "InteriorTarget";
    this.insertionDelimiter = " ";
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.fullInteriorRange;
    this.fullInteriorRange = parameters.fullInteriorRange;
  }
  getCloneParameters() {
    return {
      ...this.state,
      fullInteriorRange: this.fullInteriorRange
    };
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _InteriorTarget({
      ...this.getCloneParameters(),
      isReversed,
      fullInteriorRange: createContinuousRangeFromRanges(
        this.fullInteriorRange,
        endTarget.fullInteriorRange,
        true,
        true
      )
    });
  }
};

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/DelimitedSequenceInsertionRemovalBehavior.ts
function getDelimitedSequenceRemovalRange(target) {
  const contentRange = union(target.contentRange, target.prefixRange);
  const delimiterTarget = target.getTrailingDelimiterTarget() ?? target.getLeadingDelimiterTarget();
  return delimiterTarget != null ? contentRange.union(delimiterTarget.contentRange) : contentRange;
}

// ../cursorless-engine/src/processTargets/targets/util/insertionRemovalBehaviors/TokenInsertionRemovalBehavior.ts
var leadingDelimiters = ['"', "'", "(", "[", "{", "<"];
var trailingDelimiters = ['"', "'", ")", "]", "}", ">", ",", ";", ":"];
function getTokenLeadingDelimiterTarget(target) {
  const { editor } = target;
  const { start } = union(target.contentRange, target.prefixRange);
  const startLine = editor.document.lineAt(start);
  const leadingText = startLine.text.slice(0, start.character);
  const leadingDelimiters2 = leadingText.match(/\s+$/);
  return leadingDelimiters2 == null ? void 0 : new PlainTarget({
    contentRange: new Range(
      start.line,
      start.character - leadingDelimiters2[0].length,
      start.line,
      start.character
    ),
    editor,
    isReversed: target.isReversed
  });
}
function getTokenTrailingDelimiterTarget(target) {
  const { editor } = target;
  const { end } = target.contentRange;
  const endLine = editor.document.lineAt(end);
  const trailingText = endLine.text.slice(end.character);
  const trailingDelimiters2 = trailingText.match(/^\s+/);
  return trailingDelimiters2 == null ? void 0 : new PlainTarget({
    contentRange: new Range(
      end.line,
      end.character,
      end.line,
      end.character + trailingDelimiters2[0].length
    ),
    editor,
    isReversed: target.isReversed
  });
}
function getTokenRemovalRange(target) {
  const { editor } = target;
  const contentRange = union(target.contentRange, target.prefixRange);
  const { start, end } = contentRange;
  const leadingWhitespaceRange = target.getLeadingDelimiterTarget()?.contentRange ?? start.toEmptyRange();
  const trailingWhitespaceRange = target.getTrailingDelimiterTarget()?.contentRange ?? end.toEmptyRange();
  const fullLineRange = expandToFullLine(editor, contentRange);
  if (leadingWhitespaceRange.union(trailingWhitespaceRange).isRangeEqual(fullLineRange)) {
    return fullLineRange;
  }
  if (!trailingWhitespaceRange.isEmpty) {
    if (!leadingWhitespaceRange.isEmpty || contentRange.start.isEqual(fullLineRange.start) || leadingDelimiters.includes(getLeadingCharacter(editor, contentRange))) {
      return contentRange.union(trailingWhitespaceRange);
    }
  }
  if (!leadingWhitespaceRange.isEmpty) {
    if (contentRange.end.isEqual(fullLineRange.end) || trailingDelimiters.includes(getTrailingCharacter(editor, contentRange))) {
      return contentRange.union(leadingWhitespaceRange);
    }
  }
  return contentRange;
}
function getLeadingCharacter(editor, contentRange) {
  const { start } = contentRange;
  const line = editor.document.lineAt(start);
  return start.isAfter(line.range.start) ? editor.document.getText(new Range(start.translate(void 0, -1), start)) : "";
}
function getTrailingCharacter(editor, contentRange) {
  const { end } = contentRange;
  const line = editor.document.lineAt(end);
  return end.isBefore(line.range.end) ? editor.document.getText(new Range(end.translate(void 0, 1), end)) : "";
}

// ../cursorless-engine/src/processTargets/targets/ScopeTypeTarget.ts
var ScopeTypeTarget = class _ScopeTypeTarget extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "ScopeTypeTarget";
    this.scopeTypeType_ = parameters.scopeTypeType;
    this.removalRange_ = parameters.removalRange;
    this.interiorRange_ = parameters.interiorRange;
    this.leadingDelimiterRange_ = parameters.leadingDelimiterRange;
    this.trailingDelimiterRange_ = parameters.trailingDelimiterRange;
    this.prefixRange = parameters.prefixRange;
    this.insertionDelimiter = parameters.insertionDelimiter ?? getInsertionDelimiter(parameters.scopeTypeType);
    this.hasDelimiterRange_ = !!this.leadingDelimiterRange_ || !!this.trailingDelimiterRange_;
  }
  getLeadingDelimiterTarget() {
    if (this.leadingDelimiterRange_ != null) {
      return new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: this.leadingDelimiterRange_
      });
    }
    if (!this.hasDelimiterRange_) {
      return getTokenLeadingDelimiterTarget(this);
    }
    return void 0;
  }
  getTrailingDelimiterTarget() {
    if (this.trailingDelimiterRange_ != null) {
      return new PlainTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange: this.trailingDelimiterRange_
      });
    }
    if (!this.hasDelimiterRange_) {
      return getTokenTrailingDelimiterTarget(this);
    }
    return void 0;
  }
  getInteriorStrict() {
    if (this.interiorRange_ == null) {
      return super.getInteriorStrict();
    }
    return [
      new InteriorTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        fullInteriorRange: this.interiorRange_
      })
    ];
  }
  getRemovalRange() {
    return this.removalRange_ != null ? this.removalRange_ : this.hasDelimiterRange_ ? getDelimitedSequenceRemovalRange(this) : getTokenRemovalRange(this);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    if (this.scopeTypeType_ !== endTarget.scopeTypeType_) {
      return null;
    }
    const contentRemovalRange = this.removalRange_ != null || endTarget.removalRange_ != null ? createContinuousRangeFromRanges(
      this.removalRange_ ?? this.contentRange,
      endTarget.removalRange_ ?? endTarget.contentRange,
      true,
      true
    ) : void 0;
    return new _ScopeTypeTarget({
      ...this.getCloneParameters(),
      isReversed,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: endTarget.trailingDelimiterRange_,
      removalRange: contentRemovalRange,
      contentRange: createContinuousRange(this, endTarget, true, true)
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      insertionDelimiter: this.insertionDelimiter,
      prefixRange: this.prefixRange,
      removalRange: void 0,
      interiorRange: void 0,
      scopeTypeType: this.scopeTypeType_,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: this.trailingDelimiterRange_
    };
  }
};
function getInsertionDelimiter(scopeType) {
  switch (scopeType) {
    case "class":
    case "namedFunction":
    case "section":
    case "sectionLevelOne":
    case "sectionLevelTwo":
    case "sectionLevelThree":
    case "sectionLevelFour":
    case "sectionLevelFive":
    case "sectionLevelSix":
    case "part":
    case "chapter":
    case "subSection":
    case "subSubSection":
    case "namedParagraph":
    case "subParagraph":
      return "\n\n";
    case "anonymousFunction":
    case "statement":
    case "ifStatement":
    case "comment":
    case "xmlElement":
    case "collectionItem":
    case "branch":
    case "environment":
      return "\n";
    default:
      return " ";
  }
}

// ../cursorless-engine/src/processTargets/targets/SubTokenWordTarget.ts
var SubTokenWordTarget = class _SubTokenWordTarget extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "SubTokenWordTarget";
    this.isToken = false;
    this.isWord = true;
    this.leadingDelimiterRange_ = parameters.leadingDelimiterRange;
    this.trailingDelimiterRange_ = parameters.trailingDelimiterRange;
    this.insertionDelimiter = parameters.insertionDelimiter;
  }
  getLeadingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      this.leadingDelimiterRange_,
      this.isReversed
    );
  }
  getTrailingDelimiterTarget() {
    return tryConstructPlainTarget(
      this.editor,
      this.trailingDelimiterRange_,
      this.isReversed
    );
  }
  getRemovalRange() {
    return getDelimitedSequenceRemovalRange(this);
  }
  maybeCreateRichRangeTarget(isReversed, endTarget) {
    return new _SubTokenWordTarget({
      ...this.getCloneParameters(),
      isReversed,
      contentRange: createContinuousRange(this, endTarget, true, true),
      trailingDelimiterRange: endTarget.trailingDelimiterRange_
    });
  }
  getCloneParameters() {
    return {
      ...this.state,
      leadingDelimiterRange: this.leadingDelimiterRange_,
      trailingDelimiterRange: this.trailingDelimiterRange_,
      insertionDelimiter: this.insertionDelimiter
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/TokenTarget.ts
var TokenTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "TokenTarget";
    this.insertionDelimiter = " ";
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getCloneParameters() {
    return this.state;
  }
};

// ../cursorless-engine/src/processTargets/targets/SurroundingPairTarget.ts
var SurroundingPairTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "SurroundingPairTarget";
    this.insertionDelimiter = " ";
    this.boundary_ = parameters.boundary;
    this.interiorRange_ = parameters.interiorRange;
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return getTokenRemovalRange(this);
  }
  getInteriorStrict() {
    return [
      new InteriorTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        fullInteriorRange: this.interiorRange_
      })
    ];
  }
  getBoundaryStrict() {
    return this.boundary_.map(
      (contentRange) => new TokenTarget({
        editor: this.editor,
        isReversed: this.isReversed,
        contentRange
      })
    );
  }
  getCloneParameters() {
    return {
      ...this.state,
      interiorRange: this.interiorRange_,
      boundary: this.boundary_
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/UntypedTarget.ts
var UntypedTarget = class extends BaseTarget {
  constructor(parameters) {
    super(parameters);
    this.type = "UntypedTarget";
    this.insertionDelimiter = " ";
    this.hasExplicitScopeType = false;
    this.hasExplicitRange = parameters.hasExplicitRange;
    this.isToken = parameters.isToken ?? true;
  }
  getLeadingDelimiterTarget() {
    return getTokenLeadingDelimiterTarget(this);
  }
  getTrailingDelimiterTarget() {
    return getTokenTrailingDelimiterTarget(this);
  }
  getRemovalRange() {
    return this.editor.document.getText(this.contentRange).trim().length === 0 ? this.contentRange : getTokenRemovalRange(this);
  }
  maybeCreateRichRangeTarget() {
    return null;
  }
  getCloneParameters() {
    return {
      ...this.state,
      isToken: this.isToken,
      hasExplicitRange: this.hasExplicitRange
    };
  }
};

// ../cursorless-engine/src/processTargets/targets/ImplicitTarget.ts
var ImplicitTarget = class extends BaseTarget {
  constructor() {
    super(...arguments);
    this.type = "ImplicitTarget";
    this.insertionDelimiter = "";
    this.isRaw = true;
    this.hasExplicitScopeType = false;
    this.isImplicit = true;
    this.isToken = false;
    this.getLeadingDelimiterTarget = () => void 0;
    this.getTrailingDelimiterTarget = () => void 0;
    this.getRemovalRange = () => this.contentRange;
    this.getCloneParameters = () => this.state;
  }
};

// ../cursorless-engine/src/testUtil/plainObjectToTarget.ts
function plainObjectToTarget(editor, plainObject) {
  switch (plainObject.type) {
    case "UntypedTarget":
      return new UntypedTarget({
        editor,
        isReversed: plainObject.isReversed,
        contentRange: plainObjectToRange(plainObject.contentRange),
        hasExplicitRange: plainObject.hasExplicitRange
      });
    case "LineTarget":
      return new LineTarget({
        editor,
        isReversed: plainObject.isReversed,
        contentRange: plainObjectToRange(plainObject.contentRange)
      });
    default:
      throw Error(`Unsupported target type ${plainObject.type}`);
  }
}

// ../cursorless-engine/src/core/Cheatsheet.ts
var import_lodash10 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/singletons/ide.singleton.ts
var ide_;
function injectIde(ide2) {
  ide_ = ide2;
}
function ide() {
  if (ide_ == null) {
    throw Error("Tried to access ide before it was injected");
  }
  return ide_;
}

// ../../node_modules/.pnpm/immer@10.0.4/node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (process.env.NODE_ENV !== "production") {
    const e = errors[error];
    const msg = typeof e === "function" ? e.apply(null, args) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter2) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter2(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry2, index) => iter2(index, entry2, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set2(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  if (!strict && isPlainObject2(base)) {
    if (!getPrototypeOf(base)) {
      const obj = /* @__PURE__ */ Object.create(null);
      return Object.assign(obj, base);
    }
    return { ...base };
  }
  const descriptors = Object.getOwnPropertyDescriptors(base);
  delete descriptors[DRAFT_STATE];
  let keys = Reflect.ownKeys(descriptors);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const desc = descriptors[key];
    if (desc.writable === false) {
      desc.writable = true;
      desc.configurable = true;
    }
    if (desc.get || desc.set)
      descriptors[key] = {
        configurable: true,
        writable: true,
        // could live with !!desc.set as well here...
        enumerable: desc.enumerable,
        value: base[key]
      };
  }
  return Object.create(getPrototypeOf(base), descriptors);
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path8) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path8)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path8, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path8 && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path8,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (process.env.NODE_ENV !== "production" && childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path8 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path8);
    set2(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set2(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(
  immer
);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);

// ../cursorless-engine/src/testUtil/takeSnapshot.ts
async function takeSnapshot(storedTargets, excludeFields = [], extraFields = [], editor, ide2, marks2, extraContext, metadata, clipboard) {
  const snapshot = {
    documentContents: editor.document.getText(),
    selections: editor.selections.map(selectionToPlainObject)
  };
  if (marks2 != null) {
    snapshot.marks = marks2;
  }
  if (metadata != null) {
    snapshot.metadata = metadata;
  }
  if (!excludeFields.includes("clipboard")) {
    snapshot.clipboard = await (clipboard ?? ide2.clipboard).readText();
  }
  if (!excludeFields.includes("visibleRanges")) {
    snapshot.visibleRanges = editor.visibleRanges.map(rangeToPlainObject);
  }
  for (const storedTargetKey of storedTargetKeys) {
    const targets = storedTargets?.get(storedTargetKey);
    const key = `${storedTargetKey}Mark`;
    if (targets != null && !excludeFields.includes(key)) {
      snapshot[key] = targets.map((target) => target.toPlainObject());
    }
  }
  if (extraFields.includes("timeOffsetSeconds")) {
    const startTimestamp = extraContext?.startTimestamp;
    if (startTimestamp == null) {
      throw new Error(
        "No start timestamp provided but time offset was requested"
      );
    }
    const offsetNanoseconds = process.hrtime.bigint() - startTimestamp;
    snapshot.timeOffsetSeconds = hrtimeBigintToSeconds(offsetNanoseconds);
  }
  return snapshot;
}

// ../cursorless-engine/src/testCaseRecorder/TestCaseRecorder.ts
var import_immutability_helper = __toESM(require_immutability_helper(), 1);
var import_lodash12 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/generateSpokenForm/NoSpokenFormError.ts
var NoSpokenFormError = class extends Error {
  constructor(reason, requiresTalonUpdate = false, isPrivate2 = false) {
    super(`No spoken form for: ${reason}`);
    this.reason = reason;
    this.requiresTalonUpdate = requiresTalonUpdate;
    this.isPrivate = isPrivate2;
  }
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/actions.ts
var actions = {
  breakLine: "break",
  scrollToBottom: "bottom",
  toggleLineBreakpoint: "break point",
  cutToClipboard: "carve",
  scrollToCenter: "center",
  clearAndSetSelection: "change",
  remove: "chuck",
  insertCopyBefore: "clone up",
  insertCopyAfter: "clone",
  toggleLineComment: "comment",
  copyToClipboard: "copy",
  scrollToTop: "crown",
  outdentLine: "dedent",
  revealDefinition: "define",
  editNewLineBefore: "drink",
  insertEmptyLineBefore: "drop",
  extractVariable: "extract",
  insertEmptyLineAfter: "float",
  foldRegion: "fold",
  followLink: "follow",
  deselect: "give",
  highlight: "highlight",
  showHover: "hover",
  increment: "increment",
  decrement: "decrement",
  indentLine: "indent",
  showDebugHover: "inspect",
  setSelectionAfter: "post",
  editNewLineAfter: "pour",
  setSelectionBefore: "pre",
  insertEmptyLinesAround: "puff",
  showQuickFix: "quick fix",
  showReferences: "reference",
  rename: "rename",
  reverseTargets: "reverse",
  findInDocument: "scout",
  findInWorkspace: "scout all",
  randomizeTargets: "shuffle",
  generateSnippet: "snippet make",
  sortTargets: "sort",
  setSelection: "take",
  revealTypeDefinition: "type deaf",
  unfoldRegion: "unfold",
  callAsFunction: "call",
  swapTargets: "swap",
  replaceWithTarget: "bring",
  moveToTarget: "move",
  wrapWithPairedDelimiter: "wrap",
  wrapWithSnippet: "wrap",
  rewrapWithPairedDelimiter: "repack",
  insertSnippet: "snippet",
  pasteFromClipboard: "paste",
  joinLines: "join",
  ["private.showParseTree"]: "parse tree",
  ["experimental.setInstanceReference"]: "from",
  editNew: null,
  executeCommand: null,
  getText: null,
  replace: null,
  ["private.getTargets"]: null,
  ["private.setKeyboardTarget"]: null
  // These actions are implemented talon-side, usually using `getText` followed
  // by some other action.
  // applyFormatter: "format",
  // nextHomophone: "phones",
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/connectives.ts
var connectives = {
  rangeExclusive: "between",
  rangeInclusive: "past",
  // Note: rangeExcludingStart has no default spoken form
  rangeExcludingStart: null,
  rangeExcludingEnd: "until",
  listConnective: "and",
  swapConnective: "with",
  sourceDestinationConnective: "to",
  before: "before",
  after: "after",
  verticalRange: "slice",
  previous: "previous",
  next: "next",
  forward: "forward",
  backward: "backward"
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/surroundingPairsDelimiters.ts
var surroundingPairsDelimiters = {
  curlyBrackets: ["{", "}"],
  angleBrackets: ["<", ">"],
  escapedDoubleQuotes: ['\\"', '\\"'],
  escapedSingleQuotes: ["\\'", "\\'"],
  escapedParentheses: ["\\(", "\\)"],
  escapedSquareBrackets: ["\\[", "\\]"],
  doubleQuotes: ['"', '"'],
  parentheses: ["(", ")"],
  backtickQuotes: ["`", "`"],
  squareBrackets: ["[", "]"],
  singleQuotes: ["'", "'"],
  whitespace: [" ", " "],
  any: null,
  string: null,
  collectionBoundary: null
};

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/modifiers.ts
var surroundingPairDelimiterToName = new CompositeKeyMap((pair) => pair);
for (const [name, pair] of Object.entries(surroundingPairsDelimiters)) {
  if (pair != null) {
    surroundingPairDelimiterToName.set(
      pair,
      name
    );
  }
}
function surroundingPairDelimitersToSpokenForm(spokenFormMap, left, right) {
  const pairName = surroundingPairDelimiterToName.get([left, right]);
  if (pairName == null) {
    throw Error(`Unknown surrounding pair delimiters '${left} ${right}'`);
  }
  return spokenFormMap.pairedDelimiter[pairName];
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/snippets.ts
var insertionSnippets = {
  ifStatement: "if",
  ifElseStatement: "if else",
  tryCatchStatement: "try",
  functionDeclaration: "funk",
  link: "link"
};
var wrapperSnippets = {
  "ifElseStatement.alternative": "else",
  "functionDeclaration.body": "funk",
  "ifElseStatement.consequence": "if else",
  "ifStatement.consequence": "if",
  "tryCatchStatement.body": "try",
  "link.text": "link"
};
function insertionSnippetToSpokenForm(snippetDescription) {
  if (snippetDescription.type === "custom") {
    throw new NoSpokenFormError("Custom insertion snippet");
  }
  const result = insertionSnippets[snippetDescription.name];
  if (result == null) {
    throw new NoSpokenFormError(
      `Named insertion snippet '${snippetDescription.name}'`
    );
  }
  if (snippetDescription.substitutions != null) {
    const values2 = Object.values(snippetDescription.substitutions);
    return `${result} ${values2.join(" ")}`;
  }
  return result;
}
function wrapperSnippetToSpokenForm(snippetDescription) {
  if (snippetDescription.type === "custom") {
    throw new NoSpokenFormError("Custom wrap with snippet");
  }
  const name = `${snippetDescription.name}.${snippetDescription.variableName}`;
  const result = wrapperSnippets[name];
  if (result == null) {
    throw new NoSpokenFormError(`Named wrap with snippet '${name}'`);
  }
  return result;
}

// ../cursorless-engine/src/generateSpokenForm/getRangeConnective.ts
function getRangeConnective(excludeAnchor, excludeActive, type2) {
  const prefix = type2 === "vertical" ? `${connectives.verticalRange} ` : "";
  if (excludeAnchor && excludeActive) {
    return prefix + connectives.rangeExclusive;
  }
  if (excludeAnchor) {
    throw new NoSpokenFormError("Range exclude anchor");
  }
  if (excludeActive) {
    return prefix + connectives.rangeExcludingEnd;
  }
  if (type2 === "vertical") {
    return connectives.verticalRange;
  }
  return connectives.rangeInclusive;
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/marks.ts
var hatColors = {
  blue: "blue",
  green: "green",
  red: "red",
  pink: "pink",
  yellow: "yellow",
  userColor1: "navy",
  userColor2: "apricot",
  default: null
};
var hatShapes = {
  ex: "ex",
  fox: "fox",
  wing: "wing",
  hole: "hole",
  frame: "frame",
  curve: "curve",
  eye: "eye",
  play: "play",
  crosshairs: "cross",
  bolt: "bolt",
  default: null
};
var marks = {
  cursor: "this",
  that: "that",
  source: "source",
  nothing: "nothing",
  keyboard: null,
  explicit: null,
  decoratedSymbol: null,
  lineNumber: null,
  range: null
};
var lineDirections = {
  modulo100: "row",
  relativeUp: "up",
  relativeDown: "down"
};
function hatColorToSpokenForm(color) {
  const result = hatColors[color];
  if (result == null) {
    throw Error(`Unknown hat color '${color}'`);
  }
  return result;
}
function hatShapeToSpokenForm(shape) {
  const result = hatShapes[shape];
  if (result == null) {
    throw Error(`Unknown hat shape '${shape}'`);
  }
  return result;
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/numbers.ts
var numbers = [
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen",
  "twenty",
  "twenty one",
  "twenty two",
  "twenty three",
  "twenty four",
  "twenty five",
  "twenty six",
  "twenty seven",
  "twenty eight",
  "twenty nine",
  "thirty",
  "thirty one",
  "thirty two",
  "thirty three",
  "thirty four",
  "thirty five",
  "thirty six",
  "thirty seven",
  "thirty eight",
  "thirty nine",
  "forty",
  "forty one",
  "forty two",
  "forty three",
  "forty four",
  "forty five",
  "forty six",
  "forty seven",
  "forty eight",
  "forty nine",
  "fifty",
  "fifty one",
  "fifty two",
  "fifty three",
  "fifty four",
  "fifty five",
  "fifty six",
  "fifty seven",
  "fifty eight",
  "fifty nine",
  "sixty",
  "sixty one",
  "sixty two",
  "sixty three",
  "sixty four",
  "sixty five",
  "sixty six",
  "sixty seven",
  "sixty eight",
  "sixty nine",
  "seventy",
  "seventy one",
  "seventy two",
  "seventy three",
  "seventy four",
  "seventy five",
  "seventy six",
  "seventy seven",
  "seventy eight",
  "seventy nine",
  "eighty",
  "eighty one",
  "eighty two",
  "eighty three",
  "eighty four",
  "eighty five",
  "eighty six",
  "eighty seven",
  "eighty eight",
  "eighty nine",
  "ninety",
  "ninety one",
  "ninety two",
  "ninety three",
  "ninety four",
  "ninety five",
  "ninety six",
  "ninety seven",
  "ninety eight",
  "ninety nine"
];
var ordinals = [
  "zeroth",
  "first",
  "second",
  "third",
  "fourth",
  "fifth",
  "sixth",
  "seventh",
  "eighth",
  "ninth",
  "tenth",
  "eleventh",
  "twelfth",
  "thirteenth",
  "fourteenth",
  "fifteenth",
  "sixteenth",
  "seventeenth",
  "eighteenth",
  "nineteenth",
  "twentieth"
];
function numberToSpokenForm(number) {
  const result = numbers[number];
  if (result == null) {
    throw Error(`Unknown number '${number}'`);
  }
  return result;
}
function ordinalToSpokenForm(ordinal) {
  const result = ordinals[ordinal];
  if (result == null) {
    throw Error(`Unknown ordinal '${ordinal}'`);
  }
  return result;
}

// ../cursorless-engine/src/generateSpokenForm/defaultSpokenForms/characters.ts
var alphabet = Object.fromEntries(
  "air bat cap drum each fine gust harp sit jury crunch look made near odd pit quench red sun trap urge vest whale plex yank zip".split(" ").map((word, index) => [
    String.fromCharCode("a".charCodeAt(0) + index),
    word
  ])
);
var digits = Object.fromEntries(
  "zero one two three four five six seven eight nine".split(" ").map((word, index) => [index.toString(), word])
);
var symbols = {
  ".": "dot",
  ",": "comma",
  ";": "semicolon",
  ":": "colon",
  "!": "bang",
  "*": "asterisk",
  "@": "at sign",
  "&": "ampersand",
  "?": "question",
  "/": "slash",
  "\\": "backslash",
  "-": "dash",
  "=": "equals",
  "+": "plus",
  "~": "tilde",
  _: "underscore",
  "#": "hash",
  "%": "percent",
  "^": "caret",
  "|": "pipe",
  $: "dollar",
  "\xA3": "pound",
  "'": "quote",
  '"': "double quote",
  "`": "back tick",
  "(": "paren",
  ")": "right paren",
  "{": "brace",
  "}": "right brace",
  "[": "square",
  "]": "right square",
  "<": "angle",
  ">": "right angle",
  "\uFFFD": "special"
};
var characters = {
  ...alphabet,
  ...digits,
  ...symbols
};
function characterToSpokenForm(char) {
  const result = characters[char];
  if (result == null) {
    throw new NoSpokenFormError(`Unknown character '${char}'`);
  }
  return result;
}

// ../cursorless-engine/src/generateSpokenForm/primitiveTargetToSpokenForm.ts
var PrimitiveTargetSpokenFormGenerator = class {
  constructor(spokenFormMap) {
    this.spokenFormMap = spokenFormMap;
    this.handleModifier = this.handleModifier.bind(this);
  }
  handlePrimitiveTarget(target) {
    const components = [];
    if (target.modifiers != null) {
      components.push(target.modifiers.map(this.handleModifier));
    }
    if (target.mark != null) {
      components.push(this.handleMark(target.mark));
    }
    return components;
  }
  handleModifier(modifier) {
    switch (modifier.type) {
      case "cascading":
      case "modifyIfUntyped":
        throw new NoSpokenFormError(`Modifier '${modifier.type}'`);
      case "containingScope":
        if (modifier.ancestorIndex == null || modifier.ancestorIndex === 0) {
          return this.handleScopeType(modifier.scopeType);
        }
        if (modifier.ancestorIndex === 1) {
          return [
            this.spokenFormMap.modifierExtra.ancestor,
            this.handleScopeType(modifier.scopeType)
          ];
        }
        throw new NoSpokenFormError(
          `Modifier '${modifier.type}' with ancestor index ${modifier.ancestorIndex}`
        );
      case "everyScope":
        return [
          this.spokenFormMap.simpleModifier.everyScope,
          this.handleScopeType(modifier.scopeType)
        ];
      case "extendThroughStartOf":
      case "extendThroughEndOf": {
        const type2 = this.spokenFormMap.simpleModifier[modifier.type];
        return modifier.modifiers != null ? [type2, modifier.modifiers.map(this.handleModifier)] : [type2];
      }
      case "relativeScope":
        return modifier.offset === 0 ? this.handleRelativeScopeInclusive(modifier) : this.handleRelativeScopeExclusive(modifier);
      case "ordinalScope": {
        const scope = this.handleScopeType(modifier.scopeType);
        const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
        if (modifier.length === 1) {
          if (modifier.start === -1) {
            return [isEvery, this.spokenFormMap.modifierExtra.last, scope];
          }
          if (modifier.start === 0) {
            return [isEvery, this.spokenFormMap.modifierExtra.first, scope];
          }
          if (modifier.start < 0) {
            return [
              isEvery,
              ordinalToSpokenForm(Math.abs(modifier.start)),
              this.spokenFormMap.modifierExtra.last,
              scope
            ];
          }
          return [isEvery, ordinalToSpokenForm(modifier.start + 1), scope];
        }
        const number = numberToSpokenForm(modifier.length);
        if (modifier.start === 0) {
          return [
            isEvery,
            this.spokenFormMap.modifierExtra.first,
            number,
            pluralize(scope)
          ];
        }
        if (modifier.start === -modifier.length) {
          return [
            isEvery,
            this.spokenFormMap.modifierExtra.last,
            number,
            pluralize(scope)
          ];
        }
        throw new NoSpokenFormError(
          `'${modifier.type}' with count > 1 and offset away from start / end`
        );
      }
      case "range": {
        if (modifier.anchor.type === "ordinalScope" && modifier.active.type === "ordinalScope" && modifier.anchor.length === 1 && modifier.active.length === 1 && modifier.anchor.scopeType.type === modifier.active.scopeType.type) {
          const anchor = modifier.anchor.start === -1 ? this.spokenFormMap.modifierExtra.last : ordinalToSpokenForm(modifier.anchor.start + 1);
          const active = this.handleModifier(modifier.active);
          const connective = getRangeConnective(
            modifier.excludeAnchor,
            modifier.excludeActive
          );
          return [anchor, connective, active];
        }
        throw Error(`Modifier '${modifier.type}' is not fully implemented`);
      }
      default:
        return [this.spokenFormMap.simpleModifier[modifier.type]];
    }
  }
  handleRelativeScopeInclusive(modifier) {
    const scope = this.handleScopeType(modifier.scopeType);
    const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
    if (modifier.length === 1) {
      const direction = modifier.direction === "forward" ? connectives.forward : connectives.backward;
      return [isEvery, scope, direction];
    }
    const length = numberToSpokenForm(modifier.length);
    const scopePlural = pluralize(scope);
    if (modifier.direction === "forward") {
      return [isEvery, length, scopePlural];
    }
    return [isEvery, length, scopePlural, connectives.backward];
  }
  handleRelativeScopeExclusive(modifier) {
    const scope = this.handleScopeType(modifier.scopeType);
    const direction = modifier.direction === "forward" ? connectives.next : connectives.previous;
    const isEvery = modifier.isEvery ? this.spokenFormMap.simpleModifier.everyScope : [];
    if (modifier.offset === 1) {
      const number = numberToSpokenForm(modifier.length);
      if (modifier.length === 1) {
        return [isEvery, direction, scope];
      }
      const scopePlural = pluralize(scope);
      return [isEvery, direction, number, scopePlural];
    }
    if (modifier.length === 1) {
      const ordinal = ordinalToSpokenForm(modifier.offset);
      return [isEvery, ordinal, direction, scope];
    }
    throw new NoSpokenFormError(
      `${modifier.type} modifier with offset > 1 and length > 1`
    );
  }
  handleScopeType(scopeType) {
    switch (scopeType.type) {
      case "oneOf":
        throw new NoSpokenFormError(`Scope type '${scopeType.type}'`);
      case "glyph":
        return [
          this.spokenFormMap.complexScopeTypeType.glyph,
          characterToSpokenForm(scopeType.character)
        ];
      case "surroundingPair": {
        const pair = this.spokenFormMap.pairedDelimiter[scopeType.delimiter];
        if (scopeType.forceDirection != null) {
          return [
            this.spokenFormMap.surroundingPairForceDirection[scopeType.forceDirection],
            pair
          ];
        }
        return pair;
      }
      case "customRegex":
        return this.spokenFormMap.customRegex[scopeType.regex] ?? {
          type: "customizable",
          spokenForms: {
            spokenForms: [],
            isCustom: true,
            defaultSpokenForms: [],
            requiresTalonUpdate: false,
            isPrivate: false
          },
          spokenFormType: "customRegex",
          id: scopeType.regex
        };
      default:
        return this.spokenFormMap.simpleScopeTypeType[scopeType.type];
    }
  }
  handleMark(mark) {
    switch (mark.type) {
      case "decoratedSymbol": {
        const [color, shape] = mark.symbolColor.split("-");
        const components = [];
        if (color !== "default") {
          components.push(hatColorToSpokenForm(color));
        }
        if (shape != null) {
          components.push(hatShapeToSpokenForm(shape));
        }
        components.push(characterToSpokenForm(mark.character));
        return components;
      }
      case "lineNumber": {
        return this.handleLineNumberMark(mark);
      }
      case "range": {
        if (mark.anchor.type === "lineNumber" && mark.active.type === "lineNumber") {
          const [typeAnchor, numberAnchor] = this.handleLineNumberMark(
            mark.anchor
          );
          const [typeActive, numberActive] = this.handleLineNumberMark(
            mark.active
          );
          if (typeAnchor === typeActive) {
            const connective = getRangeConnective(
              mark.excludeAnchor,
              mark.excludeActive
            );
            return [typeAnchor, numberAnchor, connective, numberActive];
          }
        }
        throw Error(`Mark '${mark.type}' is not fully implemented`);
      }
      case "explicit":
      case "keyboard":
        throw new NoSpokenFormError(`Mark '${mark.type}'`);
      default:
        return [marks[mark.type]];
    }
  }
  handleLineNumberMark(mark) {
    switch (mark.lineNumberType) {
      case "absolute":
        throw new NoSpokenFormError("Absolute line numbers");
      case "modulo100": {
        return [
          lineDirections.modulo100,
          numberToSpokenForm(mark.lineNumber + 1)
        ];
      }
      case "relative": {
        return [
          mark.lineNumber < 0 ? lineDirections.relativeUp : lineDirections.relativeDown,
          numberToSpokenForm(Math.abs(mark.lineNumber))
        ];
      }
    }
  }
};
function pluralize(name) {
  if (typeof name === "string") {
    return pluralizeString(name);
  }
  if (Array.isArray(name)) {
    if (name.length === 0) {
      return name;
    }
    const last2 = name[name.length - 1];
    return [...name.slice(0, -1), pluralize(last2)];
  }
  return {
    ...name,
    spokenForms: {
      ...name.spokenForms,
      spokenForms: name.spokenForms.spokenForms.map(pluralizeString)
    }
  };
}
function pluralizeString(name) {
  return `${name}s`;
}

// ../cursorless-engine/src/generateSpokenForm/getSpokenFormComponentMap.ts
function getSpokenFormComponentMap(spokenFormMap) {
  return Object.fromEntries(
    Object.entries(spokenFormMap).map(([spokenFormType, map4]) => [
      spokenFormType,
      Object.fromEntries(
        Object.entries(map4).map(([id, spokenForms]) => [
          id,
          {
            type: "customizable",
            spokenForms,
            spokenFormType,
            id
          }
        ])
      )
    ])
    // FIXME: Don't cast here; need to make our own mapValues with stronger typing
    // using tricks from our object.d.ts
  );
}

// ../cursorless-engine/src/generateSpokenForm/generateSpokenForm.ts
var SpokenFormGenerator = class {
  constructor(spokenFormMap) {
    this.spokenFormMap = getSpokenFormComponentMap(spokenFormMap);
    this.primitiveGenerator = new PrimitiveTargetSpokenFormGenerator(
      this.spokenFormMap
    );
  }
  /**
   * Given a command, generates its spoken form.
   * @param command The command to generate a spoken form for
   * @returns The spoken form of the command
   */
  processCommand(command) {
    return this.componentsToSpokenForm(() => this.handleAction(command.action));
  }
  /**
   * Given a scope type, generates its spoken form.
   * @param scopeType The scope type to generate a spoken form for
   * @returns The spoken form of the scope type
   */
  processScopeType(scopeType) {
    return this.componentsToSpokenForm(() => [
      this.primitiveGenerator.handleScopeType(scopeType)
    ]);
  }
  /**
   * Given a function that returns a spoken form component, generates a spoken
   * form for that component by flattening the component and performing a
   * cartesian product over any elements that have multiple ways to be spoken.
   * Note that this spoken form object can correspond to multiple actual spoken
   * forms, consisting of a preferred spoken form and a list of alternative
   * spoken forms.
   *
   * Note that today, we arbitrarily choose the first spoken form as the
   * preferred spoken form, and the rest as alternative spoken forms.
   *
   * If the function throws a {@link NoSpokenFormError}, returns an error spoken
   * form object instead.
   *
   * @param getComponents A function that returns the components to generate a
   * spoken form for
   * @returns A spoken form for the given components
   */
  componentsToSpokenForm(getComponents) {
    try {
      return {
        type: "success",
        spokenForms: constructSpokenForms(getComponents())
      };
    } catch (e) {
      if (e instanceof NoSpokenFormError) {
        return {
          type: "error",
          reason: e.reason,
          requiresTalonUpdate: e.requiresTalonUpdate,
          isPrivate: e.isPrivate
        };
      }
      throw e;
    }
  }
  handleAction(action) {
    switch (action.name) {
      case "editNew":
      case "getText":
      case "replace":
      case "executeCommand":
      case "private.getTargets":
      case "private.setKeyboardTarget":
        throw new NoSpokenFormError(`Action '${action.name}'`);
      case "replaceWithTarget":
      case "moveToTarget":
        return [
          actions[action.name],
          this.handleTarget(action.source),
          this.handleDestination(action.destination)
        ];
      case "swapTargets":
        return [
          actions[action.name],
          this.handleTarget(action.target1),
          connectives.swapConnective,
          this.handleTarget(action.target2)
        ];
      case "callAsFunction":
        if (action.argument.type === "implicit") {
          return [actions[action.name], this.handleTarget(action.callee)];
        }
        return [
          actions[action.name],
          this.handleTarget(action.callee),
          "on",
          this.handleTarget(action.argument)
        ];
      case "wrapWithPairedDelimiter":
      case "rewrapWithPairedDelimiter":
        return [
          surroundingPairDelimitersToSpokenForm(
            this.spokenFormMap,
            action.left,
            action.right
          ),
          actions[action.name],
          this.handleTarget(action.target)
        ];
      case "pasteFromClipboard":
        return [
          actions[action.name],
          this.handleDestination(action.destination)
        ];
      case "insertSnippet":
        return [
          actions[action.name],
          insertionSnippetToSpokenForm(action.snippetDescription),
          this.handleDestination(action.destination)
        ];
      case "generateSnippet":
        if (action.snippetName != null) {
          throw new NoSpokenFormError(`${action.name}.snippetName`);
        }
        return [actions[action.name], this.handleTarget(action.target)];
      case "wrapWithSnippet":
        return [
          wrapperSnippetToSpokenForm(action.snippetDescription),
          actions[action.name],
          this.handleTarget(action.target)
        ];
      case "highlight": {
        if (action.highlightId != null) {
          throw new NoSpokenFormError(`${action.name}.highlightId`);
        }
        return [actions[action.name], this.handleTarget(action.target)];
      }
      default: {
        return [actions[action.name], this.handleTarget(action.target)];
      }
    }
  }
  handleTarget(target) {
    switch (target.type) {
      case "list":
        if (target.elements.length < 2) {
          throw new NoSpokenFormError("List target with < 2 elements");
        }
        return target.elements.map(
          (element, i) => i === 0 ? this.handleTarget(element) : [connectives.listConnective, this.handleTarget(element)]
        );
      case "range": {
        const anchor = this.handleTarget(target.anchor);
        const active = this.handleTarget(target.active);
        const connective = getRangeConnective(
          target.excludeAnchor,
          target.excludeActive,
          target.rangeType
        );
        return [anchor, connective, active];
      }
      case "primitive":
        return this.primitiveGenerator.handlePrimitiveTarget(target);
      case "implicit":
        return [];
    }
  }
  handleDestination(destination) {
    switch (destination.type) {
      case "list":
        if (destination.destinations.length < 2) {
          throw new NoSpokenFormError("List destination with < 2 elements");
        }
        return destination.destinations.map(
          (destination2, i) => i === 0 ? this.handleDestination(destination2) : [connectives.listConnective, this.handleDestination(destination2)]
        );
      case "primitive":
        return [
          this.handleInsertionMode(destination.insertionMode),
          this.handleTarget(destination.target)
        ];
      case "implicit":
        return [];
    }
  }
  handleInsertionMode(insertionMode) {
    switch (insertionMode) {
      case "to":
        return connectives.sourceDestinationConnective;
      case "before":
        return connectives.before;
      case "after":
        return connectives.after;
    }
  }
};
function constructSpokenForms(component) {
  if (typeof component === "string") {
    return [component];
  }
  if (Array.isArray(component)) {
    if (component.length === 0) {
      return [""];
    }
    return cartesianProduct(component.map(constructSpokenForms)).map(
      (words) => words.filter((word) => word.length !== 0).join(" ")
    );
  }
  if (component.spokenForms.spokenForms.length === 0) {
    const componentInfo = `${camelCaseToAllDown(
      component.spokenFormType
    )} with id ${component.id}`;
    let helpInfo;
    if (component.spokenForms.isPrivate) {
      helpInfo = "this is a private spoken form currently only for internal experimentation";
    } else if (component.spokenForms.requiresTalonUpdate) {
      helpInfo = "please update talon to the latest version (see https://www.cursorless.org/docs/user/updating/)";
    } else {
      helpInfo = "please see https://www.cursorless.org/docs/user/customization/ for more information";
    }
    throw new NoSpokenFormError(
      `${componentInfo}; ${helpInfo}`,
      component.spokenForms.requiresTalonUpdate,
      component.spokenForms.isPrivate
    );
  }
  return component.spokenForms.spokenForms;
}
function cartesianProduct(arrays) {
  if (arrays.length === 0) {
    return [];
  }
  if (arrays.length === 1) {
    return arrays[0].map((element) => [element]);
  }
  const [first, ...rest] = arrays;
  const restCartesianProduct = cartesianProduct(rest);
  return first.flatMap(
    (element) => restCartesianProduct.map((restElement) => [element, ...restElement])
  );
}

// ../cursorless-engine/src/spokenForms/SpokenFormMap.ts
function mapSpokenForms(input, mapper) {
  return Object.fromEntries(
    Object.entries(input).map(([spokenFormType, map4]) => [
      spokenFormType,
      Object.fromEntries(
        Object.entries(map4).map(([id, inputValue]) => [
          id,
          mapper(inputValue, spokenFormType, id)
        ])
      )
    ])
    // FIXME: Don't cast here; need to make our own mapValues with stronger typing
    // using tricks from our object.d.ts
  );
}

// ../cursorless-engine/src/spokenForms/spokenFormMapUtil.ts
function isDisabledByDefault(...spokenForms) {
  return {
    defaultSpokenForms: spokenForms,
    isDisabledByDefault: true,
    isPrivate: false
  };
}
function isPrivate(...spokenForms) {
  return {
    defaultSpokenForms: spokenForms,
    isDisabledByDefault: true,
    isPrivate: true
  };
}

// ../cursorless-engine/src/spokenForms/defaultSpokenFormMapCore.ts
var defaultSpokenFormMapCore = {
  pairedDelimiter: {
    curlyBrackets: "curly",
    angleBrackets: "diamond",
    escapedDoubleQuotes: "escaped quad",
    escapedSingleQuotes: "escaped twin",
    escapedParentheses: "escaped round",
    escapedSquareBrackets: "escaped box",
    doubleQuotes: "quad",
    parentheses: "round",
    backtickQuotes: "skis",
    squareBrackets: "box",
    singleQuotes: "twin",
    any: "pair",
    string: "string",
    whitespace: "void",
    collectionBoundary: isPrivate("collection boundary")
  },
  simpleScopeTypeType: {
    argumentOrParameter: "arg",
    attribute: "attribute",
    functionCall: "call",
    functionCallee: "callee",
    className: "class name",
    class: "class",
    comment: "comment",
    functionName: "funk name",
    namedFunction: "funk",
    ifStatement: "if state",
    instance: "instance",
    collectionItem: "item",
    collectionKey: "key",
    anonymousFunction: "lambda",
    list: "list",
    map: "map",
    name: "name",
    regularExpression: "regex",
    section: "section",
    sectionLevelOne: isDisabledByDefault("one section"),
    sectionLevelTwo: isDisabledByDefault("two section"),
    sectionLevelThree: isDisabledByDefault("three section"),
    sectionLevelFour: isDisabledByDefault("four section"),
    sectionLevelFive: isDisabledByDefault("five section"),
    sectionLevelSix: isDisabledByDefault("six section"),
    selector: "selector",
    statement: "state",
    branch: "branch",
    type: "type",
    value: "value",
    condition: "condition",
    unit: "unit",
    //  XML, JSX
    xmlElement: "element",
    xmlBothTags: "tags",
    xmlStartTag: "start tag",
    xmlEndTag: "end tag",
    // LaTeX
    part: "part",
    chapter: "chapter",
    subSection: "subsection",
    subSubSection: "subsubsection",
    namedParagraph: "paragraph",
    subParagraph: "subparagraph",
    environment: "environment",
    // Talon
    command: "command",
    // Text-based scope types
    character: "char",
    word: "sub",
    token: "token",
    identifier: "identifier",
    line: "line",
    sentence: "sentence",
    paragraph: "block",
    document: "file",
    nonWhitespaceSequence: "paint",
    boundedNonWhitespaceSequence: "short paint",
    url: "link",
    notebookCell: "cell",
    ["private.fieldAccess"]: isPrivate("access"),
    string: isPrivate("parse tree string"),
    ["private.switchStatementSubject"]: isPrivate("subject")
  },
  complexScopeTypeType: {
    glyph: "glyph"
  },
  surroundingPairForceDirection: {
    left: "left",
    right: "right"
  },
  simpleModifier: {
    excludeInterior: "bounds",
    toRawSelection: "just",
    leading: "leading",
    trailing: "trailing",
    keepContentFilter: "content",
    keepEmptyFilter: "empty",
    inferPreviousMark: "its",
    startOf: "start of",
    endOf: "end of",
    interiorOnly: "inside",
    visible: "visible",
    extendThroughStartOf: "head",
    extendThroughEndOf: "tail",
    everyScope: "every"
  },
  modifierExtra: {
    first: "first",
    last: "last",
    previous: "previous",
    next: "next",
    forward: "forward",
    backward: "backward",
    ancestor: "grand"
  },
  customRegex: {}
};

// ../cursorless-engine/src/spokenForms/defaultSpokenFormMap.ts
var defaultSpokenFormInfoMap = mapSpokenForms(
  defaultSpokenFormMapCore,
  (value) => typeof value === "string" ? {
    defaultSpokenForms: [value],
    isDisabledByDefault: false,
    isPrivate: false
  } : value
);
var defaultSpokenFormMap = mapSpokenForms(
  defaultSpokenFormInfoMap,
  ({ defaultSpokenForms, isDisabledByDefault: isDisabledByDefault2, isPrivate: isPrivate2 }) => ({
    spokenForms: isDisabledByDefault2 ? [] : defaultSpokenForms,
    isCustom: false,
    defaultSpokenForms,
    requiresTalonUpdate: false,
    isPrivate: isPrivate2
  })
);

// ../cursorless-engine/src/testCaseRecorder/TestCase.ts
var import_lodash11 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/getPartialTargetDescriptors.ts
function getPartialTargetDescriptors(action) {
  switch (action.name) {
    case "callAsFunction":
      return [action.callee, action.argument];
    case "replaceWithTarget":
    case "moveToTarget":
      return [
        action.source,
        ...getPartialTargetDescriptorsFromDestination(action.destination)
      ];
    case "swapTargets":
      return [action.target1, action.target2];
    case "pasteFromClipboard":
    case "insertSnippet":
    case "replace":
    case "editNew":
      return getPartialTargetDescriptorsFromDestination(action.destination);
    default:
      return [action.target];
  }
}
function getPartialTargetDescriptorsFromDestination(destination) {
  switch (destination.type) {
    case "list":
      return destination.destinations.map(({ target }) => target);
    case "primitive":
      return [destination.target];
    case "implicit":
      return [];
  }
}

// ../cursorless-engine/src/util/object.ts
function mergeStrict(...objects) {
  const returnValue = {};
  objects.forEach((object) => {
    for (const [key, value] of Object.entries(object)) {
      if (Object.prototype.hasOwnProperty.call(returnValue, key)) {
        throw new Error(`Found duplicate property ${key}`);
      }
      returnValue[key] = value;
    }
  });
  return returnValue;
}
function unsafeKeys(o) {
  return Object.keys(o);
}

// ../cursorless-engine/src/core/StoredTargets.ts
var StoredTargetMap = class {
  constructor() {
    this.targetMap = /* @__PURE__ */ new Map();
    this.notifier = new Notifier();
  }
  set(key, targets) {
    this.targetMap.set(key, targets);
    this.notifier.notifyListeners(key, targets);
  }
  get(key) {
    return this.targetMap.get(key);
  }
  onStoredTargets(callback2) {
    for (const key of storedTargetKeys) {
      callback2(key, this.get(key));
    }
    return this.notifier.registerListener(callback2);
  }
};

// ../cursorless-engine/src/core/Debug.ts
var Debug = class {
  constructor(treeSitter) {
    this.treeSitter = treeSitter;
    ide().disposeOnExit(this);
    this.evaluateSetting = this.evaluateSetting.bind(this);
    this.logBranchTypes = this.logBranchTypes.bind(this);
    this.active = true;
    switch (ide().runMode) {
      case "development":
        this.enableDebugLog();
        break;
      case "test":
        this.disableDebugLog();
        break;
      case "production":
        this.evaluateSetting();
        this.disposableConfiguration = ide().configuration.onDidChangeConfiguration(this.evaluateSetting);
        break;
    }
  }
  log(...args) {
    if (this.active) {
      console.log(...args);
    }
  }
  dispose() {
    if (this.disposableConfiguration) {
      this.disposableConfiguration.dispose();
    }
    if (this.disposableSelection) {
      this.disposableSelection.dispose();
    }
  }
  enableDebugLog() {
    this.active = true;
    this.disposableSelection = ide().onDidChangeTextEditorSelection(
      this.logBranchTypes
    );
  }
  disableDebugLog() {
    this.active = false;
    if (this.disposableSelection) {
      this.disposableSelection.dispose();
      this.disposableSelection = void 0;
    }
  }
  evaluateSetting() {
    const debugEnabled = ide().configuration.getOwnConfiguration("debug");
    if (debugEnabled) {
      this.enableDebugLog();
    } else {
      this.disableDebugLog();
    }
  }
  logBranchTypes(event) {
    let node;
    try {
      node = this.treeSitter.getNodeAtLocation(
        ide().activeTextEditor.document,
        event.selections[0]
      );
    } catch (error) {
      return;
    }
    const ancestors = [node];
    while (node.parent != null) {
      ancestors.unshift(node.parent);
      node = node.parent;
    }
    const cursor = node.tree.walk();
    this.printCursorLocationInfo(ancestors, cursor, 0);
  }
  printCursorLocationInfo(nodes, cursor, index) {
    const field = cursor.currentFieldName();
    const fieldText = field != null ? `${field}: ` : "";
    const indent = " ".repeat(index);
    const nodeIsLast = index === nodes.length - 1;
    const { nodeIsNamed } = cursor;
    let text = `${indent}${fieldText}`;
    if (nodeIsNamed) {
      text += `(${cursor.nodeType}`;
      if (nodeIsLast) {
        text += ")";
      }
    } else {
      text += `"${cursor.nodeType}"`;
    }
    console.log(text);
    if (!nodeIsLast && this.cursorGoToChildWithId(cursor, nodes[index + 1].id)) {
      this.printCursorLocationInfo(nodes, cursor, index + 1);
    }
    if (nodeIsNamed && !nodeIsLast) {
      console.log(`${indent})`);
    }
  }
  cursorGoToChildWithId(cursor, id) {
    cursor.gotoFirstChild();
    while (cursor.currentNode().id !== id) {
      if (!cursor.gotoNextSibling()) {
        return false;
      }
    }
    return true;
  }
};

// ../cursorless-engine/src/core/HatTokenMapImpl.ts
var import_process = require("process");

// ../cursorless-engine/src/util/bigint.ts
function abs(x) {
  return x < BigInt(0) ? -x : x;
}

// ../cursorless-engine/src/tokenGraphemeSplitter/tokenGraphemeSplitter.ts
var import_lodash13 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/regex.ts
function _rightAnchored(regex) {
  const { source, flags } = regex;
  return new RegExp(`(${source})$`, flags.replace("m", ""));
}
function _leftAnchored(regex) {
  const { source, flags } = regex;
  return new RegExp(`^(${source})`, flags.replace("m", ""));
}
function makeCache(func) {
  const cache = /* @__PURE__ */ new Map();
  function wrapper(arg) {
    let cachedValue = cache.get(arg);
    if (cachedValue == null) {
      cachedValue = func(arg);
      cache.set(arg, cachedValue);
    }
    return cachedValue;
  }
  return wrapper;
}
var rightAnchored = makeCache(_rightAnchored);
var leftAnchored = makeCache(_leftAnchored);
function matchAll(text, regex, mapfn) {
  regex.lastIndex = 0;
  return Array.from(text.matchAll(regex), mapfn);
}
function testRegex(regex, text) {
  regex.lastIndex = 0;
  return regex.test(text);
}
function matchRegex(regex, text) {
  regex.lastIndex = 0;
  return text.match(regex);
}
function matchText(text, regex) {
  return matchAll(text, regex, (match2) => ({
    index: match2.index,
    text: match2[0]
  }));
}

// ../cursorless-engine/src/tokenGraphemeSplitter/tokenGraphemeSplitter.ts
var KNOWN_SYMBOLS = [
  "!",
  "#",
  "$",
  "%",
  "&",
  "'",
  "(",
  ")",
  "*",
  "+",
  ",",
  "-",
  ".",
  "/",
  ":",
  ";",
  "<",
  "=",
  ">",
  "?",
  "@",
  "[",
  "\\",
  "]",
  "^",
  "_",
  "`",
  "{",
  "|",
  "}",
  "~",
  "\xA3",
  '"'
];
var KNOWN_SYMBOL_REGEXP_STR = KNOWN_SYMBOLS.map(import_lodash13.escapeRegExp).join("|");
var KNOWN_GRAPHEME_REGEXP_STR = ["[a-zA-Z0-9]", KNOWN_SYMBOL_REGEXP_STR].join(
  "|"
);
var KNOWN_GRAPHEME_MATCHER = new RegExp(
  `^(${KNOWN_GRAPHEME_REGEXP_STR})$`,
  "u"
);
var UNKNOWN = "[unk]";
var GRAPHEME_SPLIT_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}]/gu;
var TokenGraphemeSplitter = class {
  constructor() {
    this.disposables = [];
    this.algorithmChangeNotifier = new Notifier();
    /**
     * Splits {@link token} into a list of graphemes, normalised as per
     * {@link normalizeGrapheme}.
     * @param token The token to split
     * @returns A list of normalised graphemes in {@link token}
     */
    this.getTokenGraphemes = (token) => matchAll(token, GRAPHEME_SPLIT_REGEX, (match2) => ({
      text: this.normalizeGrapheme(match2[0]),
      tokenStartOffset: match2.index,
      tokenEndOffset: match2.index + match2[0].length
    }));
    /**
     * Register to be notified when the graphing splitting algorithm changes, for example if
     * the user changes the setting to enable preserving case
     * @param listener A function to be called when graphing splitting algorithm changes
     * @returns A function that can be called to unsubscribe from notifications
     */
    this.registerAlgorithmChangeListener = this.algorithmChangeNotifier.registerListener;
    ide().disposeOnExit(this);
    this.updateTokenHatSplittingMode = this.updateTokenHatSplittingMode.bind(this);
    this.getTokenGraphemes = this.getTokenGraphemes.bind(this);
    this.updateTokenHatSplittingMode();
    this.disposables.push(
      // Notify listeners in case the user changed their token hat splitting
      // setting.
      ide().configuration.onDidChangeConfiguration(
        this.updateTokenHatSplittingMode
      )
    );
  }
  updateTokenHatSplittingMode() {
    const { lettersToPreserve, symbolsToPreserve, ...rest } = ide().configuration.getOwnConfiguration("tokenHatSplittingMode");
    this.tokenHatSplittingMode = {
      lettersToPreserve: lettersToPreserve.map(
        (grapheme) => grapheme.toLowerCase().normalize("NFC")
      ),
      symbolsToPreserve: symbolsToPreserve.map(
        (grapheme) => grapheme.normalize("NFC")
      ),
      ...rest
    };
    this.algorithmChangeNotifier.notifyListeners();
  }
  /**
   * Normalizes the grapheme {@link rawGraphemeText} based on user
   * configuration.  Proceeds as follows:
   *
   * 1. Runs text through Unicode NFC normalization to ensure that characters
   *    that look identical are handled the same (eg whether they use combining
   *    mark or single codepoint for diacritics).
   * 2. If the grapheme is a known grapheme, returns it.
   * 3. Transforms grapheme to lowercase if
   *    {@link TokenHatSplittingMode.preserveCase} is `false`
   * 3. Returns the (possibly case-normalised) grapheme if it appears in
   *    {@link TokenHatSplittingMode.lettersToPreserve}
   * 4. Strips diacritics from the grapheme
   * 5. If the grapheme doesn't match {@link KNOWN_GRAPHEME_MATCHER}, maps the
   *    grapheme to the constant {@link UNKNOWN}, so that it can be referred to
   *    using "special", "red special", etc.
   * 6. Returns the grapheme.
   *
   * @param rawGraphemeText The raw grapheme text to normalise
   * @returns The normalised grapheme
   */
  normalizeGrapheme(rawGraphemeText) {
    const { preserveCase, lettersToPreserve, symbolsToPreserve } = this.tokenHatSplittingMode;
    let returnValue = rawGraphemeText.normalize("NFC");
    if (symbolsToPreserve.includes(returnValue)) {
      return returnValue;
    }
    if (!preserveCase) {
      returnValue = returnValue.toLowerCase();
    }
    if (lettersToPreserve.includes(returnValue.toLowerCase())) {
      return returnValue;
    }
    returnValue = (0, import_lodash13.deburr)(returnValue);
    if (!KNOWN_GRAPHEME_MATCHER.test(returnValue)) {
      returnValue = UNKNOWN;
    }
    return returnValue;
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => dispose());
  }
};

// ../cursorless-engine/src/singletons/tokenGraphemeSplitter.singleton.ts
function tokenGraphemeSplitter() {
  if (tokenGraphemeSplitter_ == null) {
    tokenGraphemeSplitter_ = new TokenGraphemeSplitter();
  }
  return tokenGraphemeSplitter_;
}
var tokenGraphemeSplitter_;

// ../cursorless-engine/src/util/allocateHats/HatMetrics.ts
var import_lodash14 = __toESM(require_lodash(), 1);
var negativePenalty = ({ penalty }) => -penalty;
function hatOldTokenRank(hatOldTokenRanks) {
  return ({ grapheme: { text: grapheme }, style }) => {
    const hatOldTokenRank2 = hatOldTokenRanks.get({
      grapheme,
      hatStyle: style
    });
    return hatOldTokenRank2 == null ? Infinity : -hatOldTokenRank2;
  };
}
function minimumTokenRankContainingGrapheme(tokenRank, graphemeTokenRanks) {
  const coreMetric = (0, import_lodash14.memoize)((graphemeText) => {
    return (0, import_lodash14.min)(graphemeTokenRanks[graphemeText].filter((r) => r > tokenRank)) ?? Infinity;
  });
  return ({ grapheme: { text } }) => coreMetric(text);
}
function isOldTokenHat(oldTokenHat) {
  return (hat) => hat.grapheme.text === oldTokenHat?.grapheme && hat.style === oldTokenHat?.hatStyle ? 1 : 0;
}
function penaltyEquivalenceClass(hatStability) {
  switch (hatStability) {
    case "greedy" /* greedy */:
      return ({ penalty }) => -penalty;
    case "balanced" /* balanced */:
      return ({ penalty }) => -(penalty < 2 ? 0 : 1);
    case "stable" /* stable */:
      return (_) => 0;
  }
}

// ../cursorless-engine/src/util/allocateHats/maxByFirstDiffering.ts
function maxByFirstDiffering(arr, fns) {
  if (arr.length === 0) {
    return void 0;
  }
  let remainingValues = arr;
  for (const fn of fns) {
    if (remainingValues.length === 1) {
      return remainingValues[0];
    }
    remainingValues = maxByAllowingTies(remainingValues, fn);
  }
  return remainingValues[0];
}
function maxByAllowingTies(arr, fn) {
  let best = -Infinity;
  const keep = [];
  for (const item of arr) {
    const value = fn(item);
    if (value < best) {
      continue;
    }
    if (value > best) {
      best = value;
      keep.length = 0;
    }
    keep.push(item);
  }
  return keep;
}

// ../cursorless-engine/src/util/allocateHats/chooseTokenHat.ts
function chooseTokenHat({ hatOldTokenRanks, graphemeTokenRanks }, hatStability, tokenRank, oldTokenHat, candidates) {
  return maxByFirstDiffering(candidates, [
    // 1. Discard any hats that are sufficiently worse than the best hat that we
    //    wouldn't use them even if they were our old hat
    penaltyEquivalenceClass(hatStability),
    // 2. Use our old hat if it's still in the running
    isOldTokenHat(oldTokenHat),
    // 3. Use a free hat if possible; if not, steal the hat of the token with
    //    lowest rank
    hatOldTokenRank(hatOldTokenRanks),
    // 4. Narrow to the hats with the lowest penalty
    negativePenalty,
    // 5. Prefer hats that sit on a grapheme that doesn't appear in any highly
    //    ranked token
    minimumTokenRankContainingGrapheme(tokenRank, graphemeTokenRanks)
  ]);
}

// ../cursorless-engine/src/util/allocateHats/getHatRankingContext.ts
function getHatRankingContext(tokens, oldTokenHatMap, tokenGraphemeSplitter2) {
  const graphemeTokenRanks = {};
  const hatOldTokenRanks = new CompositeKeyMap(({ grapheme, hatStyle }) => [grapheme, hatStyle]);
  tokens.forEach(({ token, rank }) => {
    const existingTokenHat = oldTokenHatMap.get(token);
    if (existingTokenHat != null) {
      hatOldTokenRanks.set(existingTokenHat, rank);
    }
    tokenGraphemeSplitter2.getTokenGraphemes(token.text).forEach(({ text: graphemeText }) => {
      let tokenRanksForGrapheme;
      if (graphemeText in graphemeTokenRanks) {
        tokenRanksForGrapheme = graphemeTokenRanks[graphemeText];
      } else {
        tokenRanksForGrapheme = [];
        graphemeTokenRanks[graphemeText] = tokenRanksForGrapheme;
      }
      tokenRanksForGrapheme.push(rank);
    });
  });
  return {
    hatOldTokenRanks,
    graphemeTokenRanks
  };
}

// ../cursorless-engine/src/util/allocateHats/getRankedTokens.ts
var import_lodash17 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/allocateHats/getDisplayLineMap.ts
var import_lodash15 = __toESM(require_lodash(), 1);
function getDisplayLineMap(editor, extraLines = []) {
  return new Map(
    (0, import_lodash15.flow)(
      import_lodash15.flatten,
      import_lodash15.uniq
    )(
      (0, import_lodash15.concat)(
        [extraLines],
        editor.visibleRanges.map(
          (visibleRange) => (0, import_lodash15.range)(visibleRange.start.line, visibleRange.end.line + 1)
        )
      )
    ).sort((a, b) => a - b).map((value, index) => [value, index])
  );
}

// ../cursorless-engine/src/util/allocateHats/getTokenComparator.ts
function getTokenComparator(selectionDisplayLine, selectionCharacterIndex) {
  return (token1, token2) => {
    const token1LineDiff = Math.abs(token1.displayLine - selectionDisplayLine);
    const token2LineDiff = Math.abs(token2.displayLine - selectionDisplayLine);
    if (token1LineDiff < token2LineDiff) {
      return -1;
    }
    if (token1LineDiff > token2LineDiff) {
      return 1;
    }
    const token1CharacterDiff = Math.abs(
      token1.range.start.character - selectionCharacterIndex
    );
    const token2CharacterDiff = Math.abs(
      token2.range.start.character - selectionCharacterIndex
    );
    return token1CharacterDiff - token2CharacterDiff;
  };
}

// ../cursorless-engine/src/tokenizer/tokenizer.ts
var import_lodash16 = __toESM(require_lodash(), 1);
var REPEATABLE_SYMBOLS = [
  "-",
  "+",
  "*",
  "/",
  "=",
  "<",
  ">",
  "_",
  "#",
  ".",
  "|",
  "&",
  ":"
];
var FIXED_TOKENS = [
  "!==",
  "!=",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "<=",
  ">=",
  "=>",
  "->",
  "??",
  '"""',
  "```",
  "/*",
  "*/",
  "<!--",
  "-->"
];
var IDENTIFIER_WORD_REGEXES = ["\\p{L}", "\\p{M}", "\\p{N}"];
var SINGLE_SYMBOLS_REGEX = "[^\\s\\w]";
var NUMBERS_REGEX = "(?<![.\\d])\\d+\\.\\d+(?![.\\d])";
function generateMatcher(languageComponents) {
  const {
    fixedTokens,
    repeatableSymbols,
    identifierWordRegexes,
    identifierWordDelimiters,
    numbersRegex,
    singleSymbolsRegex
  } = languageComponents;
  const repeatableSymbolsRegex = repeatableSymbols.map(import_lodash16.escapeRegExp).map((s) => `${s}+`).join("|");
  const fixedTokensRegex = fixedTokens.map(import_lodash16.escapeRegExp).join("|");
  const identifierComponents = identifierWordRegexes.concat(
    identifierWordDelimiters.map(import_lodash16.escapeRegExp)
  );
  const identifiersRegex = `(${identifierComponents.join("|")})+`;
  const wordRegex = `(${identifierWordRegexes.join("|")})+`;
  const regex = [
    fixedTokensRegex,
    numbersRegex,
    identifiersRegex,
    repeatableSymbolsRegex,
    singleSymbolsRegex
  ].join("|");
  return {
    identifierMatcher: new RegExp(identifiersRegex, "gu"),
    wordMatcher: new RegExp(wordRegex, "gu"),
    tokenMatcher: new RegExp(regex, "gu")
  };
}
var matchers = /* @__PURE__ */ new Map();
function getMatcher(languageId) {
  const wordSeparators = ide().configuration.getOwnConfiguration(
    "wordSeparators",
    {
      languageId
    }
  );
  const key = wordSeparators.join("\0");
  if (!matchers.has(key)) {
    const components = {
      fixedTokens: FIXED_TOKENS,
      repeatableSymbols: REPEATABLE_SYMBOLS,
      identifierWordRegexes: IDENTIFIER_WORD_REGEXES,
      identifierWordDelimiters: wordSeparators,
      numbersRegex: NUMBERS_REGEX,
      singleSymbolsRegex: SINGLE_SYMBOLS_REGEX
    };
    matchers.set(key, generateMatcher(components));
  }
  return matchers.get(key);
}
function tokenize(text, languageId, mapfn) {
  return matchAll(text, getMatcher(languageId).tokenMatcher, mapfn);
}

// ../cursorless-engine/src/util/allocateHats/getTokensInRange.ts
function getTokensInRange(editor, range4) {
  const languageId = editor.document.languageId;
  const text = editor.document.getText(range4);
  const rangeOffset = editor.document.offsetAt(range4.start);
  return tokenize(text, languageId, (match2) => {
    const startOffset = rangeOffset + match2.index;
    const endOffset = rangeOffset + match2.index + match2[0].length;
    const range5 = new Range(
      editor.document.positionAt(startOffset),
      editor.document.positionAt(endOffset)
    );
    return {
      editor,
      text: match2[0],
      range: range5,
      offsets: { start: startOffset, end: endOffset }
    };
  });
}

// ../cursorless-engine/src/util/allocateHats/getRankedTokens.ts
function getRankedTokens(activeTextEditor, visibleTextEditors) {
  const editors = getRankedEditors(
    activeTextEditor,
    visibleTextEditors
  );
  return editors.flatMap((editor) => {
    const referencePosition = editor.selections[0].active;
    const displayLineMap = getDisplayLineMap(editor, [referencePosition.line]);
    const tokens = (0, import_lodash17.flatten)(
      editor.visibleRanges.map(
        (range4) => getTokensInRange(editor, range4).map((partialToken) => ({
          ...partialToken,
          displayLine: displayLineMap.get(partialToken.range.start.line)
        }))
      )
    );
    tokens.sort(
      getTokenComparator(
        displayLineMap.get(referencePosition.line),
        referencePosition.character
      )
    );
    return tokens.map((token, index) => ({ token, rank: -index }));
  });
}
function getRankedEditors(activeTextEditor, visibleTextEditors) {
  let editors;
  if (activeTextEditor == null) {
    editors = visibleTextEditors;
  } else {
    editors = [
      activeTextEditor,
      ...visibleTextEditors.filter((editor) => editor !== activeTextEditor)
    ];
  }
  return editors;
}

// ../cursorless-engine/src/util/allocateHats/allocateHats.ts
function allocateHats(tokenGraphemeSplitter2, enabledHatStyles, oldTokenHats, hatStability, activeTextEditor, visibleTextEditors) {
  const tokenOldHatMap = getTokenOldHatMap(oldTokenHats);
  const rankedTokens = getRankedTokens(activeTextEditor, visibleTextEditors);
  const context = getHatRankingContext(
    rankedTokens,
    tokenOldHatMap,
    tokenGraphemeSplitter2
  );
  const enabledHatStyleNames = Object.keys(enabledHatStyles);
  const graphemeRemainingHatCandidates = new DefaultMap(
    () => [...enabledHatStyleNames]
  );
  return rankedTokens.map(({ token, rank: tokenRank }) => {
    const tokenRemainingHatCandidates = getTokenRemainingHatCandidates(
      tokenGraphemeSplitter2,
      token,
      graphemeRemainingHatCandidates,
      enabledHatStyles
    );
    const chosenHat = chooseTokenHat(
      context,
      hatStability,
      tokenRank,
      tokenOldHatMap.get(token),
      tokenRemainingHatCandidates
    );
    if (chosenHat == null) {
      return void 0;
    }
    graphemeRemainingHatCandidates.set(
      chosenHat.grapheme.text,
      graphemeRemainingHatCandidates.get(chosenHat.grapheme.text).filter((style) => style !== chosenHat.style)
    );
    return constructHatRangeDescriptor(token, chosenHat);
  }).filter((value) => value != null);
}
function getTokenOldHatMap(oldTokenHats) {
  const tokenOldHatMap = new CompositeKeyMap(
    ({ editor, offsets }) => [editor.id, offsets.start, offsets.end]
  );
  oldTokenHats.forEach(
    (descriptor) => tokenOldHatMap.set(descriptor.token, descriptor)
  );
  return tokenOldHatMap;
}
function getTokenRemainingHatCandidates(tokenGraphemeSplitter2, token, graphemeRemainingHatCandidates, enabledHatStyles) {
  const candidates = [];
  const graphemes = tokenGraphemeSplitter2.getTokenGraphemes(token.text);
  for (const grapheme of graphemes) {
    for (const style of graphemeRemainingHatCandidates.get(grapheme.text)) {
      candidates.push({
        grapheme,
        style,
        penalty: enabledHatStyles[style].penalty
      });
    }
  }
  return candidates;
}
function constructHatRangeDescriptor(token, chosenHat) {
  return {
    hatStyle: chosenHat.style,
    grapheme: chosenHat.grapheme.text,
    token,
    hatRange: new Range(
      token.range.start.translate(
        void 0,
        chosenHat.grapheme.tokenStartOffset
      ),
      token.range.start.translate(void 0, chosenHat.grapheme.tokenEndOffset)
    )
  };
}

// ../cursorless-engine/src/core/Debouncer.ts
var Debouncer = class {
  constructor(callback2, debounceDelayMs) {
    this.callback = callback2;
    this.debounceDelayMs = debounceDelayMs;
    this.timeoutHandle = null;
    this.run = this.run.bind(this);
  }
  run() {
    if (this.timeoutHandle != null) {
      clearTimeout(this.timeoutHandle);
    }
    const decorationDebounceDelayMs = this.debounceDelayMs ?? ide().configuration.getOwnConfiguration("decorationDebounceDelayMs");
    this.timeoutHandle = setTimeout(() => {
      this.callback();
      this.timeoutHandle = null;
    }, decorationDebounceDelayMs);
  }
  dispose() {
    if (this.timeoutHandle != null) {
      clearTimeout(this.timeoutHandle);
    }
  }
};

// ../cursorless-engine/src/core/HatAllocator.ts
var HatAllocator = class {
  constructor(hats, context) {
    this.hats = hats;
    this.context = context;
    this.disposables = [];
    this.debouncer = new Debouncer(() => this.allocateHats());
    ide().disposeOnExit(this);
    this.disposables.push(
      this.hats.onDidChangeEnabledHatStyles(this.debouncer.run),
      this.hats.onDidChangeIsEnabled(this.debouncer.run),
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(this.debouncer.run),
      // An event that fires when a text document closes
      ide().onDidCloseTextDocument(this.debouncer.run),
      // An Event which fires when the active editor has changed. Note that the event also fires when the active editor changes to undefined.
      ide().onDidChangeActiveTextEditor(this.debouncer.run),
      // An Event which fires when the array of visible editors has changed.
      ide().onDidChangeVisibleTextEditors(this.debouncer.run),
      // An event that is emitted when a text document is changed. This usually happens when the contents changes but also when other things like the dirty-state changes.
      ide().onDidChangeTextDocument(this.debouncer.run),
      // An Event which fires when the selection in an editor has changed.
      ide().onDidChangeTextEditorSelection(this.debouncer.run),
      // An Event which fires when the visible ranges of an editor has changed.
      ide().onDidChangeTextEditorVisibleRanges(this.debouncer.run),
      // Re-draw hats on grapheme splitting algorithm change in case they
      // changed their token hat splitting setting.
      tokenGraphemeSplitter().registerAlgorithmChangeListener(
        this.debouncer.run
      ),
      this.debouncer
    );
  }
  /**
   * Allocate hats to the visible tokens.
   *
   * @param oldTokenHats If supplied, pretend that this allocation was the
   * previous allocation when trying to maintain stable hats.  This parameter is
   * used for testing.
   */
  async allocateHats(oldTokenHats) {
    const activeMap = await this.context.getActiveMap();
    const tokenHats = this.hats.isEnabled ? allocateHats(
      tokenGraphemeSplitter(),
      this.hats.enabledHatStyles,
      oldTokenHats ?? activeMap.tokenHats,
      ide().configuration.getOwnConfiguration("experimental.hatStability"),
      ide().activeTextEditor,
      ide().visibleTextEditors
    ) : [];
    activeMap.setTokenHats(tokenHats);
    await this.hats.setHatRanges(
      tokenHats.map(({ hatStyle, hatRange, token: { editor } }) => ({
        editor,
        range: hatRange,
        styleName: hatStyle
      }))
    );
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => dispose());
  }
};

// ../cursorless-engine/src/core/IndividualHatMap.ts
var IndividualHatMap = class _IndividualHatMap {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.isExpired = false;
    this.documentTokenLists = /* @__PURE__ */ new Map();
    this.deregisterFunctions = [];
    this.map = {};
    this._tokenHats = [];
  }
  get tokenHats() {
    return this._tokenHats;
  }
  getDocumentTokenList(document) {
    const key = document.uri.toString();
    let currentValue = this.documentTokenLists.get(key);
    if (currentValue == null) {
      currentValue = [];
      this.documentTokenLists.set(key, currentValue);
      this.deregisterFunctions.push(
        this.rangeUpdater.registerRangeInfoList(document, currentValue)
      );
    }
    return currentValue;
  }
  clone() {
    const ret = new _IndividualHatMap(this.rangeUpdater);
    ret.setTokenHats(this._tokenHats);
    return ret;
  }
  /**
   * Overwrites the hat assignemnt for this hat token map.
   *
   * @param tokenHats The new hat assignments
   */
  setTokenHats(tokenHats) {
    this.map = {};
    this.documentTokenLists = /* @__PURE__ */ new Map();
    this.deregisterFunctions.forEach((func) => func());
    const liveTokenHats = tokenHats.map((tokenHat) => {
      const { hatStyle, grapheme, token } = tokenHat;
      const liveToken = this.makeTokenLive(token);
      this.map[getKey(hatStyle, grapheme)] = liveToken;
      return { ...tokenHat, token: liveToken };
    });
    this._tokenHats = liveTokenHats;
  }
  makeTokenLive(token) {
    const { tokenMatcher } = getMatcher(token.editor.document.languageId);
    const liveToken = {
      ...token,
      expansionBehavior: {
        start: {
          type: "regex",
          regex: tokenMatcher
        },
        end: {
          type: "regex",
          regex: tokenMatcher
        }
      }
    };
    this.getDocumentTokenList(token.editor.document).push(liveToken);
    return liveToken;
  }
  getEntries() {
    this.checkExpired();
    return Object.entries(this.map);
  }
  getToken(hatStyle, character) {
    this.checkExpired();
    return this.map[getKey(hatStyle, tokenGraphemeSplitter().normalizeGrapheme(character))];
  }
  checkExpired() {
    if (this.isExpired) {
      throw Error("Map snapshot has expired");
    }
  }
  dispose() {
    this.isExpired = true;
    this.deregisterFunctions.forEach((func) => func());
  }
};

// ../cursorless-engine/src/core/HatTokenMapImpl.ts
var PRE_PHRASE_SNAPSHOT_MAX_AGE_NS = BigInt(6e10);
var HatTokenMapImpl = class {
  constructor(rangeUpdater, debug, hats, commandServerApi) {
    this.debug = debug;
    this.commandServerApi = commandServerApi;
    this.prePhraseMapsSnapshotTimestamp = null;
    this.lastSignalVersion = null;
    ide().disposeOnExit(this);
    this.activeMap = new IndividualHatMap(rangeUpdater);
    this.getActiveMap = this.getActiveMap.bind(this);
    this.allocateHats = this.allocateHats.bind(this);
    this.hatAllocator = new HatAllocator(hats, {
      getActiveMap: this.getActiveMap
    });
  }
  /**
   * Allocate hats to the visible tokens.
   *
   * @param oldTokenHats If supplied, pretend that this allocation was the
   * previous allocation when trying to maintain stable hats.  This parameter is
   * used for testing.
   */
  allocateHats(oldTokenHats) {
    return this.hatAllocator.allocateHats(oldTokenHats);
  }
  async getActiveMap() {
    await this.maybeTakePrePhraseSnapshot();
    return this.activeMap;
  }
  /**
   * Returns a transient, read-only hat map for use during the course of a
   * single command.
   *
   * Please do not hold onto this copy beyond the lifetime of a single command,
   * because it will get stale.
   * @param usePrePhraseSnapshot Whether to use pre-phrase snapshot
   * @returns A readable snapshot of the map
   */
  async getReadableMap(usePrePhraseSnapshot) {
    await this.maybeTakePrePhraseSnapshot();
    if (usePrePhraseSnapshot) {
      if (this.lastSignalVersion == null) {
        console.error(
          "Pre phrase snapshot requested but no signal was present; please upgrade command client"
        );
        return this.activeMap;
      }
      if (this.prePhraseMapSnapshot == null) {
        console.error(
          "Navigation map pre-phrase snapshot requested, but no snapshot has been taken"
        );
        return this.activeMap;
      }
      if (abs(import_process.hrtime.bigint() - this.prePhraseMapsSnapshotTimestamp) > PRE_PHRASE_SNAPSHOT_MAX_AGE_NS) {
        console.error(
          "Navigation map pre-phrase snapshot requested, but snapshot is more than a minute old"
        );
        return this.activeMap;
      }
      return this.prePhraseMapSnapshot;
    }
    return this.activeMap;
  }
  dispose() {
    this.activeMap.dispose();
    if (this.prePhraseMapSnapshot != null) {
      this.prePhraseMapSnapshot.dispose();
    }
  }
  async maybeTakePrePhraseSnapshot() {
    const phraseStartSignal = this.commandServerApi?.signals?.prePhrase;
    if (phraseStartSignal != null) {
      const newSignalVersion = await phraseStartSignal.getVersion();
      if (newSignalVersion !== this.lastSignalVersion) {
        this.debug.log("taking snapshot");
        this.lastSignalVersion = newSignalVersion;
        if (newSignalVersion != null) {
          this.takePrePhraseSnapshot();
        }
      }
    }
  }
  takePrePhraseSnapshot() {
    if (this.prePhraseMapSnapshot != null) {
      this.prePhraseMapSnapshot.dispose();
    }
    this.prePhraseMapSnapshot = this.activeMap.clone();
    this.prePhraseMapsSnapshotTimestamp = import_process.hrtime.bigint();
  }
};

// ../cursorless-engine/src/core/Snippets.ts
var import_promises2 = require("fs/promises");
var import_lodash19 = __toESM(require_lodash(), 1);
var import_path = require("path");

// ../cursorless-engine/src/core/mergeSnippets.ts
var import_lodash18 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/core/compareSnippetDefinitions.ts
function compareSnippetDefinitions(a, b) {
  const scopeComparision = compareSnippetScopes(
    a.definition.scope,
    b.definition.scope
  );
  if (scopeComparision !== 0) {
    return scopeComparision;
  }
  return a.origin - b.origin;
}
function compareSnippetScopes(a, b) {
  if (a == null && b == null) {
    return 0;
  }
  if (a == null) {
    return -1;
  }
  if (b == null) {
    return 1;
  }
  if (a.langIds == null && b.langIds != null) {
    return -1;
  }
  if (b.langIds == null && a.langIds != null) {
    return 1;
  }
  const scopeTypesComparision = compareScopeTypes(a.scopeTypes, b.scopeTypes);
  if (scopeTypesComparision !== 0) {
    return scopeTypesComparision;
  }
  return a.langIds == null ? 0 : b.langIds.length - a.langIds.length;
}
function compareScopeTypes(a, b) {
  if (a == null && b != null) {
    return -1;
  }
  if (b == null && a != null) {
    return 1;
  }
  return 0;
}

// ../cursorless-engine/src/core/mergeSnippets.ts
function mergeSnippets(coreSnippets, thirdPartySnippets, userSnippets) {
  const mergedSnippets = {};
  const mergedMap = (0, import_lodash18.mapValues)(
    (0, import_lodash18.groupBy)(
      [
        ...prepareSnippetsFromOrigin(0 /* core */, coreSnippets),
        ...prepareSnippetsFromOrigin(
          1 /* thirdParty */,
          ...Object.values(thirdPartySnippets)
        ),
        ...prepareSnippetsFromOrigin(2 /* user */, ...userSnippets)
      ],
      ([key]) => key
    ),
    (entries) => entries.map(([, value]) => value)
  );
  Object.entries(mergedMap).forEach(([key, snippets]) => {
    const mergedSnippet = (0, import_lodash18.merge)(
      {},
      ...snippets.sort((a, b) => a.origin - b.origin).map(({ snippet: snippet2 }) => snippet2)
    );
    mergedSnippet.definitions = snippets.flatMap(
      ({ origin, snippet: snippet2 }) => snippet2.definitions.map((definition) => ({ origin, definition }))
    ).sort((a, b) => -compareSnippetDefinitions(a, b)).map(({ definition }) => definition);
    mergedSnippets[key] = mergedSnippet;
  });
  return mergedSnippets;
}
function prepareSnippetsFromOrigin(origin, ...snippetMaps) {
  return snippetMaps.map(
    (snippetMap) => (0, import_lodash18.mapValues)((0, import_lodash18.cloneDeep)(snippetMap), (snippet2) => ({
      origin,
      snippet: snippet2
    }))
  ).flatMap((snippetMap) => Object.entries(snippetMap));
}

// ../cursorless-engine/src/core/Snippets.ts
var CURSORLESS_SNIPPETS_SUFFIX = ".cursorless-snippets";
var SNIPPET_DIR_REFRESH_INTERVAL_MS = 1e3;
var Snippets = class {
  constructor() {
    this.thirdPartySnippets = {};
    /**
     * The maximum modification time of any snippet in user snippets dir.
     *
     * This variable will be set to -1 if no user snippets have yet been read or
     * if the user snippets path has changed.
     *
     * This variable will be set to 0 if the user has no snippets dir configured and
     * we've already set userSnippets to {}.
     */
    this.maxSnippetMtimeMs = -1;
    /**
     * If the user has misconfigured their snippet dir, then we keep track of it
     * so that we can show them the error message if we can't find a snippet
     * later, and so that we don't show them the same error message every time
     * we try to poll the directory.
     */
    this.directoryErrorMessage = null;
    this.updateUserSnippetsPath();
    this.updateUserSnippets = this.updateUserSnippets.bind(this);
    this.registerThirdPartySnippets = this.registerThirdPartySnippets.bind(this);
    const timer = setInterval(
      this.updateUserSnippets,
      SNIPPET_DIR_REFRESH_INTERVAL_MS
    );
    ide().disposeOnExit(
      ide().configuration.onDidChangeConfiguration(() => {
        if (this.updateUserSnippetsPath()) {
          this.updateUserSnippets();
        }
      }),
      {
        dispose() {
          clearInterval(timer);
        }
      }
    );
  }
  async init() {
    const extensionPath = ide().assetsRoot;
    const snippetsDir = (0, import_path.join)(extensionPath, "cursorless-snippets");
    const snippetFiles = await getSnippetPaths(snippetsDir);
    this.coreSnippets = mergeStrict(
      ...await Promise.all(
        snippetFiles.map(
          async (path8) => JSON.parse(await (0, import_promises2.readFile)(path8, "utf8"))
        )
      )
    );
    await this.updateUserSnippets();
  }
  /**
   * Updates the userSnippetsDir field if it has change, returning a boolean
   * indicating whether there was an update.  If there was an update, resets the
   * maxSnippetMtime to -1 to ensure snippet update.
   * @returns Boolean indicating whether path has changed
   */
  updateUserSnippetsPath() {
    const newUserSnippetsDir = ide().configuration.getOwnConfiguration(
      "experimental.snippetsDir"
    );
    if (newUserSnippetsDir === this.userSnippetsDir) {
      return false;
    }
    this.maxSnippetMtimeMs = -1;
    this.userSnippetsDir = newUserSnippetsDir;
    return true;
  }
  async updateUserSnippets() {
    let snippetFiles;
    try {
      snippetFiles = this.userSnippetsDir ? await getSnippetPaths(this.userSnippetsDir) : [];
    } catch (err) {
      if (this.directoryErrorMessage?.directory !== this.userSnippetsDir) {
        const errorMessage = `Error with cursorless snippets dir "${this.userSnippetsDir}": ${err.message}`;
        showError(ide().messages, "snippetsDirError", errorMessage);
        this.directoryErrorMessage = {
          directory: this.userSnippetsDir,
          errorMessage
        };
      }
      this.userSnippets = [];
      this.mergeSnippets();
      return;
    }
    this.directoryErrorMessage = null;
    const maxSnippetMtime = (0, import_lodash19.max)(
      (await Promise.all(snippetFiles.map((file) => (0, import_promises2.stat)(file)))).map(
        (stat2) => stat2.mtimeMs
      )
    ) ?? 0;
    if (maxSnippetMtime <= this.maxSnippetMtimeMs) {
      return;
    }
    this.maxSnippetMtimeMs = maxSnippetMtime;
    this.userSnippets = await Promise.all(
      snippetFiles.map(async (path8) => {
        try {
          const content = await (0, import_promises2.readFile)(path8, "utf8");
          if (content.length === 0) {
            return {};
          }
          return JSON.parse(content);
        } catch (err) {
          showError(
            ide().messages,
            "snippetsFileError",
            `Error with cursorless snippets file "${path8}": ${err.message}`
          );
          return {};
        }
      })
    );
    this.mergeSnippets();
  }
  /**
   * Allows extensions to register third-party snippets.  Calling this function
   * twice with the same extensionId will replace the older snippets.
   *
   * Note that third-party snippets take precedence over core snippets, but
   * user snippets take precedence over both.
   * @param extensionId The id of the extension registering the snippets.
   * @param snippets The snippets to be registered.
   */
  registerThirdPartySnippets(extensionId, snippets) {
    this.thirdPartySnippets[extensionId] = snippets;
    this.mergeSnippets();
  }
  /**
   * Merge core, third-party, and user snippets, with precedence user > third
   * party > core.
   */
  mergeSnippets() {
    this.mergedSnippets = mergeSnippets(
      this.coreSnippets,
      this.thirdPartySnippets,
      this.userSnippets
    );
  }
  /**
   * Looks in merged collection of snippets for a snippet with key
   * `snippetName`. Throws an exception if the snippet of the given name could
   * not be found
   * @param snippetName The name of the snippet to look up
   * @returns The named snippet
   */
  getSnippetStrict(snippetName) {
    const snippet2 = this.mergedSnippets[snippetName];
    if (snippet2 == null) {
      let errorMessage = `Couldn't find snippet ${snippetName}. `;
      if (this.directoryErrorMessage != null) {
        errorMessage += `This could be due to: ${this.directoryErrorMessage.errorMessage}.`;
      }
      throw Error(errorMessage);
    }
    return snippet2;
  }
};
function getSnippetPaths(snippetsDir) {
  return walkFiles(snippetsDir, CURSORLESS_SNIPPETS_SUFFIX);
}

// ../cursorless-engine/src/core/updateSelections/RangeUpdater.ts
var import_lodash21 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/map.ts
function getDefault(map4, key, factory) {
  let currentValue = map4.get(key);
  if (currentValue == null) {
    currentValue = factory();
    map4.set(key, currentValue);
  }
  return currentValue;
}

// ../cursorless-engine/src/core/updateSelections/updateRangeInfos.ts
var import_lodash20 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/core/updateSelections/getOffsetsForDeleteOrReplace.ts
var import_immutability_helper2 = __toESM(require_immutability_helper(), 1);
function getOffsetsForDeleteOrReplace(changeEventInfo, rangeInfo) {
  const {
    originalOffsets: {
      start: changeOriginalStartOffset,
      end: changeOriginalEndOffset
    },
    finalOffsets: { end: changeFinalEndOffset },
    displacement
  } = changeEventInfo;
  const {
    offsets: { start: rangeStart, end: rangeEnd }
  } = rangeInfo;
  (0, import_immutability_helper2.invariant)(
    changeOriginalEndOffset > changeOriginalStartOffset,
    () => "Change range expected to be nonempty"
  );
  (0, import_immutability_helper2.invariant)(
    changeOriginalEndOffset >= rangeStart && changeOriginalStartOffset <= rangeEnd,
    () => "Change range expected to intersect with selection range"
  );
  return {
    start: changeOriginalEndOffset <= rangeStart ? rangeStart + displacement : Math.min(rangeStart, changeFinalEndOffset),
    end: changeOriginalEndOffset <= rangeEnd ? rangeEnd + displacement : Math.min(rangeEnd, changeFinalEndOffset)
  };
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForEmptyRangeInsert.ts
var import_immutability_helper3 = __toESM(require_immutability_helper(), 1);
function getOffsetsForEmptyRangeInsert(changeEventInfo, rangeInfo) {
  const {
    event: { text, isReplace: isReplace3 },
    finalOffsets: { start, end }
  } = changeEventInfo;
  (0, import_immutability_helper3.invariant)(
    start === changeEventInfo.originalOffsets.end && start === rangeInfo.offsets.start && start === rangeInfo.offsets.end,
    () => "Selection range and change range expected to be same empty range"
  );
  if (isReplace3) {
    const expansionBehavior = rangeInfo.expansionBehavior.end;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start,
          end: start
        };
      case "open":
        return { start, end };
      case "regex": {
        const matches = text.match(leftAnchored(expansionBehavior.regex));
        return matches == null ? {
          start,
          end: start
        } : {
          start,
          end: start + matches[0].length
        };
      }
    }
  } else {
    const expansionBehavior = rangeInfo.expansionBehavior.start;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: end,
          end
        };
      case "open":
        return { start, end };
      case "regex": {
        const index = text.search(rightAnchored(expansionBehavior.regex));
        return index === -1 ? {
          start: end,
          end
        } : {
          start: start + index,
          end
        };
      }
    }
  }
}

// ../cursorless-engine/src/core/updateSelections/getOffsetsForNonEmptyRangeInsert.ts
var import_immutability_helper4 = __toESM(require_immutability_helper(), 1);
function getOffsetsForNonEmptyRangeInsert(changeEventInfo, rangeInfo) {
  const {
    event: { text: insertedText },
    originalOffsets: { start: insertOffset },
    displacement
  } = changeEventInfo;
  const {
    offsets: { start: rangeStart, end: rangeEnd },
    text: originalRangeText
  } = rangeInfo;
  (0, import_immutability_helper4.invariant)(
    rangeEnd > rangeStart,
    () => "Selection range expected to be nonempty"
  );
  (0, import_immutability_helper4.invariant)(
    insertOffset >= rangeStart && insertOffset <= rangeEnd,
    () => "Insertion offset expected to intersect with selection range"
  );
  if (insertOffset > rangeStart && insertOffset < rangeEnd) {
    return { start: rangeStart, end: rangeEnd + displacement };
  }
  if (insertOffset === rangeStart) {
    const expansionBehavior = rangeInfo.expansionBehavior.start;
    const newRangeEnd = rangeEnd + displacement;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: rangeStart + displacement,
          end: newRangeEnd
        };
      case "open":
        return {
          start: rangeStart,
          end: newRangeEnd
        };
      case "regex": {
        let text = insertedText + originalRangeText;
        const regex = rightAnchored(expansionBehavior.regex);
        let index = text.search(regex);
        while (index > insertedText.length) {
          text = text.slice(0, index);
          index = text.search(regex);
        }
        return index === -1 ? {
          start: rangeStart,
          end: newRangeEnd
        } : {
          start: rangeStart + index,
          end: newRangeEnd
        };
      }
    }
  } else {
    const expansionBehavior = rangeInfo.expansionBehavior.end;
    const newRangeStart = rangeStart;
    switch (expansionBehavior.type) {
      case "closed":
        return {
          start: newRangeStart,
          end: rangeEnd
        };
      case "open":
        return {
          start: newRangeStart,
          end: rangeEnd + displacement
        };
      case "regex": {
        let text = originalRangeText + insertedText;
        const regex = leftAnchored(expansionBehavior.regex);
        let matches = text.match(regex);
        let matchLength = matches == null ? 0 : matches[0].length;
        while (matchLength !== 0 && matchLength < originalRangeText.length) {
          text = originalRangeText.slice(matchLength) + insertedText;
          matches = text.match(regex);
          matchLength = matches == null ? 0 : matchLength + matches[0].length;
        }
        return matchLength === 0 ? {
          start: newRangeStart,
          end: rangeEnd
        } : {
          start: newRangeStart,
          end: rangeStart + matchLength
        };
      }
    }
  }
}

// ../cursorless-engine/src/core/updateSelections/getUpdatedText.ts
function getUpdatedText(changeEventInfo, rangeInfo, newOffsets) {
  const { start: changeOriginalOffsetsStart, end: changeOriginalOffsetsEnd } = changeEventInfo.originalOffsets;
  const { start: rangeOriginalOffsetsStart, end: rangeOriginalOffsetsEnd } = rangeInfo.offsets;
  const newTextStartOffset = Math.min(
    changeOriginalOffsetsStart,
    rangeOriginalOffsetsStart
  );
  let result = "";
  if (rangeOriginalOffsetsStart < changeOriginalOffsetsStart) {
    result += rangeInfo.text.substring(
      0,
      changeOriginalOffsetsStart - rangeOriginalOffsetsStart
    );
  }
  result += changeEventInfo.event.text;
  if (changeOriginalOffsetsEnd < rangeOriginalOffsetsEnd) {
    result += rangeInfo.text.substring(
      rangeOriginalOffsetsEnd - changeOriginalOffsetsEnd,
      rangeInfo.text.length
    );
  }
  return result.substring(
    newOffsets.start - newTextStartOffset,
    newOffsets.end - newTextStartOffset
  );
}

// ../cursorless-engine/src/core/updateSelections/updateRangeInfos.ts
function updateRangeInfos(changeEvent, rangeInfoGenerator) {
  const { document, contentChanges } = changeEvent;
  const changeEventInfos = contentChanges.map((change) => {
    const changeDisplacement = change.text.length - change.rangeLength;
    const changeOriginalStartOffset = change.rangeOffset;
    const changeOriginalEndOffset = changeOriginalStartOffset + change.rangeLength;
    const changeFinalStartOffset = changeOriginalStartOffset;
    const changeFinalEndOffset = changeOriginalEndOffset + changeDisplacement;
    return {
      displacement: changeDisplacement,
      event: change,
      originalOffsets: {
        start: changeOriginalStartOffset,
        end: changeOriginalEndOffset
      },
      finalOffsets: {
        start: changeFinalStartOffset,
        end: changeFinalEndOffset
      }
    };
  });
  for (const rangeInfo of rangeInfoGenerator) {
    const originalOffsets = rangeInfo.offsets;
    const displacements = changeEventInfos.map((changeEventInfo) => {
      let newOffsets2;
      if (changeEventInfo.originalOffsets.start > originalOffsets.end) {
        return {
          start: 0,
          end: 0
        };
      }
      if (changeEventInfo.originalOffsets.end < originalOffsets.start) {
        return {
          start: changeEventInfo.displacement,
          end: changeEventInfo.displacement
        };
      }
      if (changeEventInfo.event.rangeLength === 0) {
        if (rangeInfo.range.isEmpty) {
          newOffsets2 = getOffsetsForEmptyRangeInsert(
            changeEventInfo,
            rangeInfo
          );
        } else {
          newOffsets2 = getOffsetsForNonEmptyRangeInsert(
            changeEventInfo,
            rangeInfo
          );
        }
      } else {
        newOffsets2 = getOffsetsForDeleteOrReplace(changeEventInfo, rangeInfo);
      }
      rangeInfo.text = getUpdatedText(changeEventInfo, rangeInfo, newOffsets2);
      return {
        start: newOffsets2.start - originalOffsets.start,
        end: newOffsets2.end - originalOffsets.end
      };
    });
    const newOffsets = {
      start: originalOffsets.start + (0, import_lodash20.sumBy)(displacements, ({ start }) => start),
      end: originalOffsets.end + (0, import_lodash20.sumBy)(displacements, ({ end }) => end)
    };
    rangeInfo.range = rangeInfo.range.with(
      document.positionAt(newOffsets.start),
      document.positionAt(newOffsets.end)
    );
    rangeInfo.offsets = newOffsets;
  }
}

// ../cursorless-engine/src/core/updateSelections/RangeUpdater.ts
var RangeUpdater = class {
  constructor() {
    this.rangeInfoLists = /* @__PURE__ */ new Map();
    this.replaceEditLists = /* @__PURE__ */ new Map();
    this.listenForDocumentChanges();
  }
  getDocumentRangeInfoLists(document) {
    return getDefault(this.rangeInfoLists, document.uri.toString(), () => []);
  }
  getDocumentReplaceEditLists(document) {
    return getDefault(this.replaceEditLists, document.uri.toString(), () => []);
  }
  /**
   * Registers a list of range infos to be kept up to date.  It is ok to
   * add to this list after registering it; any items in the list at the time of
   * a document change will be kept up to date.  Please be sure to call the
   * returned deregister function when you no longer need the ranges
   * updated.
   * @param document The document containing the ranges
   * @param rangeInfoList The ranges to keep up to date; it is ok to add to this list after the fact
   * @returns A function that can be used to deregister the list
   */
  registerRangeInfoList(document, rangeInfoList) {
    const documentRangeInfoLists = this.getDocumentRangeInfoLists(document);
    documentRangeInfoLists.push(rangeInfoList);
    return () => (0, import_lodash21.pull)(documentRangeInfoLists, rangeInfoList);
  }
  /**
   * Registers a list of edits to treat as replace edits. These edits are
   * insertions that will not shift an empty selection to the right. Call this
   * function before applying your edits to the document
   *
   * Note that if you make two edits at the same location with the same text,
   * it is not possible to mark only one of them as replace edit.
   *
   * It is ok to add to this list after registering it; any items in the list
   * at the time of a document change will be treated as replace edits.  Please
   * be sure to call the returned deregister function after you have waited for
   * your edits to be applied.
   * @param document The document containing the ranges
   * @param replaceEditList A list of edits to treat as replace edits; it is ok to add to this list after the fact
   * @returns A function that can be used to deregister the list
   */
  registerReplaceEditList(document, replaceEditList) {
    const documentReplaceEditLists = this.getDocumentReplaceEditLists(document);
    documentReplaceEditLists.push(replaceEditList);
    return () => (0, import_lodash21.pull)(documentReplaceEditLists, replaceEditList);
  }
  *documentRangeInfoGenerator(document) {
    const documentRangeInfoLists = this.getDocumentRangeInfoLists(document);
    for (const rangeInfoLists of documentRangeInfoLists) {
      for (const rangeInfo of rangeInfoLists) {
        yield rangeInfo;
      }
    }
  }
  listenForDocumentChanges() {
    this.disposable = ide().onDidChangeTextDocument(
      (event) => {
        const changes = event.contentChanges;
        console.debug(
          `RangeUpdater.listenForDocumentChanges(): changes=${JSON.stringify(changes)}`
        );
        const documentReplaceEditLists = this.getDocumentReplaceEditLists(
          event.document
        );
        const extendedEvent = {
          ...event,
          contentChanges: event.contentChanges.map(
            (change) => isReplace(documentReplaceEditLists, change) ? {
              ...change,
              isReplace: true
            } : change
          )
        };
        updateRangeInfos(
          extendedEvent,
          this.documentRangeInfoGenerator(event.document)
        );
      }
    );
  }
  dispose() {
    this.disposable.dispose();
  }
};
function isReplace(documentReplaceEditLists, change) {
  for (const replaceEditLists of documentReplaceEditLists) {
    for (const replaceEdit of replaceEditLists) {
      if (replaceEdit.range.isRangeEqual(change.range) && replaceEdit.text === change.text) {
        return true;
      }
    }
  }
  return false;
}

// ../cursorless-engine/src/spokenForms/CustomSpokenForms.ts
var import_lodash22 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/scopeProviders/TalonSpokenForms.ts
var SUPPORTED_ENTRY_TYPES = [
  "simpleScopeTypeType",
  "complexScopeTypeType",
  "customRegex",
  "pairedDelimiter"
];
var NeedsInitialTalonUpdateError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NeedsInitialTalonUpdateError";
  }
};

// ../cursorless-engine/src/spokenForms/CustomSpokenForms.ts
var CustomSpokenForms = class {
  constructor(talonSpokenForms) {
    this.talonSpokenForms = talonSpokenForms;
    this.notifier = new Notifier();
    this.spokenFormMap_ = { ...defaultSpokenFormMap };
    /**
     * Registers a callback to be run when the custom spoken forms change.
     * @param callback The callback to run when the scope ranges change
     * @returns A {@link Disposable} which will stop the callback from running
     */
    this.onDidChangeCustomSpokenForms = this.notifier.registerListener;
    this.disposable = talonSpokenForms.onDidChange(
      () => this.updateSpokenFormMaps().catch(() => {
      })
    );
    this.customSpokenFormsInitialized = this.updateSpokenFormMaps();
    this.customSpokenFormsInitialized.catch(() => {
    });
  }
  get spokenFormMap() {
    return this.spokenFormMap_;
  }
  /**
   * If `true`, indicates they need to update their Talon files to get the
   * machinery used to share spoken forms from Talon to the VSCode extension.
   */
  get needsInitialTalonUpdate() {
    return this.needsInitialTalonUpdate_;
  }
  async updateSpokenFormMaps() {
    let allCustomEntries;
    try {
      allCustomEntries = await this.talonSpokenForms.getSpokenFormEntries();
      if (allCustomEntries.length === 0) {
        throw new Error("Custom spoken forms list empty");
      }
    } catch (err) {
      if (err instanceof NeedsInitialTalonUpdateError) {
        this.needsInitialTalonUpdate_ = true;
      } else {
        console.error("Error loading custom spoken forms", err);
        showError(
          ide().messages,
          "CustomSpokenForms.updateSpokenFormMaps",
          `Error loading custom spoken forms: ${err.message}}}. Falling back to default spoken forms.`
        );
      }
      this.spokenFormMap_ = { ...defaultSpokenFormMap };
      this.notifier.notifyListeners();
      throw err;
    }
    for (const entryType of SUPPORTED_ENTRY_TYPES) {
      updateEntriesForType(
        this.spokenFormMap_,
        entryType,
        defaultSpokenFormInfoMap[entryType],
        Object.fromEntries(
          allCustomEntries.filter((entry2) => entry2.type === entryType).map(({ id, spokenForms }) => [id, spokenForms])
        )
      );
    }
    this.notifier.notifyListeners();
  }
  getCustomRegexScopeTypes() {
    return Object.keys(this.spokenFormMap_.customRegex).map((regex) => ({
      type: "customRegex",
      regex
    }));
  }
  dispose() {
    this.disposable.dispose();
  }
};
function updateEntriesForType(spokenFormMapToUpdate, key, defaultEntries, customEntries) {
  const ids = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(defaultEntries), ...Object.keys(customEntries)])
  );
  const obj = {};
  for (const id of ids) {
    const { defaultSpokenForms = [], isPrivate: isPrivate2 = false } = defaultEntries[id] ?? {};
    const customSpokenForms = customEntries[id];
    obj[id] = customSpokenForms == null ? (
      // No entry for the given id. This either means that the user needs to
      // update Talon, or it's a private spoken form.
      {
        defaultSpokenForms,
        spokenForms: [],
        // If it's not a private spoken form, then it's a new scope type
        requiresTalonUpdate: !isPrivate2,
        isCustom: false,
        isPrivate: isPrivate2
      }
    ) : (
      // We have an entry for the given id
      {
        defaultSpokenForms,
        spokenForms: customSpokenForms,
        requiresTalonUpdate: false,
        isCustom: !(0, import_lodash22.isEqual)(defaultSpokenForms, customSpokenForms),
        isPrivate: isPrivate2
      }
    );
  }
  spokenFormMapToUpdate[key] = obj;
}

// ../cursorless-engine/src/generateSpokenForm/CustomSpokenFormGeneratorImpl.ts
var CustomSpokenFormGeneratorImpl = class {
  constructor(talonSpokenForms) {
    this.customSpokenForms = new CustomSpokenForms(talonSpokenForms);
    this.customSpokenFormsInitialized = this.customSpokenForms.customSpokenFormsInitialized;
    this.spokenFormGenerator = new SpokenFormGenerator(
      this.customSpokenForms.spokenFormMap
    );
    this.disposable = this.customSpokenForms.onDidChangeCustomSpokenForms(
      () => {
        this.spokenFormGenerator = new SpokenFormGenerator(
          this.customSpokenForms.spokenFormMap
        );
      }
    );
  }
  onDidChangeCustomSpokenForms(listener) {
    return this.customSpokenForms.onDidChangeCustomSpokenForms(listener);
  }
  commandToSpokenForm(command) {
    return this.spokenFormGenerator.processCommand(command);
  }
  scopeTypeToSpokenForm(scopeType) {
    return this.spokenFormGenerator.processScopeType(scopeType);
  }
  getCustomRegexScopeTypes() {
    return this.customSpokenForms.getCustomRegexScopeTypes();
  }
  get needsInitialTalonUpdate() {
    return this.customSpokenForms.needsInitialTalonUpdate;
  }
  dispose() {
    this.disposable.dispose();
  }
};

// ../cursorless-engine/src/languages/LanguageDefinitions.ts
var import_path3 = require("path");

// ../cursorless-engine/src/languages/LanguageDefinition.ts
var import_path2 = require("path");

// ../../node_modules/.pnpm/itertools@2.2.5/node_modules/itertools/dist/index.js
function* flatten4(iterableOfIterables) {
  for (const iterable of iterableOfIterables) {
    for (const item of iterable) {
      yield item;
    }
  }
}
function* itake(n, iterable) {
  const it = iter(iterable);
  let count2 = n;
  while (count2-- > 0) {
    const s = it.next();
    if (!s.done) {
      yield s.value;
    } else {
      return;
    }
  }
}
function* pairwise(iterable) {
  const it = iter(iterable);
  const first2 = it.next();
  if (first2.done) {
    return;
  }
  let r1 = first2.value;
  for (const r2 of it) {
    yield [r1, r2];
    r1 = r2;
  }
}
var SENTINEL = Symbol();
function* count(start = 0, step = 1) {
  let n = start;
  for (; ; ) {
    yield n;
    n += step;
  }
}
function* ifilter(iterable, predicate) {
  for (const value of iterable) {
    if (predicate(value)) {
      yield value;
    }
  }
}
function* imap(iterable, mapper) {
  for (const value of iterable) {
    yield mapper(value);
  }
}
function* islice(iterable, stopOrStart, possiblyStop, step = 1) {
  let start, stop;
  if (possiblyStop !== void 0) {
    start = stopOrStart;
    stop = possiblyStop;
  } else {
    start = 0;
    stop = stopOrStart;
  }
  if (start < 0)
    throw new Error("start cannot be negative");
  if (stop !== null && stop < 0)
    throw new Error("stop cannot be negative");
  if (step <= 0)
    throw new Error("step cannot be negative");
  let i = -1;
  const it = iter(iterable);
  let res;
  while (true) {
    i++;
    if (stop !== null && i >= stop)
      return;
    res = it.next();
    if (res.done)
      return;
    if (i < start)
      continue;
    if ((i - start) % step === 0) {
      yield res.value;
    }
  }
}
function* takewhile(iterable, predicate) {
  const it = iter(iterable);
  let res;
  while (!(res = it.next()).done) {
    const value = res.value;
    if (!predicate(value))
      return;
    yield value;
  }
}
function iter(iterable) {
  return iterable[Symbol.iterator]();
}
function map2(iterable, mapper) {
  return Array.from(imap(iterable, mapper));
}
function range_(start, stop, step) {
  const counter = count(start, step);
  const pred = step >= 0 ? (n) => n < stop : (n) => n > stop;
  return takewhile(counter, pred);
}
function range2(startOrStop, definitelyStop, step = 1) {
  if (definitelyStop !== void 0) {
    return range_(startOrStop, definitelyStop, step);
  } else {
    return range_(0, startOrStop, step);
  }
}
function flatmap(iterable, mapper) {
  return flatten4(imap(iterable, mapper));
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/compareTargetScopes.ts
function compareTargetScopes(direction, position, { domain: a }, { domain: b }) {
  return direction === "forward" ? compareTargetScopesForward(position, a, b) : compareTargetScopesBackward(position, a, b);
}
function compareTargetScopesForward(position, a, b) {
  const aIsStartVisible = a.start.isAfterOrEqual(position);
  const bIsStartVisible = b.start.isAfterOrEqual(position);
  if (aIsStartVisible && bIsStartVisible) {
    const value2 = a.start.compareTo(b.start);
    return value2 === 0 ? a.end.compareTo(b.end) : value2;
  }
  if (!aIsStartVisible && !bIsStartVisible) {
    const value2 = a.end.compareTo(b.end);
    return value2 === 0 ? -a.start.compareTo(b.start) : value2;
  }
  if (!aIsStartVisible && bIsStartVisible) {
    const value2 = a.end.compareTo(b.start);
    return value2 !== 0 ? value2 : b.isEmpty ? 1 : -1;
  }
  const value = a.start.compareTo(b.end);
  return value !== 0 ? value : a.isEmpty ? -1 : 1;
}
function compareTargetScopesBackward(position, a, b) {
  const aIsEndVisible = a.end.isBeforeOrEqual(position);
  const bIsEndVisible = b.end.isBeforeOrEqual(position);
  if (aIsEndVisible && bIsEndVisible) {
    const value2 = -a.end.compareTo(b.end);
    return value2 === 0 ? -a.start.compareTo(b.start) : value2;
  }
  if (!aIsEndVisible && !bIsEndVisible) {
    const value2 = -a.start.compareTo(b.start);
    return value2 === 0 ? a.end.compareTo(b.end) : value2;
  }
  if (!aIsEndVisible && bIsEndVisible) {
    const value2 = -a.start.compareTo(b.end);
    return value2 !== 0 ? value2 : b.isEmpty ? 1 : -1;
  }
  const value = -a.end.compareTo(b.start);
  return value !== 0 ? value : a.isEmpty ? -1 : 1;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/shouldYieldScope.ts
function shouldYieldScope(initialPosition, currentPosition, direction, requirements, previousScope, scope) {
  return checkRequirements(initialPosition, requirements, previousScope, scope) && // Note that we're using `currentPosition` instead of `initialPosition`
  // below, because we want to filter out scopes that are strictly contained
  // by previous scopes.  However, if we want to include descendant scopes,
  // then we do use the initial position
  (previousScope == null || compareTargetScopes(
    direction,
    requirements.includeDescendantScopes ? initialPosition : currentPosition,
    previousScope,
    scope
  ) < 0);
}
function checkRequirements(position, requirements, previousScope, scope) {
  const {
    containment,
    distalPosition,
    allowAdjacentScopes,
    skipAncestorScopes
  } = requirements;
  const { domain } = scope;
  switch (containment) {
    case "disallowed":
      if (domain.contains(position)) {
        return false;
      }
      break;
    case "disallowedIfStrict":
      if (strictlyContains(domain, position)) {
        return false;
      }
      break;
    case "required":
      if (!domain.contains(position)) {
        return false;
      }
      break;
  }
  if (skipAncestorScopes && previousScope != null && domain.contains(previousScope.domain)) {
    return false;
  }
  return partiallyContains(
    new Range(position, distalPosition),
    domain,
    allowAdjacentScopes
  );
}
function partiallyContains(range1, range22, allowAdjacent) {
  const intersection = range1.intersection(range22);
  if (intersection == null) {
    return false;
  }
  return !intersection.isEmpty || allowAdjacent || range22.isEmpty;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/BaseScopeHandler.ts
var DEFAULT_REQUIREMENTS = {
  containment: null,
  allowAdjacentScopes: false,
  skipAncestorScopes: false,
  includeDescendantScopes: false
};
var BaseScopeHandler = class {
  constructor() {
    this.includeAdjacentInEvery = false;
  }
  *generateScopes(editor, position, direction, requirements = {}) {
    const hints = {
      ...DEFAULT_REQUIREMENTS,
      ...requirements,
      distalPosition: requirements.distalPosition ?? (direction === "forward" ? editor.document.range.end : editor.document.range.start)
    };
    let previousScope = void 0;
    let currentPosition = position;
    for (const scope of this.generateScopeCandidates(
      editor,
      position,
      direction,
      hints
    )) {
      if (shouldYieldScope(
        position,
        currentPosition,
        direction,
        hints,
        previousScope,
        scope
      )) {
        yield scope;
        previousScope = scope;
        currentPosition = direction === "forward" ? scope.domain.end : scope.domain.start;
      }
      if (this.canStopEarly(position, direction, hints, previousScope, scope)) {
        return;
      }
    }
  }
  canStopEarly(position, direction, requirements, previousScope, scope) {
    const { containment, distalPosition, skipAncestorScopes } = requirements;
    if (this.isHierarchical && !skipAncestorScopes) {
      return false;
    }
    const scopeToCheck = this.isHierarchical && skipAncestorScopes ? previousScope : scope;
    if (scopeToCheck == null) {
      return false;
    }
    if (containment === "required" && (direction === "forward" ? scopeToCheck.domain.end.isAfter(position) : scopeToCheck.domain.start.isBefore(position))) {
      return true;
    }
    if (direction === "forward" ? scopeToCheck.domain.end.isAfterOrEqual(distalPosition) : scopeToCheck.domain.start.isBeforeOrEqual(distalPosition)) {
      return true;
    }
    return false;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/NestedScopeHandler.ts
var NestedScopeHandler = class extends BaseScopeHandler {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super();
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.scopeType = scopeType;
    this.languageId = languageId;
    this.isHierarchical = false;
  }
  /**
   * We expand to this scope type before looking for instances of the scope type
   * handled by this scope handler.  In most cases the iteration scope will
   * suffice, but in some cases you want them to diverge.  For example, you
   * might want the default iteration scope to be `"file"`, but you don't need
   * to expand to the file just to find instances of the given scope type.
   */
  get searchScopeType() {
    return this.iterationScopeType;
  }
  get searchScopeHandler() {
    if (this._searchScopeHandler == null) {
      this._searchScopeHandler = this.scopeHandlerFactory.create(
        this.searchScopeType,
        this.languageId
      );
    }
    return this._searchScopeHandler;
  }
  generateScopeCandidates(editor, position, direction, hints) {
    const { containment, ...rest } = hints;
    const generator = this.searchScopeHandler.generateScopes(
      editor,
      position,
      direction,
      // If containment is disallowed, we need to unset that for the search
      // scope, because the search scope could contain position but nested
      // scopes do not.
      {
        containment: containment === "required" ? "required" : void 0,
        ...rest
      }
    );
    return flatmap(
      generator,
      (searchScope) => this.generateScopesInSearchScope(direction, searchScope)
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/LineScopeHandler.ts
var LineScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    this.scopeType = { type: "line" };
    this.iterationScopeType = {
      type: "paragraph"
    };
    this.isHierarchical = false;
    this.includeAdjacentInEvery = true;
  }
  *generateScopeCandidates(editor, position, direction) {
    if (direction === "forward") {
      for (let i = position.line; i < editor.document.lineCount; i++) {
        yield lineNumberToScope(editor, i);
      }
    } else {
      for (let i = position.line; i >= 0; i--) {
        yield lineNumberToScope(editor, i);
      }
    }
  }
};
function lineNumberToScope(editor, lineNumber) {
  const { range: range4 } = editor.document.lineAt(lineNumber);
  return {
    editor,
    domain: range4,
    getTargets: (isReversed) => [createLineTarget(editor, isReversed, range4)]
  };
}
function createLineTarget(editor, isReversed, range4) {
  return new LineTarget({
    editor,
    isReversed,
    contentRange: fitRangeToLineContent(editor, range4)
  });
}
function fitRangeToLineContent(editor, range4) {
  const startLine = editor.document.lineAt(range4.start);
  const endLine = editor.document.lineAt(range4.end);
  return new Range(
    startLine.lineNumber,
    startLine.firstNonWhitespaceCharacterIndex,
    endLine.lineNumber,
    endLine.lastNonWhitespaceCharacterIndex
  );
}

// ../cursorless-engine/src/util/getMatchesInRange.ts
function generateMatchesInRange(regex, editor, range4, direction) {
  const offset = editor.document.offsetAt(range4.start);
  const text = editor.document.getText(range4);
  const matchToRange = (match2) => new Range(
    editor.document.positionAt(offset + match2.index),
    editor.document.positionAt(offset + match2.index + match2[0].length)
  );
  regex.lastIndex = 0;
  return direction === "forward" ? imap(text.matchAll(regex), matchToRange) : Array.from(text.matchAll(regex), matchToRange).reverse();
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/IdentifierScopeHandler.ts
var IdentifierScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "identifier" };
    this.iterationScopeType = { type: "line" };
    this.regex = getMatcher(this.languageId).identifierMatcher;
  }
  generateScopesInSearchScope(direction, { editor, domain }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain, direction),
      (range4) => ({
        editor,
        domain: range4,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range4,
            isReversed
          })
        ]
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/isPreferredOverHelper.ts
function isPreferredOverHelper(scopeA, scopeB, matchers2) {
  const textA = scopeA.editor.document.getText(scopeA.domain);
  const textB = scopeB.editor.document.getText(scopeB.domain);
  for (const matcher2 of matchers2) {
    const aMatchesRegex = testRegex(matcher2, textA);
    const bMatchesRegex = testRegex(matcher2, textB);
    if (aMatchesRegex && !bMatchesRegex) {
      return true;
    }
    if (bMatchesRegex && !aMatchesRegex) {
      return false;
    }
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/CharacterScopeHandler.ts
var SPLIT_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}\p{Z}\p{C}]/gu;
var PREFERRED_SYMBOLS_REGEX = /[$]/g;
var NONWHITESPACE_REGEX = /\p{L}\p{M}*|[\p{N}\p{P}\p{S}]/gu;
var CharacterScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "character" };
    this.iterationScopeType = { type: "token" };
  }
  get searchScopeType() {
    return { type: "line" };
  }
  generateScopesInSearchScope(direction, { editor, domain }) {
    return imap(
      generateMatchesInRange(SPLIT_REGEX, editor, domain, direction),
      (range4) => ({
        editor,
        domain: range4,
        getTargets: (isReversed) => [
          new PlainTarget({
            editor,
            contentRange: range4,
            isReversed,
            isToken: false
          })
        ]
      })
    );
  }
  isPreferredOver(scopeA, scopeB) {
    const { identifierMatcher } = getMatcher(this.languageId);
    return isPreferredOverHelper(scopeA, scopeB, [
      identifierMatcher,
      PREFERRED_SYMBOLS_REGEX,
      NONWHITESPACE_REGEX
    ]);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/WordScopeHandler/WordTokenizer.ts
var CAMEL_REGEX = /\p{Lu}?\p{Ll}+|\p{Lu}+(?!\p{Ll})|\p{N}+/gu;
var WordTokenizer = class {
  constructor(languageId) {
    this.wordRegex = getMatcher(languageId).wordMatcher;
  }
  splitIdentifier(text) {
    const wordMatches = matchText(text, this.wordRegex);
    return wordMatches.length > 1 ? wordMatches : (
      // Secondly try split on camel case
      matchText(text, CAMEL_REGEX)
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/WordScopeHandler/WordScopeHandler.ts
var WordScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "word" };
    this.iterationScopeType = { type: "identifier" };
    this.wordTokenizer = new WordTokenizer(this.languageId);
  }
  getScopesInSearchScope({
    editor,
    domain
  }) {
    const { document } = editor;
    const offset = document.offsetAt(domain.start);
    const matches = this.wordTokenizer.splitIdentifier(
      document.getText(domain)
    );
    const contentRanges = matches.map(
      (match2) => new Range(
        document.positionAt(offset + match2.index),
        document.positionAt(offset + match2.index + match2.text.length)
      )
    );
    return contentRanges.map((range4, i) => ({
      editor,
      domain: range4,
      getTargets: (isReversed) => {
        const previousContentRange = i > 0 ? contentRanges[i - 1] : null;
        const nextContentRange = i + 1 < contentRanges.length ? contentRanges[i + 1] : null;
        return [
          constructTarget(
            isReversed,
            editor,
            previousContentRange,
            range4,
            nextContentRange
          )
        ];
      }
    }));
  }
  generateScopesInSearchScope(direction, searchScope) {
    const scopes = this.getScopesInSearchScope(searchScope);
    if (direction === "backward") {
      scopes.reverse();
    }
    return scopes;
  }
};
function constructTarget(isReversed, editor, previousContentRange, contentRange, nextContentRange) {
  const leadingDelimiterRange = previousContentRange != null && contentRange.start.isAfter(previousContentRange.end) ? new Range(previousContentRange.end, contentRange.start) : void 0;
  const trailingDelimiterRange = nextContentRange != null && nextContentRange.start.isAfter(contentRange.end) ? new Range(contentRange.end, nextContentRange.start) : void 0;
  const isInDelimitedList = leadingDelimiterRange != null || trailingDelimiterRange != null;
  const insertionDelimiter = isInDelimitedList ? editor.document.getText(
    leadingDelimiterRange ?? trailingDelimiterRange
  ) : "";
  return new SubTokenWordTarget({
    editor,
    isReversed,
    contentRange,
    insertionDelimiter,
    leadingDelimiterRange,
    trailingDelimiterRange
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TokenScopeHandler.ts
var PREFERRED_SYMBOLS_REGEX2 = /[$]/g;
var TokenScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "token" };
    this.iterationScopeType = { type: "line" };
    this.regex = getMatcher(this.languageId).tokenMatcher;
  }
  generateScopesInSearchScope(direction, { editor, domain }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain, direction),
      (range4) => ({
        editor,
        domain: range4,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range4,
            isReversed
          })
        ]
      })
    );
  }
  isPreferredOver(scopeA, scopeB) {
    const { identifierMatcher } = getMatcher(this.languageId);
    return isPreferredOverHelper(scopeA, scopeB, [
      identifierMatcher,
      PREFERRED_SYMBOLS_REGEX2
    ]);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/DocumentScopeHandler.ts
var DocumentScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    this.scopeType = { type: "document" };
    this.iterationScopeType = { type: "document" };
    this.isHierarchical = false;
  }
  *generateScopeCandidates(editor, _position, _direction) {
    const contentRange = editor.document.range;
    yield {
      editor,
      domain: contentRange,
      getTargets: (isReversed) => [
        new DocumentTarget({
          editor,
          isReversed,
          contentRange
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/BaseTreeSitterScopeHandler.ts
var import_lodash23 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/mergeAdjacentBy.ts
function mergeAdjacentBy(input, isEqual5, merge4) {
  const result = [];
  let current2 = [];
  for (const elem of input) {
    if (current2.length === 0 || isEqual5(current2[current2.length - 1], elem)) {
      current2.push(elem);
    } else {
      result.push(merge4(current2));
      current2 = [elem];
    }
  }
  if (current2.length > 0) {
    result.push(merge4(current2));
  }
  return result;
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/BaseTreeSitterScopeHandler.ts
var BaseTreeSitterScopeHandler = class extends BaseScopeHandler {
  constructor(query) {
    super();
    this.query = query;
  }
  *generateScopeCandidates(editor, position, direction, _hints) {
    const { document } = editor;
    const scopes = this.query.matches(document).map((match2) => this.matchToScope(editor, match2)).filter((scope) => scope != null).sort((a, b) => compareTargetScopes(direction, position, a, b));
    yield* mergeAdjacentBy(
      scopes,
      (a, b) => a.domain.isRangeEqual(b.domain),
      (equivalentScopes) => {
        if (equivalentScopes.length === 1) {
          return equivalentScopes[0];
        }
        return {
          ...equivalentScopes[0],
          getTargets(isReversed) {
            const targets = (0, import_lodash23.uniqWith)(
              equivalentScopes.flatMap((scope) => scope.getTargets(isReversed)),
              (a, b) => a.isEqual(b)
            );
            if (targets.length > 1 && !equivalentScopes.every((scope) => scope.allowMultiple)) {
              const message = "Please use #allow-multiple! predicate in your query to allow multiple matches for this scope type";
              showError(
                ide().messages,
                "BaseTreeSitterScopeHandler.allow-multiple",
                message
              );
              if (ide().runMode === "test") {
                throw Error(message);
              }
            }
            return targets;
          }
        };
      }
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/captureUtils.ts
function getRelatedCapture(match2, scopeTypeType, relationship, matchHasScopeType) {
  if (matchHasScopeType) {
    return findCaptureByName(
      match2,
      `${scopeTypeType}.${relationship}`,
      `_.${relationship}`
    );
  }
  return findCaptureByName(match2, `${scopeTypeType}.${relationship}`) ?? (findCaptureByName(match2, scopeTypeType) != null ? findCaptureByName(match2, `_.${relationship}`) : void 0);
}
function getRelatedRange(match2, scopeTypeType, relationship, matchHasScopeType) {
  return getRelatedCapture(
    match2,
    scopeTypeType,
    relationship,
    matchHasScopeType
  )?.range;
}
function findCaptureByName(match2, ...names) {
  return match2.captures.find(
    (capture) => names.some((name) => capture.name === name)
  );
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/TreeSitterIterationScopeHandler.ts
var TreeSitterIterationScopeHandler = class extends BaseTreeSitterScopeHandler {
  constructor(query, iterateeScopeType) {
    super(query);
    this.iterateeScopeType = iterateeScopeType;
    this.isHierarchical = true;
    // Doesn't correspond to any scope type
    this.scopeType = void 0;
  }
  // Doesn't have any iteration scope type itself; that would correspond to
  // something like "every every"
  get iterationScopeType() {
    throw Error("Not implemented");
  }
  matchToScope(editor, match2) {
    const scopeTypeType = this.iterateeScopeType.type;
    const capture = getRelatedCapture(match2, scopeTypeType, "iteration", false);
    if (capture == null) {
      return void 0;
    }
    const { range: contentRange, allowMultiple } = capture;
    const domain = getRelatedRange(match2, scopeTypeType, "iteration.domain", false) ?? contentRange;
    return {
      editor,
      domain,
      allowMultiple,
      getTargets: (isReversed) => [
        new PlainTarget({
          editor,
          isReversed,
          contentRange
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/TreeSitterScopeHandler.ts
var TreeSitterScopeHandler = class extends BaseTreeSitterScopeHandler {
  constructor(query, scopeType) {
    super(query);
    this.scopeType = scopeType;
    this.isHierarchical = true;
  }
  // We just create a custom scope handler that doesn't necessarily correspond
  // to any well-defined scope type
  get iterationScopeType() {
    return {
      type: "custom",
      scopeHandler: new TreeSitterIterationScopeHandler(
        this.query,
        this.scopeType
      )
    };
  }
  matchToScope(editor, match2) {
    const scopeTypeType = this.scopeType.type;
    const capture = findCaptureByName(match2, scopeTypeType);
    if (capture == null) {
      return void 0;
    }
    const { range: contentRange, allowMultiple, insertionDelimiter } = capture;
    const domain = getRelatedRange(match2, scopeTypeType, "domain", true) ?? contentRange;
    const removalRange = getRelatedRange(match2, scopeTypeType, "removal", true);
    const interiorRange = getRelatedRange(
      match2,
      scopeTypeType,
      "interior",
      true
    );
    const prefixRange = getRelatedRange(
      match2,
      scopeTypeType,
      "prefix",
      true
    )?.with(void 0, contentRange.start);
    const leadingDelimiterRange = getRelatedRange(
      match2,
      scopeTypeType,
      "leading",
      true
    )?.with(void 0, prefixRange?.start ?? contentRange.start);
    const trailingDelimiterRange = getRelatedRange(
      match2,
      scopeTypeType,
      "trailing",
      true
    )?.with(contentRange.end);
    return {
      editor,
      domain,
      allowMultiple,
      getTargets: (isReversed) => [
        new ScopeTypeTarget({
          scopeTypeType,
          editor,
          isReversed,
          contentRange,
          prefixRange,
          removalRange,
          leadingDelimiterRange,
          trailingDelimiterRange,
          interiorRange,
          insertionDelimiter
        })
      ]
    };
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/IteratorInfo.ts
function getInitialIteratorInfos(iterators) {
  return iterators.flatMap((iterator) => {
    const { value, done } = iterator.next();
    return done ? [] : [
      {
        iterator,
        value
      }
    ];
  });
}
function advanceIteratorsUntil(iteratorInfos, criterion) {
  return iteratorInfos.flatMap((iteratorInfo) => {
    const { iterator } = iteratorInfo;
    let { value } = iteratorInfo;
    let done = false;
    while (!criterion(value) && !done) {
      ({ value, done } = iterator.next());
    }
    if (done) {
      return [];
    }
    return [{ iterator, value }];
  });
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/OneOfScopeHandler.ts
var OneOfScopeHandler = class _OneOfScopeHandler extends BaseScopeHandler {
  constructor(scopeType, scopeHandlers, getIterationScopeType) {
    super();
    this.scopeType = scopeType;
    this.scopeHandlers = scopeHandlers;
    this.getIterationScopeType = getIterationScopeType;
    this.isHierarchical = true;
  }
  static create(scopeHandlerFactory, scopeType, languageId) {
    const scopeHandlers = scopeType.scopeTypes.map(
      (scopeType2) => {
        const handler = scopeHandlerFactory.create(scopeType2, languageId);
        if (handler == null) {
          throw new Error(`No available scope handler for '${scopeType2.type}'`);
        }
        return handler;
      }
    );
    const iterationScopeType = () => ({
      type: "custom",
      scopeHandler: new _OneOfScopeHandler(
        void 0,
        scopeHandlers.map(
          (scopeHandler) => scopeHandlerFactory.create(
            scopeHandler.iterationScopeType,
            languageId
          )
        ),
        () => {
          throw new Error("Not implemented");
        }
      )
    });
    return new _OneOfScopeHandler(scopeType, scopeHandlers, iterationScopeType);
  }
  get iterationScopeType() {
    return this.getIterationScopeType();
  }
  *generateScopeCandidates(editor, position, direction, hints) {
    const iterators = this.scopeHandlers.map(
      (scopeHandler) => scopeHandler.generateScopes(editor, position, direction, hints)[Symbol.iterator]()
    );
    let iteratorInfos = getInitialIteratorInfos(iterators);
    while (iteratorInfos.length > 0) {
      iteratorInfos.sort(
        (a, b) => compareTargetScopes(direction, position, a.value, b.value)
      );
      const currentScope2 = iteratorInfos[0].value;
      yield currentScope2;
      iteratorInfos = advanceIteratorsUntil(
        iteratorInfos,
        (scope) => compareTargetScopes(direction, position, currentScope2, scope) < 0
      );
    }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ParagraphScopeHandler.ts
var ParagraphScopeHandler = class extends BaseScopeHandler {
  constructor(_scopeType, _languageId) {
    super();
    this.scopeType = { type: "paragraph" };
    this.iterationScopeType = { type: "document" };
    this.isHierarchical = false;
  }
  *generateScopeCandidates(editor, position, direction) {
    const { document } = editor;
    const offset = direction === "forward" ? 1 : -1;
    const stop = direction === "forward" ? document.lineCount : -1;
    let startLine = getStartLine(document, position, direction);
    let previousLine = editor.document.lineAt(position);
    for (let i = position.line + offset; i !== stop; i += offset) {
      const currentLine = editor.document.lineAt(i);
      if (currentLine.isEmptyOrWhitespace) {
        if (startLine != null) {
          yield createScope2(editor, startLine.range.union(previousLine.range));
          startLine = void 0;
        }
      } else if (startLine == null) {
        startLine = currentLine;
      }
      previousLine = currentLine;
    }
    if (startLine != null) {
      yield createScope2(editor, startLine.range.union(previousLine.range));
    }
  }
};
function getStartLine(document, position, direction) {
  const offset = direction === "forward" ? -1 : 1;
  const stop = direction === "forward" ? -1 : document.lineCount;
  let startLine = document.lineAt(position);
  if (startLine.isEmptyOrWhitespace) {
    return void 0;
  }
  for (let i = position.line + offset; i !== stop; i += offset) {
    const line = document.lineAt(i);
    if (line.isEmptyOrWhitespace) {
      break;
    }
    startLine = line;
  }
  return startLine;
}
function createScope2(editor, domain) {
  return {
    editor,
    domain,
    getTargets: (isReversed) => [
      new ParagraphTarget({
        editor,
        isReversed,
        contentRange: fitRangeToLineContent(editor, domain)
      })
    ]
  };
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SentenceScopeHandler/SentenceSegmenter.ts
var sbd = __toESM(require_tokenizer(), 1);
var leadingOffsetRegex = /\S*\p{L}/u;
var skipPartRegex = /(\r?\n[^\p{L}]*\r?\n)|(?<=[.!?])(\s*\r?\n)/gu;
var options = {
  ["newline_boundaries"]: false,
  ["preserve_whitespace"]: true
};
var SentenceSegmenter = class {
  *segment(text) {
    const sentences2 = sbd.sentences(text, options);
    let index = 0;
    for (const sentence of sentences2) {
      const parts = sentence.split(skipPartRegex).filter((p) => p != null);
      for (const part of parts) {
        if (!skipPart(part)) {
          const segment = createSegment(part, index);
          if (segment != null) {
            yield segment;
          }
        }
        index += part.length;
      }
    }
  }
};
function createSegment(sentence, index) {
  const leadingOffsetMatch = matchRegex(leadingOffsetRegex, sentence);
  if (leadingOffsetMatch == null) {
    return void 0;
  }
  const leadingOffset = leadingOffsetMatch.index;
  if (leadingOffset !== 0) {
    index += leadingOffset;
    sentence = sentence.slice(leadingOffset);
  }
  return {
    text: sentence.trimEnd(),
    index
  };
}
function skipPart(text) {
  return testRegex(skipPartRegex, text);
}

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/SentenceScopeHandler/SentenceScopeHandler.ts
var SentenceScopeHandler = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.scopeType = { type: "sentence" };
    this.iterationScopeType = { type: "paragraph" };
    this.segmenter = new SentenceSegmenter();
  }
  generateScopesInSearchScope(direction, { editor, domain }) {
    const offset = editor.document.offsetAt(domain.start);
    const text = editor.document.getText(domain);
    const sentenceToScope = (sentence) => {
      const contentRange = new Range(
        editor.document.positionAt(offset + sentence.index),
        editor.document.positionAt(
          offset + sentence.index + sentence.text.length
        )
      );
      return {
        editor,
        domain: contentRange,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange,
            isReversed
          })
        ]
      };
    };
    const sentences2 = this.segmenter.segment(text);
    return direction === "forward" ? imap(sentences2, sentenceToScope) : Array.from(sentences2, sentenceToScope).reverse();
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/RegexScopeHandler.ts
var import_lodash24 = __toESM(require_lodash(), 1);
var RegexStageBase = class extends NestedScopeHandler {
  constructor() {
    super(...arguments);
    this.iterationScopeType = { type: "line" };
  }
  generateScopesInSearchScope(direction, { editor, domain }) {
    return imap(
      generateMatchesInRange(this.regex, editor, domain, direction),
      (range4) => ({
        editor,
        domain: range4,
        getTargets: (isReversed) => [
          new TokenTarget({
            editor,
            contentRange: range4,
            isReversed
          })
        ]
      })
    );
  }
};
var NonWhitespaceSequenceScopeHandler = class extends RegexStageBase {
  constructor() {
    super(...arguments);
    this.regex = /\S+/g;
  }
};
var UrlScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
    // taken from https://regexr.com/3e6m0
    this.regex = /(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/g;
  }
};
var CustomRegexScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
  }
  get regex() {
    return new RegExp(this.scopeType.regex, "gu");
  }
};
var GlyphScopeHandler = class extends RegexStageBase {
  constructor(scopeHandlerFactory, scopeType, languageId) {
    super(scopeHandlerFactory, scopeType, languageId);
    this.scopeType = scopeType;
  }
  get regex() {
    return new RegExp((0, import_lodash24.escapeRegExp)(this.scopeType.character), "gui");
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/ScopeHandlerFactoryImpl.ts
var ScopeHandlerFactoryImpl = class {
  constructor(languageDefinitions) {
    this.languageDefinitions = languageDefinitions;
    this.create = this.create.bind(this);
  }
  create(scopeType, languageId) {
    switch (scopeType.type) {
      case "character":
        return new CharacterScopeHandler(this, scopeType, languageId);
      case "word":
        return new WordScopeHandler(this, scopeType, languageId);
      case "token":
        return new TokenScopeHandler(this, scopeType, languageId);
      case "identifier":
        return new IdentifierScopeHandler(this, scopeType, languageId);
      case "line":
        return new LineScopeHandler(scopeType, languageId);
      case "sentence":
        return new SentenceScopeHandler(this, scopeType, languageId);
      case "paragraph":
        return new ParagraphScopeHandler(scopeType, languageId);
      case "document":
        return new DocumentScopeHandler(scopeType, languageId);
      case "oneOf":
        return OneOfScopeHandler.create(this, scopeType, languageId);
      case "nonWhitespaceSequence":
        return new NonWhitespaceSequenceScopeHandler(
          this,
          scopeType,
          languageId
        );
      case "url":
        return new UrlScopeHandler(this, scopeType, languageId);
      case "customRegex":
        return new CustomRegexScopeHandler(this, scopeType, languageId);
      case "glyph":
        return new GlyphScopeHandler(this, scopeType, languageId);
      case "custom":
        return scopeType.scopeHandler;
      case "instance":
        throw Error("Unexpected scope type 'instance'");
      default:
        return this.languageDefinitions.get(languageId)?.getScopeHandler(scopeType);
    }
  }
};

// ../cursorless-engine/src/languages/captureNames.ts
var TEXT_FRAGMENT_CAPTURE_NAME = "textFragment";

// ../cursorless-engine/src/processTargets/modifiers/scopeHandlers/TreeSitterScopeHandler/TreeSitterTextFragmentScopeHandler.ts
var TreeSitterTextFragmentScopeHandler = class extends BaseTreeSitterScopeHandler {
  constructor(query) {
    super(query);
    this.isHierarchical = true;
    // Doesn't correspond to any scope type
    this.scopeType = void 0;
  }
  // Doesn't have any iteration scope type itself; that would correspond to
  // something like "every every"
  get iterationScopeType() {
    throw Error("Not implemented");
  }
  matchToScope(editor, match2) {
    const capture = findCaptureByName(match2, TEXT_FRAGMENT_CAPTURE_NAME);
    if (capture == null) {
      return void 0;
    }
    const { range: contentRange, allowMultiple } = capture;
    if (allowMultiple) {
      throw Error(
        "The #allow-multiple! predicate is not supported for text fragments"
      );
    }
    return {
      editor,
      domain: contentRange,
      allowMultiple,
      getTargets: (isReversed) => [
        new PlainTarget({
          editor,
          isReversed,
          contentRange
        })
      ]
    };
  }
};

// ../cursorless-engine/src/util/nodeSelectors.ts
var import_lodash25 = __toESM(require_lodash(), 1);
function makeRangeFromPositions(startPosition, endPosition) {
  return new Range(
    startPosition.row,
    startPosition.column,
    endPosition.row,
    endPosition.column
  );
}
function positionFromPoint(point) {
  return new Position(point.row, point.column);
}
function getNodeRange(node) {
  return new Range(
    node.startPosition.row,
    node.startPosition.column,
    node.endPosition.row,
    node.endPosition.column
  );
}
function makeNodePairSelection(anchor, active) {
  return new Selection(
    anchor.startPosition.row,
    anchor.startPosition.column,
    active.endPosition.row,
    active.endPosition.column
  );
}
function getNodeInternalRange(node) {
  const children = node.children;
  return makeRangeFromPositions(
    children[0].endPosition,
    children[children.length - 1].startPosition
  );
}
function simpleSelectionExtractor(editor, node) {
  return {
    selection: new Selection(
      new Position(node.startPosition.row, node.startPosition.column),
      new Position(node.endPosition.row, node.endPosition.column)
    ),
    context: {}
  };
}
function extendUntilNextMatchingSiblingOrLast(editor, node, nodeFinder2) {
  const endNode = getNextMatchingSiblingNodeOrLast(node, nodeFinder2);
  return pairSelectionExtractor(editor, node, endNode);
}
function getNextMatchingSiblingNodeOrLast(node, nodeFinder2) {
  let currentNode = node;
  let nextNode = node.nextSibling;
  while (nextNode != null && nodeFinder2(nextNode) == null) {
    currentNode = nextNode;
    nextNode = nextNode.nextSibling;
  }
  return currentNode;
}
function pairSelectionExtractor(editor, node1, node2) {
  const isForward = node1.startIndex < node2.startIndex;
  const start = isForward ? node1 : node2;
  const end = isForward ? node2 : node1;
  return {
    selection: new Selection(
      new Position(start.startPosition.row, start.startPosition.column),
      new Position(end.endPosition.row, end.endPosition.column)
    ),
    context: {}
  };
}
function argumentSelectionExtractor() {
  return delimitedSelector(
    (node) => node.type === "," || node.type === "(" || node.type === ")" || node.type === "[" || node.type === "]" || node.type === ">" || node.type === "<" || node.type === "}" || node.type === "{",
    ", "
  );
}
function unwrapSelectionExtractor(editor, node) {
  let startIndex = node.startIndex;
  let endIndex = node.endIndex;
  if (node.text.startsWith("(") && node.text.endsWith(")")) {
    startIndex += 1;
    endIndex -= 1;
  } else if (node.text.endsWith(";")) {
    endIndex -= 1;
  }
  return {
    selection: new Selection(
      editor.document.positionAt(startIndex),
      editor.document.positionAt(endIndex)
    ),
    context: {}
  };
}
function selectWithLeadingDelimiter(...delimiters) {
  return function(editor, node) {
    const firstSibling = node.previousSibling;
    const secondSibling = firstSibling?.previousSibling;
    let leadingDelimiterRange;
    if (firstSibling) {
      if (delimiters.includes(firstSibling.type)) {
        if (secondSibling) {
          leadingDelimiterRange = makeRangeFromPositions(
            secondSibling.endPosition,
            node.startPosition
          );
        } else {
          leadingDelimiterRange = makeRangeFromPositions(
            firstSibling.startPosition,
            node.startPosition
          );
        }
      } else {
        leadingDelimiterRange = makeRangeFromPositions(
          firstSibling.endPosition,
          node.startPosition
        );
      }
    }
    return {
      ...simpleSelectionExtractor(editor, node),
      context: {
        leadingDelimiterRange
      }
    };
  };
}
function childRangeSelector(typesToExclude = [], typesToInclude = [], { includeUnnamedChildren = false } = {}) {
  return function(editor, node) {
    if (typesToExclude.length > 0 && typesToInclude.length > 0) {
      throw new Error("Cannot have both exclusions and inclusions.");
    }
    let nodes = includeUnnamedChildren ? node.children : node.namedChildren;
    const exclusionSet = new Set(typesToExclude);
    const inclusionSet = new Set(typesToInclude);
    nodes = nodes.filter((child) => {
      if (exclusionSet.size > 0) {
        return !exclusionSet.has(child.type);
      }
      if (inclusionSet.size > 0) {
        return inclusionSet.has(child.type);
      }
      return true;
    });
    return pairSelectionExtractor(editor, nodes[0], nodes[nodes.length - 1]);
  };
}
function selectWithTrailingDelimiter(...delimiters) {
  return function(editor, node) {
    const firstSibling = node.nextSibling;
    const secondSibling = firstSibling?.nextSibling;
    let trailingDelimiterRange;
    if (firstSibling) {
      if (delimiters.includes(firstSibling.type)) {
        if (secondSibling) {
          trailingDelimiterRange = makeRangeFromPositions(
            node.endPosition,
            secondSibling.startPosition
          );
        } else {
          trailingDelimiterRange = makeRangeFromPositions(
            node.endPosition,
            firstSibling.endPosition
          );
        }
      } else {
        trailingDelimiterRange = makeRangeFromPositions(
          node.endPosition,
          firstSibling.startPosition
        );
      }
    }
    return {
      ...simpleSelectionExtractor(editor, node),
      context: {
        trailingDelimiterRange
      }
    };
  };
}
function getNextNonDelimiterNode(startNode, isDelimiterNode) {
  let node = startNode.nextSibling;
  while (node != null) {
    if (!isDelimiterNode(node)) {
      return node;
    }
    node = node.nextSibling;
  }
  return node;
}
function getPreviousNonDelimiterNode(startNode, isDelimiterNode) {
  let node = startNode.previousSibling;
  while (node != null) {
    if (!isDelimiterNode(node)) {
      return node;
    }
    node = node.previousSibling;
  }
  return node;
}
function delimitedSelector(isDelimiterNode, defaultDelimiter, getStartNode = import_lodash25.identity, getEndNode = import_lodash25.identity) {
  return (editor, node) => {
    let leadingDelimiterRange;
    let trailingDelimiterRange;
    const startNode = getStartNode(node);
    const endNode = getEndNode(node);
    const previousNonDelimiterNode = getPreviousNonDelimiterNode(
      startNode,
      isDelimiterNode
    );
    const nextNonDelimiterNode = getNextNonDelimiterNode(
      endNode,
      isDelimiterNode
    );
    if (previousNonDelimiterNode != null) {
      leadingDelimiterRange = makeRangeFromPositions(
        previousNonDelimiterNode.endPosition,
        startNode.startPosition
      );
    }
    if (nextNonDelimiterNode != null) {
      trailingDelimiterRange = makeRangeFromPositions(
        endNode.endPosition,
        nextNonDelimiterNode.startPosition
      );
    }
    const containingListDelimiter = getInsertionDelimiter2(
      editor,
      leadingDelimiterRange,
      trailingDelimiterRange,
      defaultDelimiter
    );
    return {
      selection: new Selection(
        new Position(
          startNode.startPosition.row,
          startNode.startPosition.column
        ),
        new Position(endNode.endPosition.row, endNode.endPosition.column)
      ),
      context: {
        containingListDelimiter,
        leadingDelimiterRange,
        trailingDelimiterRange
      }
    };
  };
}
function getInsertionDelimiter2(editor, leadingDelimiterRange, trailingDelimiterRange, defaultDelimiterInsertion) {
  const { document } = editor;
  const delimiters = [
    trailingDelimiterRange != null ? document.getText(trailingDelimiterRange) : defaultDelimiterInsertion,
    leadingDelimiterRange != null ? document.getText(leadingDelimiterRange) : defaultDelimiterInsertion
  ];
  return (0, import_lodash25.maxBy)(delimiters, "length");
}

// ../../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator2 = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator2);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map4) {
  overrideErrorMap = map4;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path: path8, errorMaps, issueData } = params;
  const fullPath = [...path8, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map4 of maps) {
    errorMessage = map4(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path8, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path8;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    var _a;
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
      offset: (_a = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2 === null || options2 === void 0 ? void 0 : options2.position,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema3, params) => {
  return new ZodArray({
    type: schema3,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema3) {
  if (schema3 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema3.shape) {
      const fieldSchema = schema3.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema3._def,
      shape: () => newShape
    });
  } else if (schema3 instanceof ZodArray) {
    return new ZodArray({
      ...schema3._def,
      type: deepPartialify(schema3.element)
    });
  } else if (schema3 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodTuple) {
    return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
  } else {
    return schema3;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema3) {
    return this.augment({ [key]: schema3 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options2) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema3 = this._def.items[itemIndex] || this._def.rest;
      if (!schema3)
        return null;
      return schema3._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return _ZodEnum.create(values2);
  }
  exclude(values2) {
    return _ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema3, params) => {
  return new ZodPromise({
    type: schema3,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema3, effect, params) => {
  return new ZodEffects({
    schema: schema3,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema3, params) => {
  return new ZodEffects({
    schema: schema3,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// ../cursorless-engine/src/languages/TreeSitterQuery/predicateToString.ts
function predicateToString(predicateDescriptor) {
  const operandList = predicateDescriptor.operands.map(operandToString).join(" ");
  return `(#${predicateDescriptor.operator} ${operandList})`;
}
function operandToString(value) {
  return value.type === "capture" ? `@${value.name}` : value.value;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/constructZodErrorMessages.ts
function constructZodErrorMessages(inputOperands, error) {
  return error.errors.filter(
    // If the user has supplied a capture instead of a string, or vice versa,
    // we'll get two errors instead of one; we prefer to show the more helpful
    // one.
    (error2) => !(error2.code === "invalid_type" && error2.path.length === 2 && (error2.path[1] === "name" || error2.path[1] === "value"))
  ).map((error2) => getErrorMessage(inputOperands, error2));
}
function getErrorMessage(inputOperands, error) {
  if (error.path.length === 0) {
    if (error.code === "too_small") {
      return "Too few arguments";
    } else if (error.code === "too_big") {
      return "Too many arguments";
    }
    return error.message;
  }
  let message = error.message;
  if (error.code === "invalid_literal" && error.path[1] === "type") {
    message = error.expected === "capture" ? "Capture names must be prefixed with @" : "Expected string, but received capture";
  }
  const argIndex = error.path[0];
  const operandString = operandToString(inputOperands[argIndex]);
  return `Error on argument ${argIndex} (\`${operandString}\`): ${message}`;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/QueryPredicateOperator.ts
var QueryPredicateOperator = class {
  /**
   * Whether it is ok for a node argument to be missing.  If true, then the
   * operator will just accept the pattern if the given node is missing.  If
   * false, then the operator will throw an error if the node is missing.
   *
   * This is useful if we want to set some flag on a node, but only if it's
   * present.
   *
   * @returns A boolean indicating whether it is ok for a node argument to be
   * missing.
   */
  allowMissingNode() {
    return false;
  }
  /**
   * Given a list of operands, return a predicate function that can be used to
   * test whether a given match satisfies the predicate.
   *
   * @param inputOperands The operands to the operator, as returned directly
   * from tree-sitter when parse the query file.
   * @returns Either a predicate function, or a list of error messages if the operands
   * were invalid.
   */
  createPredicate(inputOperands) {
    const result = this.schema.safeParse(inputOperands);
    return result.success ? {
      success: true,
      predicate: (match2) => {
        try {
          const acceptArgs = this.constructAcceptArgs(result.data, match2);
          return this.run(...acceptArgs);
        } catch (err) {
          if (err instanceof CaptureNotFoundError && this.allowMissingNode()) {
            return true;
          }
          throw err;
        }
      }
    } : {
      success: false,
      errors: constructZodErrorMessages(inputOperands, result.error)
    };
  }
  /**
   * Given the output of the schema and a match, construct the arguments to pass
   * to the `accept` function.
   * @param rawOutput The output of the schema.
   * @param match The match to use to convert captures to nodes.
   * @returns The arguments to pass to the `accept` function.
   */
  constructAcceptArgs(rawOutput, match2) {
    return rawOutput.map((operand) => {
      if (operand.type === "capture") {
        const capture = match2.captures.find(
          (capture2) => capture2.name === operand.name
        );
        if (capture == null) {
          throw new CaptureNotFoundError(operand.name);
        }
        return capture;
      } else {
        return operand.value;
      }
    });
  }
};
var CaptureNotFoundError = class extends Error {
  constructor(operandName) {
    super(`Could not find capture ${operandName}`);
  }
};

// ../cursorless-engine/src/languages/TreeSitterQuery/operatorArgumentSchemaTypes.ts
var string = z.object({ type: z.literal("string"), value: z.string() });
var q = {
  /**
   * Expect a capture, eg @foo.  The operator will receive the node referenced
   * by the capture
   */
  node: z.object({ type: z.literal("capture"), name: z.string() }),
  /** Expect a string */
  string,
  /** Expect an integer */
  integer: string.transform((val, ctx) => {
    const parsedValue = parseInt(val.value);
    if (isNaN(parsedValue)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Expected an integer"
      });
      return z.NEVER;
    }
    return { type: "integer", value: parsedValue };
  }),
  /** Expect a boolean */
  boolean: string.transform((val, ctx) => {
    if (val.value === "true") {
      return { type: "boolean", value: true };
    }
    if (val.value === "false") {
      return { type: "boolean", value: false };
    }
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "Expected true or false"
    });
    return z.NEVER;
  })
};

// ../cursorless-engine/src/languages/TreeSitterQuery/queryPredicateOperators.ts
var NotType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "not-type?";
    this.schema = z.tuple([q.node, q.string]).rest(q.string);
  }
  run({ node }, ...types2) {
    return !types2.includes(node.type);
  }
};
var NotParentType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "not-parent-type?";
    this.schema = z.tuple([q.node, q.string]).rest(q.string);
  }
  run({ node }, ...types2) {
    return node.parent == null || !types2.includes(node.parent.type);
  }
};
var IsNthChild = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "is-nth-child?";
    this.schema = z.tuple([q.node, q.integer]);
  }
  run({ node }, n) {
    return node.parent?.children.findIndex((n2) => n2.id === node.id) === n;
  }
};
var HasMultipleChildrenOfType = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "has-multiple-children-of-type?";
    this.schema = z.tuple([q.node, q.string]);
  }
  run({ node }, type2) {
    const count2 = node.children.filter((n) => n.type === type2).length;
    return count2 > 1;
  }
};
var ChildRange = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "child-range!";
    this.schema = z.union([
      z.tuple([q.node, q.integer]),
      z.tuple([q.node, q.integer, q.integer]),
      z.tuple([q.node, q.integer, q.integer, q.boolean]),
      z.tuple([q.node, q.integer, q.integer, q.boolean, q.boolean])
    ]);
  }
  run(nodeInfo, startIndex, endIndex, excludeStart, excludeEnd) {
    const {
      node: { children }
    } = nodeInfo;
    startIndex = startIndex < 0 ? children.length + startIndex : startIndex;
    endIndex = endIndex == null ? -1 : endIndex;
    endIndex = endIndex < 0 ? children.length + endIndex : endIndex;
    const start = children[startIndex];
    const end = children[endIndex];
    nodeInfo.range = makeRangeFromPositions(
      excludeStart ? start.endPosition : start.startPosition,
      excludeEnd ? end.startPosition : end.endPosition
    );
    return true;
  }
};
var ShrinkToMatch = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "shrink-to-match!";
    this.schema = z.tuple([q.node, q.string]);
  }
  run(nodeInfo, pattern) {
    const { document, range: range4 } = nodeInfo;
    const text = document.getText(range4);
    const match2 = text.match(new RegExp(pattern, "ds"));
    if (match2?.index == null) {
      throw Error(`No match for pattern '${pattern}'`);
    }
    const [startOffset, endOffset] = match2.indices?.groups?.keep ?? match2.indices[0];
    const baseOffset = document.offsetAt(range4.start);
    nodeInfo.range = new Range(
      document.positionAt(baseOffset + startOffset),
      document.positionAt(baseOffset + endOffset)
    );
    return true;
  }
};
var TrimEnd = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "trim-end!";
    this.schema = z.tuple([q.node]);
  }
  run(nodeInfo) {
    const { document, range: range4 } = nodeInfo;
    const text = document.getText(range4);
    const whitespaceLength = text.length - text.trimEnd().length;
    nodeInfo.range = new Range(
      range4.start,
      adjustPosition(document, range4.end, -whitespaceLength)
    );
    return true;
  }
};
var AllowMultiple = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "allow-multiple!";
    this.schema = z.tuple([q.node]);
  }
  allowMissingNode() {
    return true;
  }
  run(nodeInfo) {
    nodeInfo.allowMultiple = true;
    return true;
  }
};
var Log = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "log!";
    this.schema = z.tuple([q.node]);
  }
  run(nodeInfo) {
    console.log(`#log!: ${nodeInfo.name}@${nodeInfo.range}`);
    return true;
  }
};
var InsertionDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "insertion-delimiter!";
    this.schema = z.tuple([q.node, q.string]);
  }
  run(nodeInfo, insertionDelimiter) {
    nodeInfo.insertionDelimiter = insertionDelimiter;
    return true;
  }
};
var SingleOrMultilineDelimiter = class extends QueryPredicateOperator {
  constructor() {
    super(...arguments);
    this.name = "single-or-multi-line-delimiter!";
    this.schema = z.tuple([q.node, q.node, q.string, q.string]);
  }
  run(nodeInfo, conditionNodeInfo, insertionDelimiterConsequence, insertionDelimiterAlternative) {
    nodeInfo.insertionDelimiter = conditionNodeInfo.range.isSingleLine ? insertionDelimiterConsequence : insertionDelimiterAlternative;
    return true;
  }
};
var queryPredicateOperators = [
  new Log(),
  new NotType(),
  new TrimEnd(),
  new NotParentType(),
  new IsNthChild(),
  new ChildRange(),
  new ShrinkToMatch(),
  new AllowMultiple(),
  new InsertionDelimiter(),
  new SingleOrMultilineDelimiter(),
  new HasMultipleChildrenOfType()
];

// ../cursorless-engine/src/languages/TreeSitterQuery/parsePredicates.ts
function parsePredicates(predicateDescriptors) {
  const errors2 = [];
  const predicates = [];
  predicateDescriptors.forEach((patternPredicateDescriptors, patternIdx) => {
    const patternPredicates = [];
    patternPredicateDescriptors.forEach((predicateDescriptor, predicateIdx) => {
      const operator = queryPredicateOperators.find(
        ({ name }) => name === predicateDescriptor.operator
      );
      if (operator == null) {
        errors2.push({
          patternIdx,
          predicateIdx,
          error: `Unknown predicate operator "${predicateDescriptor.operator}"`
        });
        return;
      }
      const result = operator.createPredicate(predicateDescriptor.operands);
      if (!result.success) {
        errors2.push(
          ...result.errors.map((error) => ({
            patternIdx,
            predicateIdx,
            error
          }))
        );
        return;
      }
      patternPredicates.push(result.predicate);
    });
    predicates.push(patternPredicates);
  });
  return { errors: errors2, predicates };
}

// ../cursorless-engine/src/languages/TreeSitterQuery/TreeSitterQuery.ts
var import_lodash26 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/languages/TreeSitterQuery/checkCaptureStartEnd.ts
function checkCaptureStartEnd(captures, messages) {
  if (captures.length === 1) {
    return true;
  }
  let shownError = false;
  const lastStart = captures.filter(({ name }) => name.endsWith(".start")).map(({ range: { end } }) => end).sort((a, b) => a.compareTo(b)).at(-1);
  const firstEnd = captures.filter(({ name }) => name.endsWith(".end")).map(({ range: { start } }) => start).sort((a, b) => a.compareTo(b)).at(0);
  if (lastStart != null && firstEnd != null) {
    if (lastStart.isAfter(firstEnd)) {
      showError(
        messages,
        "TreeSitterQuery.checkCaptures.badOrder",
        `Start capture must be before end capture: ${captures}`
      );
      shownError = true;
    }
  }
  const startCount = captures.filter(
    ({ name }) => name.endsWith(".start")
  ).length;
  const endCount = captures.filter(({ name }) => name.endsWith(".end")).length;
  const regularCount = captures.length - startCount - endCount;
  if (regularCount > 0 && (startCount > 0 || endCount > 0)) {
    showError(
      messages,
      "TreeSitterQuery.checkCaptures.mixRegularStartEnd",
      `Please do not mix regular captures and start/end captures: ${captures.map(
        ({ name, range: range4 }) => name + " " + range4.toString()
      )}`
    );
    shownError = true;
  }
  if (regularCount > 1) {
    showError(
      messages,
      "TreeSitterQuery.checkCaptures.duplicate",
      `A capture with the same name may only appear once in a single pattern: ${captures.map(
        ({ name, range: range4 }) => name + " " + range4.toString()
      )}`
    );
    shownError = true;
  }
  return !shownError;
}

// ../cursorless-engine/src/languages/TreeSitterQuery/rewriteStartOfEndOf.ts
function rewriteStartOfEndOf(captures) {
  return captures.map((capture) => {
    if (capture.name.endsWith(".startOf")) {
      return {
        ...capture,
        name: capture.name.replace(/\.startOf$/, ""),
        range: capture.range.start.toEmptyRange()
      };
    }
    if (capture.name.endsWith(".endOf")) {
      return {
        ...capture,
        name: capture.name.replace(/\.endOf$/, ""),
        range: capture.range.end.toEmptyRange()
      };
    }
    return capture;
  });
}

// ../cursorless-engine/src/languages/TreeSitterQuery/TreeSitterQuery.ts
var TreeSitterQuery = class _TreeSitterQuery {
  constructor(treeSitter, query, patternPredicates) {
    this.treeSitter = treeSitter;
    this.query = query;
    this.patternPredicates = patternPredicates;
  }
  static create(languageId, treeSitter, query) {
    const { errors: errors2, predicates } = parsePredicates(query.predicates);
    if (errors2.length > 0) {
      for (const error of errors2) {
        const context = [
          `language ${languageId}`,
          `pattern ${error.patternIdx}`,
          `predicate \`${predicateToString(
            query.predicates[error.patternIdx][error.predicateIdx]
          )}\``
        ].join(", ");
        showError(
          ide().messages,
          "TreeSitterQuery.parsePredicates",
          `Error parsing predicate for ${context}: ${error.error}`
        );
      }
      if (ide().runMode === "test") {
        throw new Error("Invalid predicates");
      }
    }
    return new _TreeSitterQuery(treeSitter, query, predicates);
  }
  matches(document, start, end) {
    return this.query.matches(
      this.treeSitter.getTree(document).rootNode,
      start == null ? void 0 : positionToPoint(start),
      end == null ? void 0 : positionToPoint(end)
    ).map(
      ({ pattern, captures }) => ({
        patternIdx: pattern,
        captures: captures.map(({ name, node }) => ({
          name,
          node,
          document,
          range: getNodeRange(node),
          insertionDelimiter: void 0,
          allowMultiple: false
        }))
      })
    ).filter(
      (match2) => this.patternPredicates[match2.patternIdx].every(
        (predicate) => predicate(match2)
      )
    ).map((match2) => {
      const captures = Object.entries(
        (0, import_lodash26.groupBy)(match2.captures, ({ name }) => normalizeCaptureName(name))
      ).map(([name, captures2]) => {
        captures2 = rewriteStartOfEndOf(captures2);
        const capturesAreValid = checkCaptureStartEnd(
          captures2,
          ide().messages
        );
        if (!capturesAreValid && ide().runMode === "test") {
          throw new Error("Invalid captures");
        }
        return {
          name,
          range: captures2.map(({ range: range4 }) => range4).reduce((accumulator, range4) => range4.union(accumulator)),
          allowMultiple: captures2.some((capture) => capture.allowMultiple),
          insertionDelimiter: captures2.find(
            (capture) => capture.insertionDelimiter != null
          )?.insertionDelimiter
        };
      });
      return { ...match2, captures };
    });
  }
  get captureNames() {
    return (0, import_lodash26.uniq)(this.query.captureNames.map(normalizeCaptureName));
  }
};
function normalizeCaptureName(name) {
  return name.replace(/(\.(start|end))?(\.(startOf|endOf))?$/, "");
}
function positionToPoint(start) {
  return { row: start.line, column: start.character };
}

// ../cursorless-engine/src/languages/TreeSitterQuery/validateQueryCaptures.ts
var wildcard = "_";
var textFragment = "textFragment";
var captureNames = [wildcard, ...simpleScopeTypeTypes];
var positionRelationships = ["prefix", "leading", "trailing"];
var positionSuffixes = ["startOf", "endOf"];
var rangeRelationships = [
  "domain",
  "removal",
  "interior",
  "iteration",
  "iteration.domain"
];
var rangeSuffixes = [
  "start",
  "end",
  "start.startOf",
  "start.endOf",
  "end.startOf",
  "end.endOf"
];
var allowedCaptures = /* @__PURE__ */ new Set();
allowedCaptures.add(textFragment);
for (const suffix of rangeSuffixes) {
  allowedCaptures.add(`${textFragment}.${suffix}`);
}
for (const captureName of captureNames) {
  if (captureName !== wildcard) {
    allowedCaptures.add(captureName);
    for (const suffix of rangeSuffixes) {
      allowedCaptures.add(`${captureName}.${suffix}`);
    }
  }
  for (const relationship of positionRelationships) {
    allowedCaptures.add(`${captureName}.${relationship}`);
    for (const suffix of positionSuffixes) {
      allowedCaptures.add(`${captureName}.${relationship}.${suffix}`);
    }
  }
  for (const relationship of rangeRelationships) {
    allowedCaptures.add(`${captureName}.${relationship}`);
    for (const suffix of rangeSuffixes) {
      allowedCaptures.add(`${captureName}.${relationship}.${suffix}`);
    }
  }
}
var capturePattern = new RegExp(`^(?!;;).*@([\\w.]*)`, "gm");
function validateQueryCaptures(file, rawQuery) {
  const matches = rawQuery.matchAll(capturePattern);
  const errors2 = [];
  for (const match2 of matches) {
    const captureName = match2[1];
    if (captureName.length > 1 && !captureName.includes(".") && captureName.startsWith("_")) {
      continue;
    }
    if (!allowedCaptures.has(captureName)) {
      const lineNumber = match2.input.slice(0, match2.index).split("\n").length;
      errors2.push(`${file}(${lineNumber}) invalid capture '@${captureName}'.`);
    }
  }
  if (errors2.length === 0) {
    return;
  }
  const message = errors2.join("\n");
  showError(
    ide().messages,
    "validateQueryCaptures.invalidCaptureName",
    message
  );
  if (ide().runMode === "test") {
    throw new Error(message);
  }
}

// ../cursorless-engine/src/languages/LanguageDefinition.ts
var LanguageDefinition = class _LanguageDefinition {
  constructor(query) {
    this.query = query;
  }
  /**
   * Construct a language definition for the given language id, if the language
   * has a new-style query definition, or return undefined if the language doesn't
   *
   * @param treeSitter The tree-sitter instance to use for parsing
   * @param languageId The language id for which to create a language definition
   * @returns A language definition for the given language id, or undefined if the given language
   * id doesn't have a new-style query definition
   */
  static async create(treeSitter, fileSystem, queryDir, languageId) {
    const languageQueryPath = (0, import_path2.join)(queryDir, `${languageId}.scm`);
    const rawLanguageQueryString = await readQueryFileAndImports(
      fileSystem,
      languageQueryPath
    );
    if (rawLanguageQueryString == null) {
      return void 0;
    }
    const rawQuery = treeSitter.getLanguage(languageId).query(rawLanguageQueryString);
    const query = TreeSitterQuery.create(languageId, treeSitter, rawQuery);
    return new _LanguageDefinition(query);
  }
  /**
   * @param scopeType The scope type for which to get a scope handler
   * @returns A scope handler for the given scope type and language id, or
   * undefined if the given scope type / language id combination is still using
   * legacy pathways
   */
  getScopeHandler(scopeType) {
    if (!this.query.captureNames.includes(scopeType.type)) {
      return void 0;
    }
    return new TreeSitterScopeHandler(this.query, scopeType);
  }
  getTextFragmentScopeHandler() {
    if (!this.query.captureNames.includes(TEXT_FRAGMENT_CAPTURE_NAME)) {
      return void 0;
    }
    return new TreeSitterTextFragmentScopeHandler(this.query);
  }
};
async function readQueryFileAndImports(fileSystem, languageQueryPath) {
  const rawQueryStrings = {
    [languageQueryPath]: null
  };
  const doValidation = ide().runMode !== "production";
  while (Object.values(rawQueryStrings).some((v) => v == null)) {
    for (const [queryPath, rawQueryString] of Object.entries(rawQueryStrings)) {
      if (rawQueryString != null) {
        continue;
      }
      const fileName = (0, import_path2.basename)(queryPath);
      let rawQuery = await fileSystem.readBundledFile(queryPath);
      if (rawQuery == null) {
        if (queryPath === languageQueryPath) {
          return void 0;
        }
        showError(
          ide().messages,
          "LanguageDefinition.readQueryFileAndImports.queryNotFound",
          `Could not find imported query file ${queryPath}`
        );
        if (ide().runMode === "test") {
          throw new Error("Invalid import statement");
        }
        rawQuery = "";
      }
      if (doValidation) {
        validateQueryCaptures(fileName, rawQuery);
      }
      rawQueryStrings[queryPath] = rawQuery;
      matchAll(
        rawQuery,
        // Matches lines like:
        //
        // ;; import path/to/query.scm
        //
        // but is very lenient about whitespace and quotes, and also allows
        // include instead of import, so that we can throw a nice error message
        // if the developer uses the wrong syntax
        /^[^\S\r\n]*;;?[^\S\r\n]*(?:import|include)[^\S\r\n]+['"]?([\w|/.]+)['"]?[^\S\r\n]*$/gm,
        (match2) => {
          const relativeImportPath = match2[1];
          if (doValidation) {
            validateImportSyntax(fileName, relativeImportPath, match2[0]);
          }
          const importQueryPath = (0, import_path2.join)((0, import_path2.dirname)(queryPath), relativeImportPath);
          rawQueryStrings[importQueryPath] = rawQueryStrings[importQueryPath] ?? null;
        }
      );
    }
  }
  return Object.values(rawQueryStrings).join("\n");
}
function validateImportSyntax(file, relativeImportPath, actual) {
  const canonicalSyntax = `;; import ${relativeImportPath}`;
  if (actual !== canonicalSyntax) {
    showError(
      ide().messages,
      "LanguageDefinition.readQueryFileAndImports.malformedImport",
      `Malformed import statement in ${file}: "${actual}". Import statements must be of the form "${canonicalSyntax}"`
    );
    if (ide().runMode === "test") {
      throw new Error("Invalid import statement");
    }
  }
}

// ../cursorless-engine/src/languages/LanguageDefinitions.ts
var LANGUAGE_UNDEFINED = Symbol("LANGUAGE_UNDEFINED");
var LanguageDefinitions = class {
  constructor(fileSystem, treeSitter) {
    this.fileSystem = fileSystem;
    this.treeSitter = treeSitter;
    this.notifier = new Notifier();
    /**
     * Maps from language id to {@link LanguageDefinition} or
     * {@link LANGUAGE_UNDEFINED} if language doesn't have new-style definitions.
     * We use a sentinel value instead of undefined so that we can distinguish
     * between a situation where we haven't yet checked whether a language has a
     * new-style query definition and a situation where we've checked and found
     * that it doesn't.  The former case is represented by `undefined` (due to the
     * semantics of {@link Map.get}), while the latter is represented by the
     * sentinel value.
     */
    this.languageDefinitions = /* @__PURE__ */ new Map();
    this.disposables = [];
    this.onDidChangeDefinition = this.notifier.registerListener;
    ide().onDidOpenTextDocument((document) => {
      this.loadLanguage(document.languageId);
    });
    ide().onDidChangeVisibleTextEditors((editors) => {
      editors.forEach(({ document }) => this.loadLanguage(document.languageId));
    });
    this.queryDir = ide().runMode === "development" ? (0, import_path3.join)(getCursorlessRepoRoot(), "queries") : "queries";
    if (ide().runMode === "development") {
      this.disposables.push(
        fileSystem.watchDir(this.queryDir, () => {
          this.reloadLanguageDefinitions();
        })
      );
    }
  }
  async init() {
    await this.loadAllLanguages();
  }
  async loadAllLanguages() {
    const languageIds = ide().visibleTextEditors.map(
      ({ document }) => document.languageId
    );
    await Promise.all(
      languageIds.map((languageId) => this.loadLanguage(languageId))
    );
  }
  async loadLanguage(languageId) {
    if (this.languageDefinitions.has(languageId)) {
      return;
    }
    const definition = await LanguageDefinition.create(
      this.treeSitter,
      this.fileSystem,
      this.queryDir,
      languageId
    ) ?? LANGUAGE_UNDEFINED;
    this.languageDefinitions.set(languageId, definition);
  }
  async reloadLanguageDefinitions() {
    const languageIds = Array.from(this.languageDefinitions.keys());
    this.languageDefinitions.clear();
    await Promise.all(
      languageIds.map((languageId) => this.loadLanguage(languageId))
    );
    this.notifier.notifyListeners();
  }
  /**
   * Get a language definition for the given language id, if the language
   * has a new-style query definition, or return undefined if the language doesn't
   *
   * @param languageId The language id for which to get a language definition
   * @returns A language definition for the given language id, or undefined if
   * the given language id doesn't have a new-style query definition
   */
  get(languageId) {
    const definition = this.languageDefinitions.get(languageId);
    if (definition == null) {
      throw new Error(
        "Expected language definition entry is missing for languageId " + languageId
      );
    }
    return definition === LANGUAGE_UNDEFINED ? void 0 : definition;
  }
  /**
   * @deprecated Only for use in legacy containing scope stage
   */
  getNodeAtLocation(document, range4) {
    return this.treeSitter.getNodeAtLocation(document, range4);
  }
  dispose() {
    this.disposables.forEach((disposable) => disposable.dispose());
  }
};

// ../cursorless-engine/src/nodeCommon/TalonSpokenFormsJsonReader.ts
var import_promises3 = require("fs/promises");
var path3 = __toESM(require("path"), 1);
var LATEST_SPOKEN_FORMS_JSON_VERSION = 0;
var TalonSpokenFormsJsonReader = class {
  constructor(fileSystem) {
    this.fileSystem = fileSystem;
    this.notifier = new Notifier();
    /**
     * Registers a callback to be run when the spoken forms change.
     * @param callback The callback to run when the scope ranges change
     * @returns A {@link Disposable} which will stop the callback from running
     */
    this.onDidChange = this.notifier.registerListener;
    this.disposable = this.fileSystem.watchDir(
      path3.dirname(this.fileSystem.cursorlessTalonStateJsonPath),
      () => this.notifier.notifyListeners()
    );
  }
  async getSpokenFormEntries() {
    let payload;
    try {
      payload = JSON.parse(
        await (0, import_promises3.readFile)(this.fileSystem.cursorlessTalonStateJsonPath, "utf-8")
      );
    } catch (err) {
      if (isErrnoException(err) && err.code === "ENOENT") {
        throw new NeedsInitialTalonUpdateError(
          `Custom spoken forms file not found at ${this.fileSystem.cursorlessTalonStateJsonPath}. Using default spoken forms.`
        );
      }
      throw err;
    }
    if (payload.version !== LATEST_SPOKEN_FORMS_JSON_VERSION) {
      throw new Error(
        `Invalid spoken forms version. Expected ${LATEST_SPOKEN_FORMS_JSON_VERSION} but got ${payload.version}`
      );
    }
    return payload.spokenForms;
  }
  dispose() {
    this.disposable.dispose();
  }
};
function isErrnoException(error) {
  return error instanceof Error && "code" in error;
}

// ../cursorless-engine/src/processTargets/modifiers/CascadingStage.ts
var CascadingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  get nestedStages() {
    if (this.nestedStages_ == null) {
      this.nestedStages_ = this.modifier.modifiers.map(
        this.modifierStageFactory.create
      );
    }
    return this.nestedStages_;
  }
  run(target) {
    for (const nestedStage of this.nestedStages) {
      try {
        return nestedStage.run(target);
      } catch (error) {
        continue;
      }
    }
    throw new Error("No modifier could be applied");
  }
};

// ../cursorless-engine/src/processTargets/modifiers/ConditionalModifierStages.ts
var ConditionalModifierBaseStage = class {
  constructor(modifierStageFactory, nestedModifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.nestedModifier = nestedModifier;
    this.suppressErrors = false;
  }
  run(target) {
    if (this.shouldModify(target)) {
      try {
        return this.nestedStage.run(target).map((newTarget) => newTarget.withThatTarget(target));
      } catch (ex) {
        if (!this.suppressErrors) {
          throw ex;
        }
      }
    }
    return [target];
  }
  get nestedStage() {
    if (this.nestedStage_ == null) {
      this.nestedStage_ = this.modifierStageFactory.create(this.nestedModifier);
    }
    return this.nestedStage_;
  }
};
var ModifyIfUntypedStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory, modifier) {
    super(modifierStageFactory, modifier.modifier);
  }
  shouldModify(target) {
    return !target.hasExplicitScopeType;
  }
};
var ModifyIfUntypedExplicitStage = class extends ConditionalModifierBaseStage {
  shouldModify(target) {
    return !target.hasExplicitScopeType && !target.isImplicit;
  }
};
var ContainingTokenIfUntypedEmptyStage = class extends ConditionalModifierBaseStage {
  constructor(modifierStageFactory) {
    super(modifierStageFactory, {
      type: "containingScope",
      scopeType: { type: "token" }
    });
    this.suppressErrors = true;
  }
  shouldModify(target) {
    return !target.hasExplicitScopeType && !target.hasExplicitRange && target.contentRange.isEmpty;
  }
};

// ../cursorless-engine/src/util/typeUtils.ts
function isSameType(a, b) {
  return Object.getPrototypeOf(a).constructor === Object.getPrototypeOf(b).constructor;
}

// ../cursorless-engine/src/processTargets/createContinuousRangeTarget.ts
function createContinuousRangeTarget(isReversed, startTarget, endTarget, includeStart, includeEnd) {
  if (includeStart && includeEnd && isSameType(startTarget, endTarget)) {
    const richTarget = startTarget.maybeCreateRichRangeTarget(
      isReversed,
      endTarget
    );
    if (richTarget != null) {
      return richTarget;
    }
  }
  if (startTarget.isLine && endTarget.isLine) {
    return new LineTarget({
      editor: startTarget.editor,
      isReversed,
      contentRange: createContinuousLineRange(
        startTarget,
        endTarget,
        includeStart,
        includeEnd
      )
    });
  }
  return new UntypedTarget({
    editor: startTarget.editor,
    isReversed,
    hasExplicitRange: true,
    contentRange: createContinuousRange(
      startTarget,
      endTarget,
      includeStart,
      includeEnd
    ),
    isToken: includeStart && includeEnd && startTarget.isToken && endTarget.isToken
  });
}

// ../cursorless-engine/src/processTargets/modifiers/constructScopeRangeTarget.ts
function constructScopeRangeTarget(isReversed, scope1, scope2) {
  if (scope1 === scope2) {
    return scope1.getTargets(isReversed);
  }
  const targets1 = scope1.getTargets(isReversed);
  const targets2 = scope2.getTargets(isReversed);
  if (targets1.length !== 1 || targets2.length !== 1) {
    throw Error("Scope range targets must be single-target");
  }
  const [target1] = targets1;
  const [target2] = targets2;
  const isScope2After = target2.contentRange.start.isAfterOrEqual(
    target1.contentRange.start
  );
  const [startTarget, endTarget] = isScope2After ? [target1, target2] : [target2, target1];
  return [
    createContinuousRangeTarget(isReversed, startTarget, endTarget, true, true)
  ];
}

// ../cursorless-engine/src/processTargets/modifiers/getPreferredScopeTouchingPosition.ts
function getPreferredScopeTouchingPosition(scopeHandler, editor, position, forceDirection) {
  const candidates = Array.from(
    scopeHandler.generateScopes(editor, position, "forward", {
      containment: "required",
      allowAdjacentScopes: true,
      skipAncestorScopes: true
    })
  );
  switch (candidates.length) {
    case 0:
      return void 0;
    case 1:
      return candidates[0];
    case 2: {
      const [backwardScope, forwardScope] = candidates;
      if (forceDirection === "forward") {
        return forwardScope;
      }
      if (forceDirection === "backward") {
        return backwardScope;
      }
      if (scopeHandler.isPreferredOver?.(backwardScope, forwardScope) ?? false) {
        return backwardScope;
      }
      return forwardScope;
    }
    default:
      throw new Error("Expected no more than 2 scope candidates");
  }
}

// ../cursorless-engine/src/processTargets/modifiers/getContainingScopeTarget.ts
function getContainingScopeTarget(target, scopeHandler, ancestorIndex = 0) {
  const {
    isReversed,
    editor,
    contentRange: { start, end }
  } = target;
  if (end.isEqual(start)) {
    let scope = getPreferredScopeTouchingPosition(scopeHandler, editor, start);
    if (scope == null) {
      return void 0;
    }
    if (ancestorIndex > 0) {
      scope = expandFromPosition(
        scopeHandler,
        editor,
        scope.domain.end,
        "forward",
        ancestorIndex,
        true
      );
    }
    if (scope == null) {
      return void 0;
    }
    return scope.getTargets(isReversed);
  }
  const startScope = expandFromPosition(
    scopeHandler,
    editor,
    start,
    "forward",
    ancestorIndex
  );
  if (startScope == null) {
    return void 0;
  }
  if (startScope.domain.contains(end)) {
    return startScope.getTargets(isReversed);
  }
  const endScope = expandFromPosition(
    scopeHandler,
    editor,
    end,
    "backward",
    ancestorIndex
  );
  if (endScope == null) {
    return void 0;
  }
  return constructScopeRangeTarget(isReversed, startScope, endScope);
}
function expandFromPosition(scopeHandler, editor, position, direction, ancestorIndex, allowAdjacentScopes = false) {
  let nextAncestorIndex = 0;
  for (const scope of scopeHandler.generateScopes(editor, position, direction, {
    containment: "required",
    allowAdjacentScopes
  })) {
    if (nextAncestorIndex === ancestorIndex) {
      return scope;
    }
    nextAncestorIndex += 1;
  }
  return void 0;
}

// ../cursorless-engine/src/processTargets/modifiers/ContainingScopeStage.ts
var ContainingScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const { scopeType, ancestorIndex = 0 } = this.modifier;
    const scopeHandler = this.scopeHandlerFactory.create(
      scopeType,
      target.editor.document.languageId
    );
    if (scopeHandler == null) {
      return this.modifierStageFactory.getLegacyScopeStage(this.modifier).run(target);
    }
    const containingScope = getContainingScopeTarget(
      target,
      scopeHandler,
      ancestorIndex
    );
    if (containingScope == null) {
      if (scopeType.type === "collectionItem") {
        return this.modifierStageFactory.getLegacyScopeStage(this.modifier).run(target);
      }
      throw new NoContainingScopeError(this.modifier.scopeType.type);
    }
    return containingScope;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/EveryScopeStage.ts
var EveryScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const { scopeType } = this.modifier;
    const { editor, isReversed } = target;
    const scopeHandler = this.scopeHandlerFactory.create(
      scopeType,
      editor.document.languageId
    );
    if (scopeHandler == null) {
      return this.modifierStageFactory.getLegacyScopeStage(this.modifier).run(target);
    }
    let scopes;
    if (target.hasExplicitRange) {
      scopes = getScopesOverlappingRange(
        scopeHandler,
        editor,
        target.contentRange
      );
      if (scopes.length === 1 && scopes[0].domain.contains(target.contentRange)) {
        scopes = void 0;
      }
    }
    if (scopes == null) {
      try {
        scopes = this.getDefaultIterationRange(
          scopeHandler,
          this.scopeHandlerFactory,
          target
        ).flatMap(
          (iterationRange) => getScopesOverlappingRange(scopeHandler, editor, iterationRange)
        );
      } catch (error) {
        if (!(error instanceof NoContainingScopeError)) {
          throw error;
        }
        scopes = [];
      }
    }
    if (scopes.length === 0) {
      if (scopeType.type === "collectionItem") {
        return this.modifierStageFactory.getLegacyScopeStage(this.modifier).run(target);
      }
      throw new NoContainingScopeError(scopeType.type);
    }
    return scopes.flatMap((scope) => scope.getTargets(isReversed));
  }
  getDefaultIterationRange(scopeHandler, scopeHandlerFactory, target) {
    const iterationScopeHandler = scopeHandlerFactory.create(
      scopeHandler.iterationScopeType,
      target.editor.document.languageId
    );
    if (iterationScopeHandler == null) {
      throw Error("Could not find iteration scope handler");
    }
    const iterationScopeTarget = getContainingScopeTarget(
      target,
      iterationScopeHandler
    );
    if (iterationScopeTarget == null) {
      throw new NoContainingScopeError(
        `iteration scope for ${scopeHandler.scopeType.type}`
      );
    }
    return iterationScopeTarget.map((target2) => target2.contentRange);
  }
};
function getScopesOverlappingRange(scopeHandler, editor, { start, end }) {
  return Array.from(
    scopeHandler.generateScopes(editor, start, "forward", {
      distalPosition: end,
      skipAncestorScopes: true,
      allowAdjacentScopes: scopeHandler.includeAdjacentInEvery
    })
  );
}

// ../cursorless-engine/src/processTargets/modifiers/FilterStages.ts
var KeepContentFilterStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.contentText.trim() !== "" ? [target] : [];
  }
};
var KeepEmptyFilterStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.contentText.trim() === "" ? [target] : [];
  }
};

// ../cursorless-engine/src/processTargets/TargetPipelineRunner.ts
var import_lodash27 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/processTargets/marks/getActiveSelections.ts
function getActiveSelections(ide2) {
  return ide2.activeTextEditor?.selections.map((selection) => ({
    selection,
    editor: ide2.activeTextEditor
  })) ?? [];
}

// ../cursorless-engine/src/processTargets/marks/ImplicitStage.ts
var ImplicitStage = class {
  run() {
    return getActiveSelections(ide()).map(
      (selection) => new ImplicitTarget({
        editor: selection.editor,
        isReversed: selection.selection.isReversed,
        contentRange: selection.selection
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/TargetPipelineRunner.ts
var TargetPipelineRunner = class {
  constructor(modifierStageFactory, markStageFactory) {
    this.modifierStageFactory = modifierStageFactory;
    this.markStageFactory = markStageFactory;
  }
  /**
   * Converts the abstract target descriptions provided by the user to a
   * concrete representation usable by actions. Conceptually, the input will be
   * something like "the function call argument containing the cursor" and the
   * output will be something like "line 3, characters 5 through 10".
   * @param target The abstract target representations provided by the user
   * @param actionFinalStages Modifier stages contributed by the action that
   * should run at the end of the modifier pipeline
   * @returns A list of lists of typed selections, one list per input target.
   * Each typed selection includes the selection, as well the uri of the
   * document containing it, and potentially rich context information such as
   * how to remove the target
   */
  run(target, {
    actionFinalStages = [],
    noAutomaticTokenExpansion = false
  } = {}) {
    return new TargetPipeline(
      this.modifierStageFactory,
      this.markStageFactory,
      target,
      { actionFinalStages, noAutomaticTokenExpansion }
    ).run();
  }
};
var TargetPipeline = class {
  constructor(modifierStageFactory, markStageFactory, target, opts) {
    this.modifierStageFactory = modifierStageFactory;
    this.markStageFactory = markStageFactory;
    this.target = target;
    this.opts = opts;
  }
  /**
   * Converts the abstract target descriptions provided by the user to a concrete
   * representation usable by actions. Conceptually, the input will be something
   * like "the function call argument containing the cursor" and the output will be something
   * like "line 3, characters 5 through 10".
   * @param context Captures the environment needed to convert the abstract target
   *    description given by the user to a concrete representation usable by
   *    actions
   * @param targets The abstract target representations provided by the user
   * @returns A list of lists of typed selections, one list per input target. Each
   * typed selection includes the selection, as well the uri of the document
   * containing it, and potentially rich context information such as how to remove
   * the target
   */
  run() {
    return uniqTargets(this.processTarget(this.target));
  }
  processTarget(target) {
    switch (target.type) {
      case "list":
        return target.elements.flatMap(
          (element) => this.processTarget(element)
        );
      case "range":
        return this.processRangeTarget(target);
      case "primitive":
      case "implicit":
        return this.processPrimitiveTarget(target);
    }
  }
  processRangeTarget(targetDesc) {
    const anchorTargets = this.processPrimitiveTarget(targetDesc.anchor);
    const activeTargets = this.processPrimitiveTarget(targetDesc.active);
    return (0, import_lodash27.zip)(anchorTargets, activeTargets).flatMap(
      ([anchorTarget, activeTarget]) => {
        if (anchorTarget == null || activeTarget == null) {
          throw new Error(
            "AnchorTargets and activeTargets lengths don't match"
          );
        }
        switch (targetDesc.rangeType) {
          case "continuous":
            return this.processContinuousRangeTarget(
              anchorTarget,
              activeTarget,
              targetDesc
            );
          case "vertical":
            return targetsToVerticalTarget(
              anchorTarget,
              activeTarget,
              targetDesc.excludeAnchor,
              targetDesc.excludeActive
            );
        }
      }
    );
  }
  processContinuousRangeTarget(anchorTarget, activeTarget, { excludeAnchor, excludeActive, exclusionScopeType }) {
    if (exclusionScopeType == null) {
      return [
        targetsToContinuousTarget(
          anchorTarget,
          activeTarget,
          excludeAnchor,
          excludeActive
        )
      ];
    }
    const isReversed = calcIsReversed(anchorTarget, activeTarget);
    return [
      targetsToContinuousTarget(
        excludeAnchor ? getExcludedScope(
          this.modifierStageFactory,
          anchorTarget,
          exclusionScopeType,
          isReversed ? "backward" : "forward"
        ) : anchorTarget,
        excludeActive ? getExcludedScope(
          this.modifierStageFactory,
          activeTarget,
          exclusionScopeType,
          isReversed ? "forward" : "backward"
        ) : activeTarget,
        false,
        false
      )
    ];
  }
  /**
   * This function implements the modifier pipeline that is at the core of Cursorless target processing.
   * It proceeds as follows:
   *
   * 1. It begins by getting the output from the {@link markStage} (eg "air", "this", etc).
   * This output is a list of zero or more targets.
   * 2. It then constructs a pipeline from the modifiers on the {@link targetDescriptor}
   * 3. It then runs each pipeline stage in turn, feeding the first stage with
   * the list of targets output from the {@link markStage}.  For each pipeline
   * stage, it passes the targets from the previous stage to the pipeline stage
   * one by one.  For each target, the stage will output a list of zero or more output
   * targets.  It then concatenates all of these lists into the list of targets
   * that will be passed to the next pipeline stage.  This process is similar to
   * the way that [jq](https://stedolan.github.io/jq/) processes its inputs.
   *
   * @param targetDescriptor The description of the target, consisting of a mark
   * and zero or more modifiers
   * @returns The output of running the modifier pipeline on the output from the mark
   */
  processPrimitiveTarget(targetDescriptor) {
    let markStage;
    let targetModifierStages;
    if (targetDescriptor.type === "implicit") {
      markStage = new ImplicitStage();
      targetModifierStages = [];
    } else {
      markStage = this.markStageFactory.create(targetDescriptor.mark);
      targetModifierStages = getModifierStagesFromTargetModifiers(
        this.modifierStageFactory,
        targetDescriptor.modifiers
      );
    }
    const markOutputTargets = markStage.run();
    const modifierStages = [
      ...targetModifierStages,
      ...this.opts.actionFinalStages,
      // This performs auto-expansion to token when you say eg "take this" with an
      // empty selection
      ...this.opts.noAutomaticTokenExpansion ? [] : [new ContainingTokenIfUntypedEmptyStage(this.modifierStageFactory)]
    ];
    return processModifierStages(modifierStages, markOutputTargets);
  }
};
function getModifierStagesFromTargetModifiers(modifierStageFactory, targetModifiers) {
  return targetModifiers.map(modifierStageFactory.create).reverse();
}
function processModifierStages(modifierStages, targets) {
  modifierStages.forEach((stage) => {
    targets = targets.flatMap((target) => stage.run(target));
  });
  return targets;
}
function getExcludedScope(modifierStageFactory, target, scopeType, direction) {
  return modifierStageFactory.create({
    type: "relativeScope",
    scopeType,
    direction,
    length: 1,
    offset: 1
  }).run(target)[0];
}
function calcIsReversed(anchor, active) {
  if (anchor.contentRange.start.isAfter(active.contentRange.start)) {
    return true;
  }
  if (anchor.contentRange.start.isBefore(active.contentRange.start)) {
    return false;
  }
  return anchor.contentRange.end.isAfter(active.contentRange.end);
}
function uniqTargets(array) {
  return uniqWithHash(
    array,
    (a, b) => a.isEqual(b),
    (a) => a.contentRange.concise()
  );
}
function ensureSingleEditor(anchorTarget, activeTarget) {
  if (anchorTarget.editor !== activeTarget.editor) {
    throw new Error("Cannot form range between targets in different editors");
  }
}
function targetsToContinuousTarget(anchorTarget, activeTarget, excludeAnchor = false, excludeActive = false) {
  ensureSingleEditor(anchorTarget, activeTarget);
  const isReversed = calcIsReversed(anchorTarget, activeTarget);
  const startTarget = isReversed ? activeTarget : anchorTarget;
  const endTarget = isReversed ? anchorTarget : activeTarget;
  const excludeStart = isReversed ? excludeActive : excludeAnchor;
  const excludeEnd = isReversed ? excludeAnchor : excludeActive;
  return createContinuousRangeTarget(
    isReversed,
    startTarget,
    endTarget,
    !excludeStart,
    !excludeEnd
  );
}
function targetsToVerticalTarget(anchorTarget, activeTarget, excludeAnchor, excludeActive) {
  ensureSingleEditor(anchorTarget, activeTarget);
  const isReversed = calcIsReversed(anchorTarget, activeTarget);
  const delta = isReversed ? -1 : 1;
  const anchorPosition = isReversed ? anchorTarget.contentRange.start : anchorTarget.contentRange.end;
  const anchorLine = anchorPosition.line + (excludeAnchor ? delta : 0);
  const activePosition = isReversed ? activeTarget.contentRange.start : activeTarget.contentRange.end;
  const activeLine = activePosition.line - (excludeActive ? delta : 0);
  const results = [];
  for (let i = anchorLine; true; i += delta) {
    const contentRange = new Range(
      i,
      anchorTarget.contentRange.start.character,
      i,
      anchorTarget.contentRange.end.character
    );
    results.push(
      new PlainTarget({
        editor: anchorTarget.editor,
        isReversed: anchorTarget.isReversed,
        contentRange,
        insertionDelimiter: anchorTarget.insertionDelimiter
      })
    );
    if (i === activeLine) {
      return results;
    }
  }
}

// ../cursorless-engine/src/processTargets/modifiers/HeadTailStage.ts
var HeadTailStage = class {
  constructor(modifierStageFactory, isReversed, modifiers) {
    this.modifierStageFactory = modifierStageFactory;
    this.isReversed = isReversed;
    this.modifiers = modifiers;
  }
  run(target) {
    const modifiers = this.modifiers ?? [
      {
        type: "containingScope",
        scopeType: { type: "line" }
      }
    ];
    const modifierStages = getModifierStagesFromTargetModifiers(
      this.modifierStageFactory,
      modifiers
    );
    const modifiedTargets = processModifierStages(modifierStages, [target]);
    return modifiedTargets.map((modifiedTarget) => {
      const contentRange = this.constructContentRange(
        target.contentRange,
        modifiedTarget.contentRange
      );
      return new TokenTarget({
        editor: target.editor,
        isReversed: this.isReversed,
        contentRange
      });
    });
  }
};
var HeadStage = class extends HeadTailStage {
  constructor(modifierStageFactory, modifier) {
    super(modifierStageFactory, true, modifier.modifiers);
  }
  constructContentRange(originalRange, modifiedRange) {
    return new Range(modifiedRange.start, originalRange.end);
  }
};
var TailStage = class extends HeadTailStage {
  constructor(modifierStageFactory, modifier) {
    super(modifierStageFactory, false, modifier.modifiers);
  }
  constructContentRange(originalRange, modifiedRange) {
    return new Range(originalRange.start, modifiedRange.end);
  }
};

// ../cursorless-engine/src/processTargets/modifiers/InstanceStage.ts
var import_lodash28 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/processTargets/modifiers/listUtils.ts
var OutOfRangeError = class extends Error {
  constructor() {
    super("Scope index out of range");
    this.name = "OutOfRangeError";
  }
};
function sliceStrict(targets, startIndex, endIndex) {
  assertIndices(targets, startIndex, endIndex);
  return targets.slice(startIndex, endIndex + 1);
}
function assertIndices(targets, startIndex, endIndex) {
  if (startIndex < 0 || endIndex >= targets.length) {
    throw new OutOfRangeError();
  }
}

// ../cursorless-engine/src/processTargets/modifiers/InstanceStage.ts
var InstanceStage = class {
  constructor(modifierStageFactory, storedTargets, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.storedTargets = storedTargets;
    this.modifier = modifier;
  }
  run(inputTarget) {
    const target = new ContainingTokenIfUntypedEmptyStage(
      this.modifierStageFactory
    ).run(inputTarget)[0];
    switch (this.modifier.type) {
      case "everyScope":
        return this.handleEveryScope(target);
      case "ordinalScope":
        return this.handleOrdinalScope(target, this.modifier);
      case "relativeScope":
        return this.handleRelativeScope(target, this.modifier);
      default:
        throw Error(`${this.modifier.type} instance scope not supported`);
    }
  }
  handleEveryScope(target) {
    return Array.from(
      flatmap(
        this.getEveryRanges(target),
        ([editor, searchRange]) => this.getTargetIterable(target, editor, searchRange, "forward")
      )
    );
  }
  handleOrdinalScope(target, { start, length }) {
    return this.getEveryRanges(target).flatMap(
      ([editor, searchRange]) => takeFromOffset(
        this.getTargetIterable(
          target,
          editor,
          searchRange,
          start >= 0 ? "forward" : "backward"
        ),
        start >= 0 ? start : -(length + start),
        length
      )
    );
  }
  handleRelativeScope(target, { direction, offset, length }) {
    const referenceTargets = this.storedTargets.get("instanceReference") ?? [
      target
    ];
    return referenceTargets.flatMap((referenceTarget) => {
      const { editor } = referenceTarget;
      const iterationRange = direction === "forward" ? new Range(
        offset === 0 ? referenceTarget.contentRange.start : referenceTarget.contentRange.end,
        editor.document.range.end
      ) : new Range(
        editor.document.range.start,
        offset === 0 ? referenceTarget.contentRange.end : referenceTarget.contentRange.start
      );
      return takeFromOffset(
        this.getTargetIterable(target, editor, iterationRange, direction),
        offset === 0 ? 0 : offset - 1,
        length
      );
    });
  }
  getEveryRanges({
    editor: targetEditor
  }) {
    return this.storedTargets.get("instanceReference")?.map(({ editor, contentRange }) => [editor, contentRange]) ?? [[targetEditor, targetEditor.document.range]];
  }
  getTargetIterable(target, editor, searchRange, direction) {
    const iterable = imap(
      generateMatchesInRange(
        new RegExp((0, import_lodash28.escapeRegExp)(target.contentText), "g"),
        editor,
        searchRange,
        direction
      ),
      (range4) => new PlainTarget({
        contentRange: range4,
        editor,
        isReversed: false,
        isToken: false
      })
    );
    const filterScopeType = getFilterScopeType(target);
    if (filterScopeType != null) {
      const containingScopeModifier = this.modifierStageFactory.create({
        type: "containingScope",
        scopeType: filterScopeType
      });
      return ifilter(
        imap(iterable, (target2) => {
          try {
            const containingScope = containingScopeModifier.run(target2);
            if (containingScope.length === 1 && containingScope[0].contentRange.isRangeEqual(target2.contentRange)) {
              return containingScope[0];
            }
            return null;
          } catch (err) {
            return null;
          }
        }),
        (target2) => target2 != null
      );
    }
    return iterable;
  }
};
function getFilterScopeType(target) {
  if (target.isLine) {
    return { type: "line" };
  }
  if (target.isToken) {
    return { type: "token" };
  }
  if (target.isWord) {
    return { type: "word" };
  }
  return null;
}
function takeFromOffset(iterable, offset, count2) {
  Array.from(itake(offset, iterable));
  const items = Array.from(itake(count2, iterable));
  if (items.length < count2) {
    throw new OutOfRangeError();
  }
  return items;
}

// ../cursorless-engine/src/processTargets/modifiers/commonContainingScopeIfUntypedModifiers.ts
var containingSurroundingPairIfUntypedModifier = {
  type: "modifyIfUntyped",
  modifier: {
    type: "containingScope",
    scopeType: { type: "surroundingPair", delimiter: "any" }
  }
};
var containingLineIfUntypedModifier = {
  type: "modifyIfUntyped",
  modifier: {
    type: "containingScope",
    scopeType: { type: "line" }
  }
};
var containingTokenIfUntypedModifier = {
  type: "modifyIfUntyped",
  modifier: {
    type: "containingScope",
    scopeType: { type: "token" }
  }
};

// ../cursorless-engine/src/processTargets/modifiers/InteriorStage.ts
var InteriorOnlyStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    return this.modifierStageFactory.create(containingSurroundingPairIfUntypedModifier).run(target).flatMap((target2) => target2.getInteriorStrict());
  }
};
var ExcludeInteriorStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    return this.modifierStageFactory.create(containingSurroundingPairIfUntypedModifier).run(target).flatMap((target2) => target2.getBoundaryStrict());
  }
};

// ../cursorless-engine/src/util/nodeFinders.ts
var nodeFinder = (isTargetNode) => {
  return (node) => {
    return isTargetNode(node) ? node : null;
  };
};
function leadingSiblingNodeFinder(nodeFinder2) {
  return (node) => {
    let currentNode = node;
    while (currentNode != null) {
      const returnNode = nodeFinder2(currentNode);
      if (returnNode != null) {
        return returnNode;
      }
      currentNode = currentNode.previousSibling;
    }
    return null;
  };
}
function chainedNodeFinder(...nodeFinders) {
  return (node) => {
    let currentNode = node;
    for (const nodeFinder2 of nodeFinders) {
      currentNode = nodeFinder2(currentNode);
      if (currentNode == null) {
        return null;
      }
    }
    return currentNode;
  };
}
function ancestorChainNodeFinder(nodeToReturn, ...nodeFinders) {
  return (node) => {
    let currentNode = node;
    const nodeList = [];
    const nodeFindersReversed = [...nodeFinders].reverse();
    for (const nodeFinder2 of nodeFindersReversed) {
      if (currentNode == null) {
        return null;
      }
      currentNode = nodeFinder2(currentNode);
      if (currentNode == null) {
        return null;
      }
      nodeList.push(currentNode);
      currentNode = currentNode.parent ?? null;
    }
    return nodeList.reverse()[nodeToReturn];
  };
}
var typedNodeFinder = (...typeNames) => {
  return nodeFinder((node) => typeNames.includes(node.type));
};
var toPosition = (point) => new Position(point.row, point.column);
var argumentNodeFinder = (...parentTypes) => {
  const left = ["(", "{", "[", "<"];
  const right = [")", "}", "]", ">"];
  const delimiters = left.concat(right);
  const isType = (node, typeNames) => node != null && typeNames.includes(node.type);
  const isOk = (node) => node != null && !isType(node, delimiters);
  return (node, selection) => {
    let resultNode;
    const { start, end } = selection;
    if (isType(node.parent, parentTypes)) {
      if (isType(node, left)) {
        resultNode = node.nextNamedSibling;
      } else if (isType(node, right)) {
        resultNode = node.previousNamedSibling;
      } else if (node.type === ",") {
        resultNode = end.isBeforeOrEqual(toPosition(node.startPosition)) ? node.previousNamedSibling : node.nextNamedSibling;
      } else {
        resultNode = node;
      }
      return isOk(resultNode) ? resultNode : null;
    } else if (isType(node, parentTypes)) {
      const children = [...node.children];
      const childRight = children.find(
        ({ startPosition }) => toPosition(startPosition).isAfterOrEqual(end)
      ) ?? null;
      if (isOk(childRight)) {
        return childRight;
      }
      children.reverse();
      const childLeft = children.find(
        ({ endPosition }) => toPosition(endPosition).isBeforeOrEqual(start)
      ) ?? null;
      if (isOk(childLeft)) {
        return childLeft;
      }
    }
    return null;
  };
};
function patternFinder(...patterns) {
  const parsedPatterns = parsePatternStrings(patterns);
  return (node) => {
    for (const pattern of parsedPatterns) {
      const match2 = tryPatternMatch(node, pattern);
      if (match2 != null) {
        return match2;
      }
    }
    return null;
  };
}
function parsePatternStrings(patternStrings) {
  return patternStrings.map(
    (patternString) => patternString.split(".").map((pattern) => new Pattern(pattern))
  );
}
function tryPatternMatch(node, patterns) {
  let result = searchNodeAscending(node, patterns);
  if (!result && patterns.length > 1) {
    result = searchNodeDescending(node, patterns);
  }
  let resultNode = null;
  let resultPattern;
  if (result != null) {
    [resultNode, resultPattern] = result;
  }
  if (resultNode != null && resultPattern != null && resultPattern.fields != null) {
    resultPattern.fields.forEach((field) => {
      resultNode = (field.isIndex ? resultNode?.namedChild(field.value) : resultNode?.childForFieldName(field.value)) ?? null;
    });
  }
  return resultNode;
}
function searchNodeAscending(node, patterns) {
  let result = null;
  let currentNode = node;
  for (let i = patterns.length - 1; i > -1; --i) {
    const pattern = patterns[i];
    if (currentNode == null || !pattern.typeEquals(currentNode)) {
      if (pattern.isOptional) {
        continue;
      }
      return null;
    }
    if (!result || !result[1].isImportant) {
      result = [currentNode, pattern];
    }
    currentNode = currentNode.parent;
  }
  return result;
}
function searchNodeDescending(node, patterns) {
  let result = null;
  let currentNode = node;
  for (let i = 0; i < patterns.length; ++i) {
    const pattern = patterns[i];
    if (currentNode == null || !pattern.typeEquals(currentNode)) {
      if (pattern.isOptional) {
        continue;
      }
      return null;
    }
    if (!result || pattern.isImportant) {
      result = [currentNode, pattern];
    }
    if (i + 1 < patterns.length) {
      const children = currentNode.namedChildren.filter(
        (node2) => patterns[i + 1].typeEquals(node2)
      );
      currentNode = children.length === 1 ? children[0] : null;
    }
  }
  return result;
}
var Pattern = class {
  constructor(pattern) {
    this.anyType = false;
    this.notType = false;
    this.type = pattern.match(/^[\w*~]+/)[0];
    if (this.type === "*") {
      this.anyType = true;
    } else if (this.type.startsWith("~")) {
      this.type = this.type.slice(1);
      this.notType = true;
    }
    this.isImportant = pattern.indexOf("!") > -1;
    this.isOptional = pattern.indexOf("?") > -1;
    this.fields = [...pattern.matchAll(/(?<=\[).+?(?=\])/g)].map((m) => m[0]).map((field) => {
      if (/\d+/.test(field)) {
        return {
          isIndex: true,
          value: Number(field)
        };
      }
      return {
        isIndex: false,
        value: field
      };
    });
  }
  typeEquals(node) {
    if (this.anyType) {
      return true;
    }
    if (this.notType) {
      return this.type !== node.type;
    }
    return this.type === node.type;
  }
};

// ../cursorless-engine/src/util/nodeMatchers.ts
function matcher(finder, selector = simpleSelectionExtractor) {
  return function(selection, node) {
    const targetNode = finder(node, selection.selection);
    return targetNode != null ? [
      {
        node: targetNode,
        selection: selector(selection.editor, targetNode)
      }
    ] : null;
  };
}
function chainedMatcher(finders, selector = simpleSelectionExtractor) {
  const nodeFinder2 = chainedNodeFinder(...finders);
  return function(selection, initialNode) {
    const returnNode = nodeFinder2(initialNode);
    if (returnNode == null) {
      return null;
    }
    return [
      {
        node: returnNode,
        selection: selector(selection.editor, returnNode)
      }
    ];
  };
}
function ancestorChainNodeMatcher(nodeFinders, nodeToReturn = 0, selector = simpleSelectionExtractor) {
  return matcher(
    ancestorChainNodeFinder(nodeToReturn, ...nodeFinders),
    selector
  );
}
function typeMatcher(...typeNames) {
  return matcher(typedNodeFinder(...typeNames));
}
function patternMatcher(...patterns) {
  return matcher(patternFinder(...patterns));
}
function argumentMatcher(...parentTypes) {
  return matcher(
    argumentNodeFinder(...parentTypes),
    argumentSelectionExtractor()
  );
}
function conditionMatcher(...patterns) {
  return matcher(patternFinder(...patterns), unwrapSelectionExtractor);
}
function leadingMatcher(patterns, delimiters = []) {
  return matcher(
    patternFinder(...patterns),
    selectWithLeadingDelimiter(...delimiters)
  );
}
function trailingMatcher(patterns, delimiters = []) {
  return matcher(
    patternFinder(...patterns),
    selectWithTrailingDelimiter(...delimiters)
  );
}
function cascadingMatcher(...matchers2) {
  return (selection, node) => {
    for (const matcher2 of matchers2) {
      const match2 = matcher2(selection, node);
      if (match2 != null) {
        return match2;
      }
    }
    return null;
  };
}
var notSupported = (_selection, _node) => {
  throw new Error("Node type not supported");
};
function createPatternMatchers(nodeMatchers14) {
  return Object.freeze(
    Object.fromEntries(
      unsafeKeys(nodeMatchers14).map((scopeType) => {
        const matcher2 = nodeMatchers14[scopeType];
        if (Array.isArray(matcher2)) {
          return [scopeType, patternMatcher(...matcher2)];
        } else if (typeof matcher2 === "string") {
          return [scopeType, patternMatcher(matcher2)];
        } else {
          return [scopeType, matcher2];
        }
      })
    )
  );
}

// ../cursorless-engine/src/languages/clojure.ts
var import_lodash29 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/treeSitterUtils.ts
function getChildNodesForFieldName(node, fieldName) {
  const treeCursor = node.walk();
  treeCursor.gotoFirstChild();
  const ret = [];
  let hasNext = true;
  while (hasNext) {
    if (treeCursor.currentFieldName() === fieldName) {
      ret.push(treeCursor.currentNode());
    }
    hasNext = treeCursor.gotoNextSibling();
  }
  return ret;
}
function getAncestors(node, includeNode = true) {
  const ancestors = includeNode ? [node] : [];
  for (let currentNode = node.parent; currentNode != null; currentNode = currentNode.parent) {
    ancestors.push(currentNode);
  }
  return ancestors;
}
function isContainedInErrorNode(node) {
  return getAncestors(node).some((ancestor) => ancestor.type === "ERROR");
}

// ../cursorless-engine/src/languages/clojure.ts
function parityNodeFinder(parentFinder, parity) {
  return indexNodeFinder(
    parentFinder,
    (nodeIndex) => Math.floor(nodeIndex / 2) * 2 + parity
  );
}
function mapParityNodeFinder(parity) {
  return parityNodeFinder(patternFinder("map_lit"), parity);
}
function indexNodeFinder(parentFinder, indexTransform) {
  return (node) => {
    const parent = node.parent;
    if (parent == null || parentFinder(parent) == null) {
      return null;
    }
    const valueNodes = getValueNodes(parent);
    const nodeIndex = valueNodes.findIndex(({ id }) => id === node.id);
    if (nodeIndex === -1) {
      return null;
    }
    const desiredIndex = indexTransform(nodeIndex);
    if (desiredIndex === -1) {
      return null;
    }
    return valueNodes[desiredIndex];
  };
}
function itemFinder() {
  return indexNodeFinder(
    (node) => node,
    (nodeIndex) => nodeIndex
  );
}
var getValueNodes = (node) => getChildNodesForFieldName(node, "value");
var functionCallPattern = "~quoting_lit.list_lit!";
var functionCallFinder = patternFinder(functionCallPattern);
function functionNameBasedFinder(...names) {
  return (node) => {
    const functionCallNode = functionCallFinder(node);
    if (functionCallNode == null) {
      return null;
    }
    const functionNode = getValueNodes(functionCallNode)[0];
    return names.includes(functionNode?.text) ? functionCallNode : null;
  };
}
function functionNameBasedMatcher(...names) {
  return matcher(functionNameBasedFinder(...names));
}
var functionFinder = functionNameBasedFinder("defn", "defmacro");
var functionNameMatcher = chainedMatcher([
  functionFinder,
  (functionNode) => getValueNodes(functionNode)[1]
]);
var ifStatementFinder = functionNameBasedFinder(
  "if",
  "if-let",
  "when",
  "when-let"
);
var ifStatementMatcher = matcher(ifStatementFinder);
var nodeMatchers = {
  map: "map_lit",
  collectionKey: matcher(mapParityNodeFinder(0)),
  collectionItem: cascadingMatcher(
    // Treat each key value pair as a single item if we're in a map
    matcher(
      mapParityNodeFinder(0),
      delimitedSelector(
        (node) => node.type === "{" || node.type === "}",
        ", ",
        import_lodash29.identity,
        mapParityNodeFinder(1)
      )
    ),
    // Otherwise just treat every item within a list as an item
    matcher(itemFinder())
  ),
  value: matcher(mapParityNodeFinder(1)),
  // FIXME: Handle formal parameters
  argumentOrParameter: matcher(
    indexNodeFinder(
      patternFinder(functionCallPattern),
      (nodeIndex) => nodeIndex !== 0 ? nodeIndex : -1
    )
  ),
  // A list is either a vector literal or a quoted list literal
  list: ["vec_lit", "quoting_lit.list_lit"],
  functionCall: functionCallPattern,
  functionCallee: chainedMatcher([
    functionCallFinder,
    (functionNode) => getValueNodes(functionNode)[0]
  ]),
  namedFunction: matcher(functionFinder),
  functionName: functionNameMatcher,
  // FIXME: Handle `let` declarations, defs, etc
  name: functionNameMatcher,
  anonymousFunction: cascadingMatcher(
    functionNameBasedMatcher("fn"),
    patternMatcher("anon_fn_lit")
  ),
  ifStatement: ifStatementMatcher,
  condition: chainedMatcher([
    ifStatementFinder,
    (node) => getValueNodes(node)[1]
  ])
};
var clojure_default = createPatternMatchers(nodeMatchers);

// ../cursorless-engine/src/languages/cpp.ts
var STATEMENT_TYPES = [
  "_statement",
  "_type_specifier",
  "alias_declaration",
  "declaration",
  "function_definition",
  "linkage_specification",
  "namespace_definition",
  "preproc_call",
  "preproc_def",
  "preproc_function_def",
  "preproc_if",
  "preproc_ifdef",
  "preproc_include",
  "static_assert_declaration",
  "template_declaration",
  "template_instantiation",
  "type_definition",
  "using_declaration",
  "break_statement",
  "case_statement",
  "compound_statement",
  "continue_statement",
  "do_statement",
  "expression_statement",
  "for_range_loop",
  "for_statement",
  "goto_statement",
  "if_statement",
  "labeled_statement",
  "return_statement",
  "switch_statement",
  "throw_statement",
  "try_statement",
  "while_statement"
];
var TYPE_TYPES = [
  "auto",
  "class_specifier",
  "decltype",
  "dependent_type",
  "enum_specifier",
  "primitive_type",
  "scoped_type_identifier",
  "sized_type_specifier",
  "struct_specifier",
  "template_type",
  "type_identifier",
  "union_specifier"
];
var nodeMatchers2 = {
  statement: STATEMENT_TYPES,
  class: [
    "class_specifier",
    "struct_specifier",
    "enum_specifier",
    "union_specifier"
  ],
  className: [
    "class_specifier[name]",
    "struct_specifier[name]",
    "enum_specifier[name]",
    "union_specifier[name]",
    "function_definition[declarator][declarator][namespace]"
    // void ClassName::method() {}
  ],
  ["private.switchStatementSubject"]: "switch_statement[condition][value]",
  anonymousFunction: "lambda_expression",
  list: "initializer_list",
  functionCall: ["call_expression", "declaration.init_declarator!"],
  functionCallee: [
    "call_expression[function]",
    "declaration.init_declarator[declarator]!"
  ],
  name: [
    "*[declarator][declarator][name]",
    "*[declarator][name]",
    "*[declarator][declarator]",
    "*[declarator]",
    "assignment_expression[left]",
    "*[name]"
  ],
  namedFunction: ["function_definition", "declaration.function_declarator"],
  type: trailingMatcher(TYPE_TYPES.concat(["*[type]"])),
  functionName: [
    "function_definition[declarator][declarator][name]",
    // void C::funcName() {}
    "function_definition[declarator][declarator]",
    // void funcName() {}
    "declaration.function_declarator![declarator]"
    // void funcName();
  ],
  value: leadingMatcher(
    [
      "*[declarator][value]",
      "*[value]",
      "assignment_expression[right]",
      "optional_parameter_declaration[default_value]"
    ],
    [":", "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "<<=", ">>="]
  ),
  argumentOrParameter: argumentMatcher("parameter_list", "argument_list"),
  attribute: "attribute"
};
var cpp_default = createPatternMatchers(nodeMatchers2);

// ../cursorless-engine/src/languages/csharp.ts
var STATEMENT_TYPES2 = [
  "class_declaration",
  "constructor_declaration",
  "conversion_operator_declaration",
  "delegate_declaration",
  "destructor_declaration",
  "enum_declaration",
  "event_declaration",
  "event_field_declaration",
  "field_declaration",
  "indexer_declaration",
  "interface_declaration",
  "method_declaration",
  "namespace_declaration",
  "operator_declaration",
  "property_declaration",
  "record_declaration",
  "struct_declaration",
  "using_directive",
  "block",
  "break_statement",
  "checked_statement",
  "continue_statement",
  "do_statement",
  "empty_statement",
  "expression_statement",
  "fixed_statement",
  "for_each_statement",
  "for_statement",
  "goto_statement",
  "if_statement",
  "labeled_statement",
  "local_declaration_statement",
  "local_function_statement",
  "lock_statement",
  "return_statement",
  "switch_statement",
  "throw_statement",
  "try_statement",
  "unsafe_statement",
  "using_statement",
  "while_statement",
  "yield_statement"
];
var NAMED_FUNCTION_TYPES = [
  "delegate_declaration",
  "local_function_statement",
  "method_declaration"
];
var LIST_TYPES_WITH_INITIALIZERS_AS_CHILDREN = [
  "array_creation_expression",
  "implicit_array_creation_expression",
  "implicit_stack_alloc_array_creation_expression",
  "stack_alloc_array_creation_expression"
];
var OBJECT_TYPES_WITH_INITIALIZERS_AS_CHILDREN = [
  "implicit_object_creation_expression"
];
var getChildInitializerNode = (node) => node.children.find((child) => child.type === "initializer_expression") ?? null;
var getInitializerNode = (node) => node.childForFieldName("initializer");
var makeDelimitedSelector = (leftType, rightType) => delimitedSelector(
  (node) => node.type === "," || node.type === leftType || node.type === rightType,
  ", "
);
var getMapMatchers = {
  map: cascadingMatcher(
    chainedMatcher([
      typedNodeFinder(...OBJECT_TYPES_WITH_INITIALIZERS_AS_CHILDREN),
      getChildInitializerNode
    ]),
    chainedMatcher([
      typedNodeFinder("object_creation_expression"),
      getInitializerNode
    ])
  ),
  collectionKey: chainedMatcher([
    typedNodeFinder("assignment_expression"),
    (node) => node.childForFieldName("left")
  ]),
  value: leadingMatcher(
    [
      "variable_declaration?.variable_declarator[1][0]!",
      "assignment_expression[right]"
    ],
    ["assignment_operator"]
  ),
  list: cascadingMatcher(
    chainedMatcher([
      typedNodeFinder(...LIST_TYPES_WITH_INITIALIZERS_AS_CHILDREN),
      getChildInitializerNode
    ]),
    chainedMatcher([
      typedNodeFinder("object_creation_expression"),
      (node) => node.childForFieldName("initializer")
    ])
  ),
  string: typeMatcher("string_literal")
};
var nodeMatchers3 = {
  ...getMapMatchers,
  className: "class_declaration[name]",
  condition: cascadingMatcher(
    conditionMatcher("*[condition]"),
    patternMatcher("while_statement[0]")
  ),
  ["private.switchStatementSubject"]: [
    "switch_statement.tuple_expression!",
    "switch_statement[value]"
  ],
  statement: STATEMENT_TYPES2,
  anonymousFunction: "lambda_expression",
  functionCall: ["invocation_expression", "object_creation_expression"],
  functionCallee: cascadingMatcher(
    patternMatcher("invocation_expression[function]"),
    matcher(
      patternFinder("object_creation_expression"),
      childRangeSelector(["argument_list"], [])
    )
  ),
  argumentOrParameter: matcher(
    nodeFinder(
      (node) => node.parent?.type === "argument_list" || node.type === "parameter"
    ),
    makeDelimitedSelector("(", ")")
  ),
  namedFunction: NAMED_FUNCTION_TYPES,
  functionName: NAMED_FUNCTION_TYPES.map((t) => t + "[name]"),
  comment: "comment",
  regularExpression: "regex",
  type: trailingMatcher(["*[type]"]),
  name: [
    "variable_declaration?.variable_declarator.identifier!",
    "assignment_expression[left]",
    "*[name]"
  ]
};
var csharp_default = createPatternMatchers(nodeMatchers3);

// ../cursorless-engine/src/languages/go.ts
var nodeMatchers4 = {
  ifStatement: "if_statement",
  functionCall: ["call_expression", "composite_literal"],
  functionCallee: ["call_expression[function]", "composite_literal[type]"],
  type: [
    "pointer_type",
    "qualified_type",
    "type_identifier",
    "function_declaration[result]",
    "method_declaration[result]"
  ],
  condition: conditionMatcher("*[condition]"),
  argumentOrParameter: cascadingMatcher(
    argumentMatcher("argument_list", "parameter_list"),
    patternMatcher("parameter_declaration"),
    patternMatcher("argument_declaration")
  ),
  collectionKey: "keyed_element[0]",
  value: cascadingMatcher(
    patternMatcher("keyed_element[1]"),
    patternMatcher("return_statement.expression_list!")
  )
};
var go_default = createPatternMatchers(nodeMatchers4);

// ../cursorless-engine/src/languages/java.ts
var nodeMatchers5 = {
  argumentOrParameter: argumentMatcher("formal_parameters", "argument_list")
};
var java_default = createPatternMatchers(nodeMatchers5);

// ../cursorless-engine/src/languages/latex.ts
var COMMANDS = [
  "command",
  "displayed_equation",
  "inline_formula",
  "math_set",
  "block_comment",
  "package_include",
  "class_include",
  "latex_include",
  "biblatex_include",
  "bibtex_include",
  "graphics_include",
  "svg_include",
  "inkscape_include",
  "verbatim_include",
  "import_include",
  "caption",
  "citation",
  "label_definition",
  "label_reference",
  "label_reference_range",
  "label_number",
  "new_command_definition",
  "old_command_definition",
  "let_command_definition",
  "environment_definition",
  "glossary_entry_definition",
  "glossary_entry_reference",
  "acronym_definition",
  "acronym_reference",
  "theorem_definition",
  "color_definition",
  "color_set_definition",
  "color_reference",
  "tikz_library_import"
];
var GROUPS = [
  "curly_group",
  "curly_group_text",
  "curly_group_text_list",
  "curly_group_path",
  "curly_group_path_list",
  "curly_group_command_name",
  "curly_group_key_value",
  "curly_group_glob_pattern",
  "curly_group_impl",
  "brack_group",
  "brack_group_text",
  "brack_group_argc",
  "brack_group_key_value",
  "mixed_group"
];
var SECTIONING = [
  "subparagraph",
  "paragraph",
  "subsubsection",
  "subsection",
  "section",
  "chapter",
  "part"
];
var ENVIRONMENTS = [
  "generic_environment",
  "comment_environment",
  "verbatim_environment",
  "listing_environment",
  "minted_environment",
  "pycode_environment"
];
var sectioningText = SECTIONING.map((s) => `${s}[text]`);
var sectioningCommand = SECTIONING.map((s) => `${s}[command]`);
function unwrapGroupParens(editor, node) {
  return {
    selection: new Selection(
      editor.document.positionAt(node.startIndex + 1),
      editor.document.positionAt(node.endIndex - 1)
    ),
    context: {
      removalRange: new Selection(
        editor.document.positionAt(node.startIndex),
        editor.document.positionAt(node.endIndex)
      )
    }
  };
}
function extendToNamedSiblingIfExists(editor, node) {
  const startIndex = node.startIndex;
  let endIndex = node.endIndex;
  const sibling = node.nextNamedSibling;
  if (sibling != null && sibling.isNamed()) {
    endIndex = sibling.endIndex;
  }
  return {
    selection: new Selection(
      editor.document.positionAt(startIndex),
      editor.document.positionAt(endIndex)
    ),
    context: {}
  };
}
function extractItemContent(editor, node) {
  let contentStartIndex = node.startIndex;
  const label = node.childForFieldName("label");
  if (label == null) {
    const command = node.childForFieldName("command");
    if (command != null) {
      contentStartIndex = command.endIndex + 1;
    }
  } else {
    contentStartIndex = label.endIndex + 1;
  }
  return {
    selection: new Selection(
      editor.document.positionAt(contentStartIndex),
      editor.document.positionAt(node.endIndex)
    ),
    context: {
      leadingDelimiterRange: new Range(
        editor.document.positionAt(node.startIndex),
        editor.document.positionAt(contentStartIndex - 1)
      )
    }
  };
}
var getStartTag = patternMatcher(`*.begin!`);
var getEndTag = patternMatcher(`*.end!`);
var getTags = (selection, node) => {
  const startTag = getStartTag(selection, node);
  const endTag = getEndTag(selection, node);
  return startTag != null && endTag != null ? startTag.concat(endTag) : null;
};
var nodeMatchers6 = {
  argumentOrParameter: cascadingMatcher(
    ancestorChainNodeMatcher(
      [patternFinder(...COMMANDS), patternFinder(...GROUPS)],
      1,
      unwrapGroupParens
    ),
    matcher(
      patternFinder("begin[name]", "end[name]", ...sectioningText),
      unwrapGroupParens
    )
  ),
  functionCall: cascadingMatcher(
    matcher(patternFinder(...COMMANDS, "begin", "end")),
    matcher(patternFinder(...sectioningCommand), extendToNamedSiblingIfExists)
  ),
  name: cascadingMatcher(
    matcher(patternFinder(...sectioningText), unwrapGroupParens),
    patternMatcher("begin[name][text]", "end[name][text]")
  ),
  functionCallee: "command_name",
  collectionItem: matcher(patternFinder("enum_item"), extractItemContent),
  part: "part",
  chapter: "chapter",
  section: "section",
  subSection: "subsection",
  subSubSection: "subsubsection",
  namedParagraph: "paragraph",
  subParagraph: "subparagraph",
  environment: ENVIRONMENTS,
  xmlElement: ENVIRONMENTS,
  xmlBothTags: getTags,
  xmlStartTag: getStartTag,
  xmlEndTag: getEndTag
};
var latex_default = createPatternMatchers(nodeMatchers6);

// ../cursorless-engine/src/languages/markdown.ts
var HEADING_MARKER_TYPES = [
  "atx_h1_marker",
  "atx_h2_marker",
  "atx_h3_marker",
  "atx_h4_marker",
  "atx_h5_marker",
  "atx_h6_marker"
];
function makeMinimumHeadingLevelFinder(headingType) {
  const markerIndex = HEADING_MARKER_TYPES.indexOf(headingType);
  return (node) => {
    return node.type === "atx_heading" && HEADING_MARKER_TYPES.indexOf(
      node.firstNamedChild?.type
    ) <= markerIndex ? node : null;
  };
}
function sectionExtractor(editor, node) {
  const finder = makeMinimumHeadingLevelFinder(
    node.firstNamedChild?.type
  );
  const { context, selection } = extendUntilNextMatchingSiblingOrLast(
    editor,
    node,
    finder
  );
  return {
    context,
    selection: shrinkRangeToFitContent(editor, selection).toSelection(
      selection.isReversed
    )
  };
}
function sectionMatcher(...patterns) {
  const finder = patternFinder(...patterns);
  return matcher(leadingSiblingNodeFinder(finder), sectionExtractor);
}
var nodeMatchers7 = {
  section: sectionMatcher("atx_heading"),
  sectionLevelOne: sectionMatcher("atx_heading.atx_h1_marker"),
  sectionLevelTwo: sectionMatcher("atx_heading.atx_h2_marker"),
  sectionLevelThree: sectionMatcher("atx_heading.atx_h3_marker"),
  sectionLevelFour: sectionMatcher("atx_heading.atx_h4_marker"),
  sectionLevelFive: sectionMatcher("atx_heading.atx_h5_marker"),
  sectionLevelSix: sectionMatcher("atx_heading.atx_h6_marker")
};
var markdown_default = createPatternMatchers(nodeMatchers7);

// ../cursorless-engine/src/languages/php.ts
var assignmentOperators = [
  "=",
  // Arithmetic
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "**=",
  // Bitwise
  "&=",
  "|=",
  "^=",
  "<<=",
  ">>=",
  // Other
  ".=",
  "??="
];
function castTypeExtractor(editor, node) {
  const range4 = getNodeRange(node);
  const contentRange = range4;
  const leftParenRange = getNodeRange(node.previousSibling);
  const rightParenRange = getNodeRange(node.nextSibling.nextSibling);
  const removalRange = range4.with(leftParenRange.start, rightParenRange.start);
  return {
    selection: new Selection(contentRange.start, contentRange.end),
    context: {
      removalRange
    }
  };
}
var nodeMatchers8 = {
  name: [
    "assignment_expression[left]",
    "class_declaration[name]",
    "function_definition[name]",
    "method_declaration[name]"
  ],
  type: cascadingMatcher(
    trailingMatcher(["~cast_expression[type]"]),
    matcher(patternFinder("cast_expression[type]"), castTypeExtractor)
  ),
  value: leadingMatcher(
    [
      "array_element_initializer[1]",
      "assignment_expression[right]",
      "augmented_assignment_expression[right]",
      "return_statement[0]",
      "yield_expression[0]"
    ],
    assignmentOperators.concat(["=>"])
  ),
  collectionKey: trailingMatcher(["array_element_initializer[0]"], ["=>"]),
  argumentOrParameter: argumentMatcher("arguments", "formal_parameters")
};
var php_default = createPatternMatchers(nodeMatchers8);

// ../cursorless-engine/src/languages/python.ts
function itemNodeFinder(parentType, childType, excludeFirstChild = false) {
  const finder = argumentNodeFinder(parentType);
  return (node, selection) => {
    const childNode = finder(node, selection);
    if (childNode?.type === childType && (!excludeFirstChild || childNode.id !== childNode.parent?.firstNamedChild?.id)) {
      return childNode;
    }
    return null;
  };
}
var nodeMatchers9 = {
  collectionItem: cascadingMatcher(
    matcher(
      itemNodeFinder("import_from_statement", "dotted_name", true),
      argumentSelectionExtractor()
    ),
    matcher(
      itemNodeFinder("import_statement", "dotted_name", false),
      argumentSelectionExtractor()
    ),
    matcher(
      itemNodeFinder("global_statement", "identifier"),
      argumentSelectionExtractor()
    )
  ),
  argumentOrParameter: cascadingMatcher(
    argumentMatcher("parameters", "argument_list"),
    matcher(patternFinder("call.generator_expression!"), childRangeSelector())
  )
};
var python_default = createPatternMatchers(nodeMatchers9);

// ../cursorless-engine/src/languages/ruby.ts
var STATEMENT_TYPES3 = [
  "alias",
  "begin_block",
  "end_block",
  "if_modifier",
  "rescue_modifier",
  "undef",
  "unless_modifier",
  "until_modifier",
  "while_modifier"
];
var EXPRESSION_TYPES = [
  "array",
  "assignment",
  "begin",
  "binary",
  "break",
  "call",
  "case",
  "case_match",
  "chained_string",
  "character",
  "class",
  "class_variable",
  "complex",
  "conditional",
  "constant",
  "delimited_symbol",
  "element_reference",
  "false",
  "float",
  "for",
  "global_variable",
  "hash",
  "heredoc_beginning",
  "identifier",
  "if",
  "instance_variable",
  "integer",
  "lambda",
  "method",
  "module",
  "next",
  "nil",
  "operator_assignment",
  "parenthesized_statements",
  "range",
  "rational",
  "redo",
  "regex",
  "retry",
  "return",
  "scope_resolution",
  "self",
  "simple_symbol",
  "singleton_class",
  "singleton_method",
  "string",
  "string_array",
  "subshell",
  "super",
  "symbol_array",
  "true",
  "unary",
  "unless",
  "until",
  "while",
  "yield"
];
var EXPRESSION_STATEMENT_PARENT_TYPES = [
  "begin",
  "block",
  "do",
  "do_block",
  "else",
  "ensure",
  "heredoc_beginning",
  "lambda",
  "method",
  "program",
  "singleton_class",
  "singleton_method",
  "then"
];
var mapTypes = ["hash"];
var listTypes = ["array", "string_array", "symbol_array"];
var assignmentOperators2 = [
  "=",
  "+=",
  "-=",
  "*=",
  "**=",
  "/=",
  "||=",
  "|=",
  "&&=",
  "&=",
  "%=",
  ">>=",
  "<<=",
  "^="
];
var mapKeyValueSeparators = [":", "=>"];
function blockFinder(node) {
  if (node.type !== "call") {
    return null;
  }
  const receiver = node.childForFieldName("receiver");
  const method = node.childForFieldName("method");
  const block = node.childForFieldName("block");
  if (receiver?.text === "Proc" && method?.text === "new" || receiver == null && method?.text === "lambda") {
    return node;
  }
  return block;
}
var nodeMatchers10 = {
  statement: cascadingMatcher(
    patternMatcher(...STATEMENT_TYPES3),
    ancestorChainNodeMatcher(
      [
        patternFinder(...EXPRESSION_STATEMENT_PARENT_TYPES),
        patternFinder(...EXPRESSION_TYPES)
      ],
      1
    )
  ),
  string: "string",
  functionName: ["method[name]", "singleton_method[name]"],
  anonymousFunction: cascadingMatcher(
    patternMatcher("lambda", "do_block"),
    matcher(blockFinder)
  ),
  condition: conditionMatcher("*[condition]"),
  argumentOrParameter: argumentMatcher(
    "lambda_parameters",
    "method_parameters",
    "block_parameters",
    "argument_list"
  ),
  collectionKey: trailingMatcher(["pair[key]"], [":"]),
  name: [
    "assignment[left]",
    "operator_assignment[left]",
    "class[name]",
    "method[name]",
    "singleton_method[name]"
  ],
  value: leadingMatcher(
    [
      "pair[value]",
      "assignment[right]",
      "operator_assignment[right]",
      "return.argument_list!"
    ],
    assignmentOperators2.concat(mapKeyValueSeparators)
  ),
  collectionItem: argumentMatcher(...mapTypes, ...listTypes)
};
var patternMatchers = createPatternMatchers(nodeMatchers10);
function stringTextFragmentExtractor(node, _selection) {
  if (node.type === "string_content" || node.type === "heredoc_content") {
    return getNodeRange(node);
  }
  return null;
}

// ../cursorless-engine/src/languages/elseIfExtractor.ts
function elseIfExtractor() {
  const contentRangeExtractor = childRangeSelector(["else_clause"], [], {
    includeUnnamedChildren: true
  });
  return function(editor, node) {
    const contentRange = contentRangeExtractor(editor, node);
    const parent = node.parent;
    if (parent?.type !== "else_clause") {
      const alternative = node.childForFieldName("alternative");
      if (alternative == null) {
        return contentRange;
      }
      const { selection: selection2 } = contentRange;
      return {
        selection: selection2,
        context: {
          removalRange: new Selection(
            selection2.start,
            positionFromPoint(alternative.namedChild(0).startPosition)
          )
        }
      };
    }
    const { selection } = contentRange;
    return {
      selection: new Selection(
        positionFromPoint(parent.child(0).startPosition),
        selection.end
      ),
      context: {}
    };
  };
}
function elseExtractor(ifNodeType) {
  const nestedElseIfExtractor = elseIfExtractor();
  return function(editor, node) {
    return node.namedChild(0).type === ifNodeType ? nestedElseIfExtractor(editor, node.namedChild(0)) : simpleSelectionExtractor(editor, node);
  };
}

// ../cursorless-engine/src/languages/rust.ts
var STATEMENT_TYPES4 = [
  "associated_type",
  "attribute_item",
  "const_item",
  "empty_statement",
  "enum_item",
  "extern_crate_declaration",
  "foreign_mod_item",
  "impl_item",
  "inner_attribute_item",
  "let_declaration",
  "macro_definition",
  "macro_invocation",
  "function_item",
  "function_signature_item",
  "mod_item",
  "static_item",
  "struct_item",
  "trait_item",
  "type_item",
  "union_item",
  "use_declaration",
  "expression_statement"
];
var STATEMENT_PARENT_TYPES = ["source_file", "block", "declaration_list"];
function implItemTypeFinder(node) {
  if (node.parent?.type === "impl_item" && node.parent?.childForFieldName("type")?.equals(node)) {
    return node;
  }
  return null;
}
function traitBoundExtractor(editor, node) {
  return {
    selection: makeNodePairSelection(node.children[1], node.lastNamedChild),
    context: {
      leadingDelimiterRange: makeRangeFromPositions(
        node.children[0].startPosition,
        node.children[1].startPosition
      )
    }
  };
}
function returnValueFinder(node) {
  if (node.type !== "block") {
    return null;
  }
  const { lastNamedChild } = node;
  if (lastNamedChild == null) {
    return null;
  }
  if (lastNamedChild.type === "expression_statement") {
    const expression = lastNamedChild.child(0);
    if (expression.type === "return_expression") {
      return expression.child(1);
    }
    return null;
  }
  if (STATEMENT_TYPES4.includes(lastNamedChild.type)) {
    return null;
  }
  if (lastNamedChild.type === "return_expression") {
    return lastNamedChild.child(1);
  }
  return lastNamedChild;
}
var nodeMatchers11 = {
  statement: ancestorChainNodeMatcher(
    [
      patternFinder(...STATEMENT_PARENT_TYPES),
      patternFinder(...STATEMENT_TYPES4)
    ],
    1
  ),
  string: ["raw_string_literal", "string_literal"],
  condition: cascadingMatcher(
    patternMatcher("while_expression[condition]", "if_expression[condition]"),
    matcher(
      patternFinder("while_let_expression", "if_let_expression"),
      childRangeSelector(["while", "if", "block"], [], {
        includeUnnamedChildren: true
      })
    ),
    leadingMatcher(["*.match_pattern![condition]"], ["if"])
  ),
  functionCall: ["call_expression", "macro_invocation", "struct_expression"],
  functionCallee: "call_expression[function]",
  comment: ["line_comment", "block_comment"],
  list: ["array_expression", "tuple_expression"],
  collectionItem: argumentMatcher(
    "array_expression",
    "tuple_expression",
    "tuple_type"
  ),
  namedFunction: "function_item",
  type: cascadingMatcher(
    leadingMatcher(
      [
        "let_declaration[type]",
        "parameter[type]",
        "field_declaration[type]",
        "const_item[type]"
      ],
      [":"]
    ),
    matcher(
      patternFinder(
        "constrained_type_parameter[bounds]",
        "where_predicate[bounds]"
      ),
      traitBoundExtractor
    ),
    leadingMatcher(["function_item[return_type]"], ["->"]),
    matcher(implItemTypeFinder),
    patternMatcher(
      "struct_item",
      "trait_item",
      "impl_item",
      "array_type[element]"
    )
  ),
  functionName: ["function_item[name]"],
  anonymousFunction: "closure_expression",
  argumentOrParameter: argumentMatcher(
    "arguments",
    "parameters",
    "meta_arguments",
    "type_parameters",
    "ordered_field_declaration_list"
  ),
  collectionKey: cascadingMatcher(
    trailingMatcher(["field_initializer[name]", "field_pattern[name]"], [":"])
  ),
  name: cascadingMatcher(
    patternMatcher(
      "let_declaration.identifier!",
      "parameter.identifier!",
      "function_item[name]",
      "struct_item[name]",
      "enum_item[name]",
      "enum_variant[name]",
      "trait_item[name]",
      "const_item[name]",
      "meta_item.identifier!",
      "let_declaration[pattern]",
      "constrained_type_parameter[left]",
      "where_predicate[left]",
      "field_declaration[name]"
    ),
    trailingMatcher(["field_initializer[name]", "field_pattern[name]"], [":"])
  ),
  class: ["struct_item", "struct_expression", "enum_item"],
  className: ["struct_item[name]", "enum_item[name]", "trait_item[name]"],
  value: cascadingMatcher(
    leadingMatcher(["let_declaration[value]"], ["="]),
    leadingMatcher(
      ["field_initializer[value]", "field_pattern[pattern]"],
      [":"]
    ),
    patternMatcher("meta_item[value]", "const_item[value]"),
    matcher(returnValueFinder)
  ),
  attribute: trailingMatcher(["mutable_specifier", "attribute_item"]),
  branch: cascadingMatcher(
    patternMatcher("match_arm"),
    matcher(patternFinder("else_clause"), elseExtractor("if_expression")),
    matcher(patternFinder("if_expression"), elseIfExtractor())
  ),
  ["private.switchStatementSubject"]: "match_expression[value]"
};
var rust_default = createPatternMatchers(nodeMatchers11);

// ../cursorless-engine/src/languages/scala.ts
var nodeMatchers12 = {
  // treating classes = classlike
  class: ["class_definition", "object_definition", "trait_definition"],
  className: [
    "class_definition[name]",
    "object_definition[name]",
    "trait_definition[name]"
  ],
  string: ["interpolated_string_expression", "string"],
  comment: "comment",
  // list.size(), does not count foo.size (field_expression), or foo size (postfix_expression)
  functionCall: "call_expression",
  namedFunction: "function_definition",
  anonymousFunction: "lambda_expression",
  argumentOrParameter: argumentMatcher(
    "arguments",
    "parameters",
    "class_parameters",
    "bindings"
  ),
  branch: matcher(
    patternFinder("case_clause"),
    childRangeSelector([], [], {
      includeUnnamedChildren: true
    })
  ),
  ["private.switchStatementSubject"]: "match_expression[value]",
  name: ["*[name]", "*[pattern]"],
  functionName: "function_definition[name]",
  // *[type] does not work here because while we want most of these we don't want "compound" types,
  // eg `generic_type[type]`, because that will grab just the inner generic (the String of List[String])
  // and as a rule we want to grab entire type definitions.
  type: leadingMatcher(
    [
      "upper_bound[type]",
      "lower_bound[type]",
      "view_bound[type]",
      "context_bound[type]",
      "val_definition[type]",
      "val_declaration[type]",
      "var_definition[type]",
      "var_declaration[type]",
      "type_definition",
      "extends_clause[type]",
      "class_parameter[type]",
      "parameter[type]",
      "function_definition[return_type]",
      "typed_pattern[type]",
      "binding[type]"
    ],
    [":"]
  ),
  value: leadingMatcher(
    ["*[value]", "*[default_value]", "type_definition[type]"],
    ["="]
  ),
  condition: conditionMatcher("*[condition]")
  // Scala features unsupported in Cursorless terminology
  //  - Pattern matching
  // Cursorless terminology not yet supported in this Scala implementation
  /*
    lists and maps basic definition are just function calls to constructors, eg List(1,2,3,4)
    These types are also basically arbitrary, so we can't really hard-code them
    There is also fancy list style: val foo = 1 :: (2 :: (3 :: Nil)) // List(1,2,3)
  */
  // list: 'call_expression',
  // map: 'call_expression',
  /* infix_expression, key on left, item on right, operator = "->"
    // collectionItem: "???"
    // collectionKey: "???",

    /* "foo".r <-, value of type field_expression, value of type string, field of type identifier = "r",
    // regularExpression: "???",

    /*
      none of this stuff is defined well in the tree sitter (it's all just infix expressions etc),
      and native XML/HTML is deprecated in Scala 3
    */
  // attribute: "???",
  // xmlElement: "???",
  // xmlStartTag: "???",
  // xmlEndTag: "???",
  // xmlBothTags: "???",
};
var scala_default = createPatternMatchers(nodeMatchers12);

// ../cursorless-engine/src/languages/scss.ts
var STATEMENT_TYPES5 = [
  "apply_statement",
  "at_rule",
  "charset_statement",
  "debug_statement",
  "each_statement",
  "error_statement",
  "for_statement",
  "forward_statement",
  "function_statement",
  "if_statement",
  "import_statement",
  "include_statement",
  "keyframes_statement",
  "media_statement",
  "mixin_statement",
  "namespace_statement",
  "placeholder",
  "rule_set",
  "supports_statement",
  "use_statement",
  "warn_statement",
  "while_statement"
];
function isArgumentListDelimiter(node) {
  return [",", "(", ")"].includes(node.type) || isAtDelimiter(node);
}
function isAtDelimiter(node) {
  return node.type === "plain_value" && node.text === "at";
}
function findAdjacentArgValues(siblingFunc) {
  return (node) => {
    if (isAtDelimiter(node) || node.type === ",") {
      node = node.previousSibling;
    }
    let nextPossibleRange = siblingFunc(node);
    while (nextPossibleRange && !isArgumentListDelimiter(nextPossibleRange)) {
      node = nextPossibleRange;
      nextPossibleRange = siblingFunc(nextPossibleRange);
    }
    return node;
  };
}
function unitMatcher(selection, node) {
  if (node.type !== "declaration") {
    return null;
  }
  return node.descendantsOfType("unit").map((n) => ({
    node: n,
    selection: simpleSelectionExtractor(selection.editor, n)
  }));
}
var nodeMatchers13 = {
  ifStatement: "if_statement",
  condition: conditionMatcher("condition"),
  statement: cascadingMatcher(
    patternMatcher(...STATEMENT_TYPES5),
    matcher(
      patternFinder("attribute_selector"),
      childRangeSelector([], ["attribute_name", "string_value"])
    )
  ),
  functionCall: "call_expression",
  functionCallee: "call_expression.function_name!",
  namedFunction: ["mixin_statement", "function_statement"],
  functionName: ["mixin_statement.name!", "function_statement.name!"],
  argumentOrParameter: cascadingMatcher(
    matcher(
      patternFinder("arguments.*!", "parameters.*!"),
      delimitedSelector(
        (node) => isArgumentListDelimiter(node),
        ", ",
        findAdjacentArgValues((node) => node.previousSibling),
        findAdjacentArgValues((node) => node.nextSibling)
      )
    )
  ),
  name: [
    "function_statement.name!",
    "declaration.property_name!",
    "declaration.variable_name!",
    "mixin_statement.name!",
    "attribute_selector.attribute_name!",
    "parameter.variable_name!"
  ],
  selector: ["rule_set.selectors!"],
  collectionKey: trailingMatcher(["declaration.property_name!"], [":"]),
  value: cascadingMatcher(
    matcher(
      patternFinder("declaration"),
      childRangeSelector(["property_name", "variable_name"])
    ),
    matcher(
      patternFinder("include_statement", "namespace_statement"),
      childRangeSelector()
    ),
    patternMatcher(
      "return_statement.*!",
      "import_statement.*!",
      "attribute_selector.plain_value!",
      "attribute_selector.string_value!",
      "parameter.default_value!"
    )
  ),
  unit: cascadingMatcher(patternMatcher("integer_value.unit!"), unitMatcher),
  collectionItem: "declaration"
};
var patternMatchers2 = createPatternMatchers(nodeMatchers13);

// ../cursorless-engine/src/languages/getNodeMatcher.ts
function getNodeMatcher(languageId, scopeTypeType, includeSiblings) {
  const matchers2 = languageMatchers[languageId];
  if (matchers2 == null) {
    throw new UnsupportedLanguageError(languageId);
  }
  const matcher2 = matchers2[scopeTypeType];
  if (matcher2 == null) {
    return notSupported;
  }
  if (includeSiblings) {
    return matcherIncludeSiblings(matcher2);
  }
  return matcher2;
}
var languageMatchers = {
  c: cpp_default,
  clojure: clojure_default,
  cpp: cpp_default,
  csharp: csharp_default,
  css: patternMatchers2,
  go: go_default,
  java: java_default,
  latex: latex_default,
  markdown: markdown_default,
  php: php_default,
  python: python_default,
  ruby: patternMatchers,
  rust: rust_default,
  scala: scala_default,
  scss: patternMatchers2
};
function matcherIncludeSiblings(matcher2) {
  return (selection, node) => {
    let matches = matcher2(selection, node);
    if (matches == null) {
      return null;
    }
    matches = matches.flatMap(
      (match2) => iterateNearestIterableAncestor(
        match2.node,
        selectionWithEditorFromRange(selection, match2.selection.selection),
        matcher2
      )
    );
    if (matches.length > 0) {
      return matches;
    }
    return null;
  };
}
function iterateNearestIterableAncestor(node, selection, nodeMatcher) {
  let parent = node.parent;
  while (parent != null) {
    const matches = parent.namedChildren.flatMap((sibling) => nodeMatcher(selection, sibling)).filter((match2) => match2 != null);
    if (matches.length > 0) {
      return matches;
    }
    parent = parent.parent;
  }
  return [];
}

// ../cursorless-engine/src/processTargets/modifiers/scopeTypeStages/LegacyContainingSyntaxScopeStage.ts
var LegacyContainingSyntaxScopeStage = class {
  constructor(languageDefinitions, modifier) {
    this.languageDefinitions = languageDefinitions;
    this.modifier = modifier;
  }
  run(target) {
    const nodeMatcher = getNodeMatcher(
      target.editor.document.languageId,
      this.modifier.scopeType.type,
      this.modifier.type === "everyScope"
    );
    const node = this.languageDefinitions.getNodeAtLocation(
      target.editor.document,
      target.contentRange
    );
    const scopeNodes = findNearestContainingAncestorNode(node, nodeMatcher, {
      editor: target.editor,
      selection: new Selection(
        target.contentRange.start,
        target.contentRange.end
      )
    });
    if (scopeNodes == null) {
      throw new NoContainingScopeError(this.modifier.scopeType.type);
    }
    return scopeNodes.map((scope) => {
      const {
        containingListDelimiter,
        leadingDelimiterRange,
        trailingDelimiterRange,
        removalRange,
        interiorRange
      } = scope.context;
      if (removalRange != null && (leadingDelimiterRange != null || trailingDelimiterRange != null)) {
        throw Error(
          "Removal range is mutually exclusive with leading or trailing delimiter range"
        );
      }
      const { editor, selection: contentSelection } = scope.selection;
      return new ScopeTypeTarget({
        scopeTypeType: this.modifier.scopeType.type,
        editor,
        isReversed: target.isReversed,
        contentRange: contentSelection,
        removalRange,
        interiorRange,
        insertionDelimiter: containingListDelimiter,
        leadingDelimiterRange,
        trailingDelimiterRange
      });
    });
  }
};
function findNearestContainingAncestorNode(startNode, nodeMatcher, selection) {
  let node = startNode;
  while (node != null) {
    const matches = nodeMatcher(selection, node);
    if (matches != null) {
      return matches.map((match2) => match2.selection).map((matchedSelection) => ({
        selection: selectionWithEditorFromRange(
          selection,
          matchedSelection.selection
        ),
        context: matchedSelection.context
      }));
    }
    node = node.parent;
  }
  return null;
}

// ../cursorless-engine/src/languages/getTextFragmentExtractor.ts
function constructDefaultTextFragmentExtractor(languageId, stringTextFragmentExtractor2) {
  const commentNodeMatcher = getNodeMatcher(languageId, "comment", false);
  stringTextFragmentExtractor2 = stringTextFragmentExtractor2 ?? constructDefaultStringTextFragmentExtractor(languageId);
  return (node, selection) => {
    const stringTextFragment = stringTextFragmentExtractor2(node, selection);
    if (stringTextFragment != null) {
      return stringTextFragment;
    }
    if (commentNodeMatcher !== notSupported && commentNodeMatcher(selection, node) != null) {
      return getNodeRange(node);
    }
    if (node.type === "ERROR") {
      return getNodeRange(node);
    }
    return null;
  };
}
function constructDefaultStringTextFragmentExtractor(languageId) {
  const stringNodeMatcher = getNodeMatcher(languageId, "string", false);
  return (node, selection) => {
    if (stringNodeMatcher(selection, node) != null) {
      return getNodeInternalRange(node);
    }
    return null;
  };
}
function constructHackedStringTextFragmentExtractor(languageId) {
  const stringNodeMatcher = getNodeMatcher(languageId, "string", false);
  return (node, selection) => {
    if (stringNodeMatcher(selection, node) != null) {
      return getNodeRange(node);
    }
    return null;
  };
}
function getTextFragmentExtractor(languageId) {
  return textFragmentExtractors[languageId];
}
var textFragmentExtractors = {
  ruby: constructDefaultTextFragmentExtractor(
    "ruby",
    stringTextFragmentExtractor
  ),
  scala: constructDefaultTextFragmentExtractor(
    "scala",
    constructHackedStringTextFragmentExtractor("scala")
  ),
  rust: constructDefaultTextFragmentExtractor("rust")
};

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/delimiterMaps.ts
var delimiterToText = Object.freeze({
  angleBrackets: [
    ["</", "<"],
    [">", "/>"]
  ],
  backtickQuotes: ["`", "`"],
  curlyBrackets: [["{", "${"], "}"],
  doubleQuotes: ['"', '"'],
  escapedDoubleQuotes: ['\\"', '\\"'],
  escapedParentheses: ["\\(", "\\)"],
  escapedSquareBrackets: ["\\[", "\\]"],
  escapedSingleQuotes: ["\\'", "\\'"],
  parentheses: [["(", "$("], ")"],
  singleQuotes: ["'", "'"],
  squareBrackets: ["[", "]"]
});
var leftToRightMap = Object.fromEntries(
  Object.values(delimiterToText)
);
var complexDelimiterMap = {
  any: unsafeKeys(delimiterToText),
  string: ["singleQuotes", "doubleQuotes", "backtickQuotes"],
  collectionBoundary: [
    "parentheses",
    "squareBrackets",
    "curlyBrackets",
    "angleBrackets"
  ]
};

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/extractSelectionFromSurroundingPairOffsets.ts
function extractSelectionFromSurroundingPairOffsets(document, baseOffset, surroundingPairOffsets) {
  const interior = new Range(
    document.positionAt(baseOffset + surroundingPairOffsets.leftDelimiter.end),
    document.positionAt(
      baseOffset + surroundingPairOffsets.rightDelimiter.start
    )
  );
  const boundary = [
    new Range(
      document.positionAt(
        baseOffset + surroundingPairOffsets.leftDelimiter.start
      ),
      document.positionAt(
        baseOffset + surroundingPairOffsets.leftDelimiter.end
      )
    ),
    new Range(
      document.positionAt(
        baseOffset + surroundingPairOffsets.rightDelimiter.start
      ),
      document.positionAt(
        baseOffset + surroundingPairOffsets.rightDelimiter.end
      )
    )
  ];
  return {
    contentRange: new Selection(
      document.positionAt(
        baseOffset + surroundingPairOffsets.leftDelimiter.start
      ),
      document.positionAt(
        baseOffset + surroundingPairOffsets.rightDelimiter.end
      )
    ),
    boundary,
    interiorRange: interior
  };
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/findSurroundingPairCore.ts
var import_lodash31 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters.ts
var import_lodash30 = __toESM(require_lodash(), 1);
function findUnmatchedDelimiter(delimiterOccurrences, initialIndex, acceptableDelimiters, lookForward) {
  const generatorResult = generateUnmatchedDelimiters(
    delimiterOccurrences,
    initialIndex,
    () => acceptableDelimiters,
    lookForward
  ).next();
  return generatorResult.done ? null : generatorResult.value;
}
function* generateUnmatchedDelimiters(delimiterOccurrences, initialIndex, getCurrentAcceptableDelimiters, lookForward) {
  const delimiterIncrements = lookForward ? {
    left: 1,
    right: -1,
    unknown: -1
  } : {
    left: -1,
    right: 1,
    unknown: -1
  };
  const delimiterBalances = {};
  let currentAcceptableDelimiters = getCurrentAcceptableDelimiters();
  const indices = lookForward ? (0, import_lodash30.range)(initialIndex, delimiterOccurrences.length, 1) : (0, import_lodash30.range)(initialIndex, -1, -1);
  for (const index of indices) {
    const delimiterOccurrence = delimiterOccurrences[index];
    const { delimiterInfo } = delimiterOccurrence;
    const delimiterName = delimiterInfo?.delimiter;
    if (delimiterName == null || !currentAcceptableDelimiters.includes(delimiterName)) {
      continue;
    }
    const increment = delimiterIncrements[delimiterInfo.side];
    const newDelimiterBalance = (delimiterBalances[delimiterName] ?? 0) + increment;
    if (newDelimiterBalance === -1) {
      yield delimiterOccurrence;
      currentAcceptableDelimiters = getCurrentAcceptableDelimiters();
      delimiterBalances[delimiterName] = 0;
    } else {
      delimiterBalances[delimiterName] = newDelimiterBalance;
    }
  }
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/findOppositeDelimiter.ts
function findOppositeDelimiter(delimiterOccurrences, index, delimiterInfo, forceDirection) {
  const { side, delimiter } = delimiterInfo;
  for (const direction of getDirections(side, forceDirection)) {
    const unmatchedDelimiter = findUnmatchedDelimiter(
      delimiterOccurrences,
      direction === "right" ? index + 1 : index - 1,
      [delimiter],
      direction === "right"
    );
    if (unmatchedDelimiter != null) {
      return unmatchedDelimiter;
    }
  }
  return null;
}
function getDirections(side, forceDirection) {
  if (forceDirection != null) {
    return [forceDirection];
  }
  switch (side) {
    case "left":
      return ["right"];
    case "right":
      return ["left"];
    case "unknown":
      return ["right", "left"];
  }
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/getSurroundingPairOffsets.ts
function getSurroundingPairOffsets(delimiter1, delimiter2) {
  const isDelimiter1First = delimiter1.offsets.start < delimiter2.offsets.start;
  const leftDelimiter = isDelimiter1First ? delimiter1 : delimiter2;
  const rightDelimiter = isDelimiter1First ? delimiter2 : delimiter1;
  return {
    leftDelimiter: leftDelimiter.offsets,
    rightDelimiter: rightDelimiter.offsets
  };
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/weaklyContains.ts
function weaklyContains(offsets1, offsets2) {
  return offsets1.start <= offsets2.start && offsets1.end >= offsets2.end;
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/findDelimiterPairAdjacentToSelection.ts
function findDelimiterPairAdjacentToSelection(initialIndex, delimiterOccurrences, selectionOffsets, scopeType, bailOnUnmatchedAdjacent = false) {
  const indicesToTry = [initialIndex + 1, initialIndex];
  for (const index of indicesToTry) {
    const delimiterOccurrence = delimiterOccurrences[index];
    if (delimiterOccurrence != null && weaklyContains(delimiterOccurrence.offsets, selectionOffsets)) {
      const { delimiterInfo } = delimiterOccurrence;
      if (delimiterInfo != null) {
        const possibleMatch = findOppositeDelimiter(
          delimiterOccurrences,
          index,
          delimiterInfo,
          scopeType.forceDirection
        );
        if (possibleMatch != null) {
          const surroundingPairOffsets = getSurroundingPairOffsets(
            delimiterOccurrence,
            possibleMatch
          );
          if (!scopeType.requireStrongContainment || surroundingPairOffsets.leftDelimiter.start < selectionOffsets.start && surroundingPairOffsets.rightDelimiter.end > selectionOffsets.end) {
            return surroundingPairOffsets;
          }
        } else if (bailOnUnmatchedAdjacent) {
          return null;
        }
      }
    }
  }
  return null;
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection.ts
function findDelimiterPairContainingSelection(initialIndex, delimiterOccurrences, acceptableDelimiters, selectionOffsets, scopeType) {
  const acceptableRightDelimiters = acceptableDelimiters;
  let acceptableLeftDelimiters = [];
  const rightDelimiterGenerator = generateUnmatchedDelimiters(
    delimiterOccurrences,
    initialIndex,
    () => acceptableRightDelimiters,
    true
  );
  const leftDelimiterGenerator = generateUnmatchedDelimiters(
    delimiterOccurrences,
    initialIndex - 1,
    () => acceptableLeftDelimiters,
    false
  );
  while (true) {
    const rightNext = rightDelimiterGenerator.next();
    if (rightNext.done) {
      return null;
    }
    const rightDelimiterOccurrence = rightNext.value;
    acceptableLeftDelimiters = [
      rightDelimiterOccurrence.delimiterInfo.delimiter
    ];
    const leftNext = leftDelimiterGenerator.next();
    if (leftNext.done) {
      return null;
    }
    const leftDelimiterOccurrence = leftNext.value;
    if (leftDelimiterOccurrence.offsets.start <= selectionOffsets.start) {
      if (scopeType.requireStrongContainment && !(leftDelimiterOccurrence.offsets.end <= selectionOffsets.start && rightDelimiterOccurrence.offsets.start >= selectionOffsets.end)) {
        continue;
      }
      return getSurroundingPairOffsets(
        leftDelimiterOccurrence,
        rightDelimiterOccurrence
      );
    }
  }
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/findSurroundingPairCore.ts
function findSurroundingPairCore(scopeType, delimiterOccurrences, acceptableDelimiters, selectionOffsets, bailOnUnmatchedAdjacent = false) {
  const initialIndex = (0, import_lodash31.sortedIndexBy)(
    delimiterOccurrences,
    {
      offsets: selectionOffsets
    },
    "offsets.end"
  );
  const delimiterPairAdjacentToSelection = findDelimiterPairAdjacentToSelection(
    initialIndex,
    delimiterOccurrences,
    selectionOffsets,
    scopeType,
    bailOnUnmatchedAdjacent
  );
  if (delimiterPairAdjacentToSelection != null) {
    return delimiterPairAdjacentToSelection;
  }
  return findDelimiterPairContainingSelection(
    initialIndex,
    delimiterOccurrences,
    acceptableDelimiters,
    selectionOffsets,
    scopeType
  );
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/getIndividualDelimiters.ts
var import_lodash32 = __toESM(require_lodash(), 1);
function getIndividualDelimiters(delimiters) {
  return delimiters.flatMap((delimiter) => {
    const [leftDelimiter, rightDelimiter] = delimiterToText[delimiter];
    const leftDelimiters = isString(leftDelimiter) ? [leftDelimiter] : leftDelimiter;
    const rightDelimiters = isString(rightDelimiter) ? [rightDelimiter] : rightDelimiter;
    const allDelimiterTexts = (0, import_lodash32.uniq)((0, import_lodash32.concat)(leftDelimiters, rightDelimiters));
    return allDelimiterTexts.map((text) => {
      const isLeft = leftDelimiters.includes(text);
      const isRight = rightDelimiters.includes(text);
      return {
        text,
        // If delimiter text is the same for left and right, we say it's side
        // is "unknown", so must be determined from context.
        side: isLeft && !isRight ? "left" : isRight && !isLeft ? "right" : "unknown",
        delimiter
      };
    });
  });
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased.ts
function findSurroundingPairParseTreeBased(editor, selection, node, delimiters, scopeType) {
  const document = editor.document;
  const individualDelimiters = getIndividualDelimiters(delimiters);
  const delimiterTextToDelimiterInfoMap = Object.fromEntries(
    individualDelimiters.map((individualDelimiter) => [
      individualDelimiter.text,
      individualDelimiter
    ])
  );
  const selectionOffsets = {
    start: document.offsetAt(selection.start),
    end: document.offsetAt(selection.end)
  };
  const context = {
    delimiterTextToDelimiterInfoMap,
    individualDelimiters,
    delimiters,
    selectionOffsets,
    scopeType
  };
  for (let currentNode = node; currentNode != null; currentNode = currentNode.parent) {
    if (!getNodeRange(currentNode).contains(selection)) {
      continue;
    }
    const pairOffsets = findSurroundingPairContainedInNode(
      context,
      currentNode
    );
    if (pairOffsets != null) {
      return extractSelectionFromSurroundingPairOffsets(
        document,
        0,
        pairOffsets
      );
    }
  }
  return null;
}
function findSurroundingPairContainedInNode(context, node) {
  const {
    delimiterTextToDelimiterInfoMap,
    individualDelimiters,
    delimiters,
    selectionOffsets,
    scopeType
  } = context;
  const possibleDelimiterNodes = node.descendantsOfType(individualDelimiters.map(({ text }) => text)).filter((node2) => !(node2.text === "" && node2.hasError()));
  const delimiterOccurrences = possibleDelimiterNodes.map((delimiterNode) => {
    return {
      offsets: {
        start: delimiterNode.startIndex,
        end: delimiterNode.endIndex
      },
      get delimiterInfo() {
        const delimiterInfo = delimiterTextToDelimiterInfoMap[delimiterNode.type];
        if (delimiterInfo.delimiter === "angleBrackets" && inferDelimiterSide(delimiterNode) !== delimiterInfo.side && !isContainedInErrorNode(delimiterNode)) {
          return void 0;
        }
        const side = delimiterInfo.side === "unknown" && scopeType.forceDirection == null ? inferDelimiterSide(delimiterNode) : delimiterInfo.side;
        return {
          ...delimiterInfo,
          side
        };
      }
    };
  });
  return findSurroundingPairCore(
    scopeType,
    delimiterOccurrences,
    delimiters,
    selectionOffsets,
    // If we're not the root node of the parse tree (ie `node.parent !=
    // null`), we tell `findSurroundingPairCore` to bail if it finds a
    // delimiter adjacent to our selection, but doesn't find its opposite
    // delimiter within our list. We do so because it's possible that the
    // adjacent delimiter's opposite might be found when we run again on a
    // parent node later.
    node.parent != null
  );
}
function inferDelimiterSide(delimiterNode) {
  return delimiterNode.parent?.firstChild?.equals(delimiterNode) ? "left" : delimiterNode.parent?.lastChild?.equals(delimiterNode) ? "right" : "unknown";
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/findSurroundingPairTextBased.ts
var import_lodash33 = __toESM(require_lodash(), 1);
var INITIAL_SCAN_LENGTH = 200;
var MAX_SCAN_LENGTH = 5e4;
var SCAN_EXPANSION_FACTOR = 3;
function findSurroundingPairTextBased(editor, range4, allowableRange, delimiters, scopeType) {
  const document = editor.document;
  const fullRange = allowableRange ?? document.range;
  const individualDelimiters = getIndividualDelimiters(delimiters);
  const delimiterTextToDelimiterInfoMap = Object.fromEntries(
    individualDelimiters.map((individualDelimiter) => [
      individualDelimiter.text,
      individualDelimiter
    ])
  );
  const delimiterRegex = getDelimiterRegex(individualDelimiters);
  const fullRangeOffsets = {
    start: document.offsetAt(fullRange.start),
    end: document.offsetAt(fullRange.end)
  };
  const selectionOffsets = {
    start: document.offsetAt(range4.start),
    end: document.offsetAt(range4.end)
  };
  const context = {
    scopeType,
    delimiterRegex,
    delimiters,
    delimiterTextToDelimiterInfoMap
  };
  for (let scanLength = INITIAL_SCAN_LENGTH; scanLength < MAX_SCAN_LENGTH; scanLength *= SCAN_EXPANSION_FACTOR) {
    const currentRangeOffsets = {
      start: Math.max(
        fullRangeOffsets.start,
        selectionOffsets.end - scanLength / 2
      ),
      end: Math.min(
        fullRangeOffsets.end,
        selectionOffsets.end + scanLength / 2
      )
    };
    const currentRange = new Range(
      document.positionAt(currentRangeOffsets.start),
      document.positionAt(currentRangeOffsets.end)
    );
    if (!currentRange.contains(range4)) {
      continue;
    }
    const adjustedSelectionOffsets = {
      start: selectionOffsets.start - currentRangeOffsets.start,
      end: selectionOffsets.end - currentRangeOffsets.start
    };
    const pairOffsets = getDelimiterPairOffsets(
      context,
      document.getText(currentRange),
      adjustedSelectionOffsets,
      currentRangeOffsets.start === fullRangeOffsets.start,
      currentRangeOffsets.end === fullRangeOffsets.end
    );
    if (pairOffsets != null) {
      return extractSelectionFromSurroundingPairOffsets(
        document,
        currentRangeOffsets.start,
        pairOffsets
      );
    }
    if (currentRange.contains(fullRange)) {
      break;
    }
  }
  return null;
}
function getDelimiterRegex(individualDelimiters) {
  const individualDelimiterDisjunct = (0, import_lodash33.uniq)(
    individualDelimiters.map(({ text }) => text)
  ).map(import_lodash33.escapeRegExp).join("|");
  return new RegExp(`(?<!\\\\)(${individualDelimiterDisjunct})`, "gu");
}
function getDelimiterPairOffsets(context, text, selectionOffsets, isAtStartOfFullRange, isAtEndOfFullRange) {
  const {
    scopeType,
    delimiterTextToDelimiterInfoMap,
    delimiterRegex,
    delimiters
  } = context;
  const { forceDirection } = scopeType;
  const delimiterOccurrences = matchAll(
    text,
    delimiterRegex,
    (match2, index) => {
      const startOffset = match2.index;
      const matchText2 = match2[0];
      let hasCachedDelimiterInfo = false;
      let cachedDelimiterInfo = void 0;
      return {
        offsets: {
          start: startOffset,
          end: startOffset + matchText2.length
        },
        get delimiterInfo() {
          if (hasCachedDelimiterInfo) {
            return cachedDelimiterInfo;
          }
          const rawDelimiterInfo = delimiterTextToDelimiterInfoMap[matchText2];
          const side = rawDelimiterInfo.side === "unknown" && forceDirection == null ? inferDelimiterSide2(
            text,
            delimiterOccurrences,
            index,
            rawDelimiterInfo?.delimiter,
            startOffset
          ) : rawDelimiterInfo.side;
          const delimiterInfo = { ...rawDelimiterInfo, side };
          hasCachedDelimiterInfo = true;
          cachedDelimiterInfo = delimiterInfo;
          return delimiterInfo;
        }
      };
    }
  );
  const surroundingPair = findSurroundingPairCore(
    scopeType,
    delimiterOccurrences,
    delimiters,
    selectionOffsets,
    !isAtStartOfFullRange || !isAtEndOfFullRange
  );
  if (surroundingPair == null || !isAtStartOfFullRange && surroundingPair.leftDelimiter.start === 0 || !isAtEndOfFullRange && surroundingPair.rightDelimiter.end === text.length - 1) {
    return null;
  }
  return surroundingPair;
}
function inferDelimiterSide2(fullText, delimiterOccurrences, index, delimiter, occurrenceStartOffset) {
  const previousOccurrence = index === 0 ? null : (0, import_lodash33.findLast)(
    delimiterOccurrences,
    (delimiterOccurrence) => delimiterOccurrence.delimiterInfo?.delimiter === delimiter,
    index - 1
  );
  if (previousOccurrence == null || fullText.substring(previousOccurrence.offsets.end, occurrenceStartOffset).includes("\n")) {
    return "left";
  }
  return previousOccurrence.delimiterInfo.side === "left" ? "right" : "left";
}

// ../cursorless-engine/src/processTargets/modifiers/surroundingPair/index.ts
function processSurroundingPair(languageDefinitions, target, scopeType) {
  const pairInfo = processSurroundingPairCore(
    languageDefinitions,
    target,
    scopeType
  );
  if (pairInfo == null) {
    return null;
  }
  return new SurroundingPairTarget({
    ...pairInfo,
    editor: target.editor,
    isReversed: target.isReversed
  });
}
function processSurroundingPairCore(languageDefinitions, target, scopeType) {
  const { editor, contentRange: range4 } = target;
  const languageDefinition = languageDefinitions.get(
    target.editor.document.languageId
  );
  const document = editor.document;
  const delimiters = complexDelimiterMap[scopeType.delimiter] ?? [scopeType.delimiter];
  let node;
  try {
    node = languageDefinitions.getNodeAtLocation(document, range4);
    if (nodeHasError(node)) {
      return findSurroundingPairTextBased(
        editor,
        range4,
        null,
        delimiters,
        scopeType
      );
    }
  } catch (err) {
    if (err.name === "UnsupportedLanguageError") {
      return findSurroundingPairTextBased(
        editor,
        range4,
        null,
        delimiters,
        scopeType
      );
    } else {
      throw err;
    }
  }
  const textFragmentRange = (() => {
    const textFragmentScopeHandler = languageDefinition?.getTextFragmentScopeHandler();
    if (textFragmentScopeHandler != null) {
      const containingScope = getContainingScopeTarget(
        target,
        textFragmentScopeHandler,
        0
      );
      return containingScope?.[0].contentRange;
    }
    const textFragmentExtractor = getTextFragmentExtractor(document.languageId);
    if (textFragmentExtractor == null) {
      return document.range;
    }
    const selectionWithEditor = {
      editor,
      selection: new Selection(range4.start, range4.end)
    };
    return textFragmentExtractor(node, selectionWithEditor);
  })();
  if (textFragmentRange != null) {
    const surroundingRange = findSurroundingPairTextBased(
      editor,
      range4,
      textFragmentRange,
      delimiters,
      scopeType
    );
    if (surroundingRange != null) {
      return surroundingRange;
    }
  }
  return findSurroundingPairParseTreeBased(
    editor,
    range4,
    node,
    delimiters,
    scopeType
  );
}
function nodeHasError(node, includeChildren = false) {
  if (nodeIsError(node)) {
    return true;
  }
  if (includeChildren) {
    if (node.children.some(nodeIsError)) {
      return true;
    }
  }
  if (node.parent != null) {
    return nodeHasError(node.parent, true);
  }
  return false;
}
function nodeIsError(node) {
  return node.type === "ERROR";
}

// ../cursorless-engine/src/processTargets/modifiers/ItemStage/getIterationScope.ts
function getIterationScope(languageDefinitions, target) {
  let surroundingTarget = getSurroundingPair(languageDefinitions, target);
  while (surroundingTarget != null) {
    if (useInteriorOfSurroundingTarget(
      languageDefinitions,
      target,
      surroundingTarget
    )) {
      return {
        range: surroundingTarget.getInteriorStrict()[0].contentRange,
        boundary: getBoundary(surroundingTarget)
      };
    }
    surroundingTarget = getParentSurroundingPair(
      languageDefinitions,
      target.editor,
      surroundingTarget
    );
  }
  return {
    range: fitRangeToLineContent(target.editor, target.contentRange)
  };
}
function useInteriorOfSurroundingTarget(languageDefinitions, target, surroundingTarget) {
  const { contentRange } = target;
  if (contentRange.isEmpty) {
    const [left, right] = getBoundary(surroundingTarget);
    const pos = contentRange.start;
    if (pos.isEqual(left.start) || pos.isEqual(right.end)) {
      return false;
    }
    const line = target.editor.document.lineAt(pos);
    if (pos.isEqual(left.end) && characterIsWhitespaceOrMissing(line, pos.character)) {
      return false;
    }
    if (pos.isEqual(right.start) && characterIsWhitespaceOrMissing(line, pos.character - 1)) {
      return false;
    }
  } else {
    if (contentRange.isRangeEqual(surroundingTarget.contentRange)) {
      return false;
    }
    const [left, right] = getBoundary(surroundingTarget);
    if (contentRange.isRangeEqual(left) || contentRange.isRangeEqual(right)) {
      return false;
    }
  }
  const surroundingStringTarget = getStringSurroundingPair(
    languageDefinitions,
    surroundingTarget
  );
  if (surroundingStringTarget != null && surroundingTarget.contentRange.start.isBeforeOrEqual(
    surroundingStringTarget.contentRange.start
  )) {
    return false;
  }
  return true;
}
function getBoundary(surroundingTarget) {
  return surroundingTarget.getBoundaryStrict().map((t) => t.contentRange);
}
function characterIsWhitespaceOrMissing(line, index) {
  return index < line.range.start.character || index >= line.range.end.character || line.text[index].trim() === "";
}
function getParentSurroundingPair(languageDefinitions, editor, target) {
  const startOffset = editor.document.offsetAt(target.contentRange.start);
  if (startOffset === 0) {
    return null;
  }
  const position = editor.document.positionAt(startOffset - 1);
  return getSurroundingPair(
    languageDefinitions,
    new PlainTarget({
      editor,
      contentRange: new Range(position, position),
      isReversed: false
    })
  );
}
function getSurroundingPair(languageDefinitions, target) {
  return processSurroundingPair(languageDefinitions, target, {
    type: "surroundingPair",
    delimiter: "collectionBoundary",
    requireStrongContainment: true
  });
}
function getStringSurroundingPair(languageDefinitions, target) {
  return processSurroundingPair(languageDefinitions, target, {
    type: "surroundingPair",
    delimiter: "string",
    requireStrongContainment: true
  });
}

// ../cursorless-engine/src/processTargets/modifiers/ItemStage/tokenizeRange.ts
function tokenizeRange(editor, interior, boundary) {
  const { document } = editor;
  const text = document.getText(interior);
  const lexemes = text.split(/([,(){}<>[\]"'`])|(?<!\\)(\\"|\\'|\\`)/g).filter((lexeme) => lexeme != null && lexeme.length > 0);
  const joinedLexemes = joinLexemesBySkippingMatchingPairs(lexemes);
  const tokens = [];
  let offset = document.offsetAt(interior.start);
  joinedLexemes.forEach((lexeme) => {
    if (lexeme.trim().length === 0) {
      offset += lexeme.length;
      return;
    }
    if (lexeme === separator) {
      tokens.push({
        type: "separator",
        range: new Range(
          document.positionAt(offset),
          document.positionAt(offset + lexeme.length)
        )
      });
    } else {
      const offsetStart = offset + (lexeme.length - lexeme.trimStart().length);
      tokens.push({
        type: "item",
        range: new Range(
          document.positionAt(offsetStart),
          document.positionAt(offsetStart + lexeme.trim().length)
        )
      });
    }
    offset += lexeme.length;
  });
  if (boundary != null) {
    return [
      { type: "boundary", range: boundary[0] },
      ...tokens,
      { type: "boundary", range: boundary[1] }
    ];
  }
  return tokens;
}
function joinLexemesBySkippingMatchingPairs(lexemes) {
  const result = [];
  let delimiterBalance = 0;
  let openingDelimiter = null;
  let closingDelimiter = null;
  let startIndex = -1;
  lexemes.forEach((lexeme, index) => {
    if (delimiterBalance > 0) {
      if (lexeme === closingDelimiter) {
        --delimiterBalance;
      } else if (lexeme === openingDelimiter) {
        ++delimiterBalance;
      }
    } else if (leftToRightMap2[lexeme] != null && lexemes.indexOf(leftToRightMap2[lexeme], index + 1) > -1) {
      openingDelimiter = lexeme;
      closingDelimiter = leftToRightMap2[lexeme];
      delimiterBalance = 1;
      if (startIndex < 0) {
        startIndex = index;
      }
    } else if (startIndex < 0) {
      startIndex = index;
    }
    const isSeparator = lexeme === separator && delimiterBalance === 0;
    if (isSeparator || index === lexemes.length - 1) {
      const endIndex = isSeparator ? index : index + 1;
      result.push(lexemes.slice(startIndex, endIndex).join(""));
      startIndex = -1;
      if (isSeparator) {
        result.push(lexeme);
      }
    }
  });
  return result;
}
var separator = ",";
var leftToRightMap2 = {
  "(": ")",
  "{": "}",
  "<": ">",
  "[": "]",
  '"': '"',
  "'": "'",
  "`": "`"
};

// ../cursorless-engine/src/processTargets/modifiers/ItemStage/ItemStage.ts
var ItemStage = class {
  constructor(languageDefinitions, modifier) {
    this.languageDefinitions = languageDefinitions;
    this.modifier = modifier;
  }
  run(target) {
    try {
      return new LegacyContainingSyntaxScopeStage(
        this.languageDefinitions,
        this.modifier
      ).run(target);
    } catch (_error) {
    }
    if (this.modifier.type === "everyScope") {
      return this.getEveryTarget(this.languageDefinitions, target);
    }
    return [this.getSingleTarget(this.languageDefinitions, target)];
  }
  getEveryTarget(languageDefinitions, target) {
    const itemInfos = getItemInfosForIterationScope(
      languageDefinitions,
      target
    );
    const filteredItemInfos = target.hasExplicitRange ? filterItemInfos(target, itemInfos) : itemInfos;
    if (filteredItemInfos.length === 0) {
      throw new NoContainingScopeError(this.modifier.scopeType.type);
    }
    return filteredItemInfos.map(
      (itemInfo) => this.itemInfoToTarget(target, itemInfo)
    );
  }
  getSingleTarget(languageDefinitions, target) {
    const itemInfos = getItemInfosForIterationScope(
      languageDefinitions,
      target
    );
    const filteredItemInfos = filterItemInfos(target, itemInfos);
    if (filteredItemInfos.length === 0) {
      throw new NoContainingScopeError(this.modifier.scopeType.type);
    }
    const first = filteredItemInfos[0];
    const last2 = filteredItemInfos[filteredItemInfos.length - 1];
    const itemInfo = {
      contentRange: first.contentRange.union(last2.contentRange),
      domain: first.domain.union(last2.domain),
      leadingDelimiterRange: first.leadingDelimiterRange,
      trailingDelimiterRange: last2.trailingDelimiterRange
    };
    const removalRange = itemInfo.leadingDelimiterRange != null && itemInfo.trailingDelimiterRange != null && getRangeLength(target.editor, itemInfo.leadingDelimiterRange) > getRangeLength(target.editor, itemInfo.trailingDelimiterRange) ? itemInfo.contentRange.union(itemInfo.leadingDelimiterRange) : void 0;
    return this.itemInfoToTarget(target, itemInfo, removalRange);
  }
  itemInfoToTarget(target, itemInfo, removalRange) {
    const insertionDelimiter = getInsertionDelimiter3(
      itemInfo.leadingDelimiterRange,
      itemInfo.trailingDelimiterRange
    );
    return new ScopeTypeTarget({
      scopeTypeType: this.modifier.scopeType.type,
      editor: target.editor,
      isReversed: target.isReversed,
      contentRange: itemInfo.contentRange,
      insertionDelimiter,
      leadingDelimiterRange: itemInfo.leadingDelimiterRange,
      trailingDelimiterRange: itemInfo.trailingDelimiterRange,
      removalRange
    });
  }
};
function getInsertionDelimiter3(leadingDelimiterRange, trailingDelimiterRange) {
  return leadingDelimiterRange != null && !leadingDelimiterRange.isSingleLine || trailingDelimiterRange != null && !trailingDelimiterRange.isSingleLine ? ",\n" : ", ";
}
function filterItemInfos(target, itemInfos) {
  return itemInfos.filter(
    (itemInfo) => itemInfo.domain.intersection(target.contentRange) != null
  );
}
function getItemInfosForIterationScope(languageDefinitions, target) {
  const { range: range4, boundary } = getIterationScope(languageDefinitions, target);
  return getItemsInRange(target.editor, range4, boundary);
}
function getItemsInRange(editor, interior, boundary) {
  const tokens = tokenizeRange(editor, interior, boundary);
  const itemInfos = [];
  tokens.forEach((token, i) => {
    if (token.type === "separator" || token.type === "boundary") {
      return;
    }
    const leadingDelimiterRange = (() => {
      if (tokens[i - 2]?.type === "item") {
        return new Range(tokens[i - 2].range.end, token.range.start);
      }
      if (tokens[i - 1]?.type === "separator") {
        return new Range(tokens[i - 1].range.start, token.range.start);
      }
      return void 0;
    })();
    const trailingDelimiterRange = (() => {
      if (tokens[i + 2]?.type === "item") {
        return new Range(token.range.end, tokens[i + 2].range.start);
      }
      if (tokens[i + 1]?.type === "separator") {
        return new Range(token.range.end, tokens[i + 1].range.end);
      }
      return void 0;
    })();
    const domainStart = tokens[i - 1]?.type === "boundary" || tokens[i - 1]?.type === "separator" ? tokens[i - 1].range.end : token.range.start;
    const domainEnd = tokens[i + 1]?.type === "boundary" || tokens[i + 1]?.type === "separator" ? tokens[i + 1].range.start : token.range.end;
    itemInfos.push({
      contentRange: token.range,
      leadingDelimiterRange,
      trailingDelimiterRange,
      domain: new Range(domainStart, domainEnd)
    });
  });
  return itemInfos;
}

// ../cursorless-engine/src/processTargets/modifiers/LeadingTrailingStages.ts
var NoDelimiterError = class extends Error {
  constructor(type2) {
    super(`Target has no ${type2} delimiter.`);
    this.name = "NoDelimiterError";
  }
};
var LeadingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    return this.modifierStageFactory.create(containingTokenIfUntypedModifier).run(target).map((target2) => {
      const leading = target2.getLeadingDelimiterTarget();
      if (leading == null) {
        throw new NoDelimiterError("leading");
      }
      return leading;
    });
  }
};
var TrailingStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    return this.modifierStageFactory.create(containingTokenIfUntypedModifier).run(target).map((target2) => {
      const trailing = target2.getTrailingDelimiterTarget();
      if (trailing == null) {
        throw new NoDelimiterError("trailing");
      }
      return trailing;
    });
  }
};

// ../cursorless-engine/src/processTargets/modifiers/targetSequenceUtils.ts
function createRangeTargetFromIndices(isReversed, targets, startIndex, endIndex) {
  assertIndices(targets, startIndex, endIndex);
  if (startIndex === endIndex) {
    return targets[startIndex];
  }
  return createContinuousRangeTarget(
    isReversed,
    targets[startIndex],
    targets[endIndex],
    true,
    true
  );
}
function getEveryScopeTargets(modifierStageFactory, target, scopeType) {
  const containingStage = modifierStageFactory.create({
    type: "everyScope",
    scopeType
  });
  return containingStage.run(target);
}

// ../cursorless-engine/src/processTargets/modifiers/OrdinalScopeStage.ts
var OrdinalScopeStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    const targets = getEveryScopeTargets(
      this.modifierStageFactory,
      target,
      this.modifier.scopeType
    );
    const startIndex = this.modifier.start + (this.modifier.start < 0 ? targets.length : 0);
    const endIndex = startIndex + this.modifier.length - 1;
    if (this.modifier.isEvery) {
      return sliceStrict(targets, startIndex, endIndex);
    }
    return [
      createRangeTargetFromIndices(
        target.isReversed,
        targets,
        startIndex,
        endIndex
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/PositionStage.ts
var PositionStage = class {
  run(target) {
    const parameters = {
      editor: target.editor,
      isReversed: target.isReversed,
      contentRange: this.getContentRange(target.contentRange)
    };
    return [
      target.isRaw ? new RawSelectionTarget(parameters) : new PlainTarget({ ...parameters, isToken: false })
    ];
  }
};
var StartOfStage = class extends PositionStage {
  getContentRange(contentRange) {
    return contentRange.start.toEmptyRange();
  }
};
var EndOfStage = class extends PositionStage {
  getContentRange(contentRange) {
    return contentRange.end.toEmptyRange();
  }
};

// ../cursorless-engine/src/processTargets/modifiers/RangeModifierStage.ts
var RangeModifierStage = class {
  constructor(modifierStageFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    const anchorStage = this.modifierStageFactory.create(this.modifier.anchor);
    const activeStage = this.modifierStageFactory.create(this.modifier.active);
    const anchorTargets = anchorStage.run(target);
    const activeTargets = activeStage.run(target);
    if (anchorTargets.length !== 1 || activeTargets.length !== 1) {
      throw new Error("Expected single anchor and active target");
    }
    return [
      targetsToContinuousTarget(
        anchorTargets[0],
        activeTargets[0],
        this.modifier.excludeAnchor,
        this.modifier.excludeActive
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/RawSelectionStage.ts
var RawSelectionStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return [
      new RawSelectionTarget({
        editor: target.editor,
        contentRange: target.contentRange,
        isReversed: target.isReversed
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/modifiers/relativeScopeLegacy.ts
var import_lodash34 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/processTargets/modifiers/TooFewScopesError.ts
var TooFewScopesError = class extends Error {
  constructor(requestedLength, currentLength, scopeType) {
    super(
      `Requested ${requestedLength} ${scopeType}s, but ${currentLength} are already selected.`
    );
    this.name = "TooFewScopesError";
  }
};

// ../cursorless-engine/src/processTargets/modifiers/relativeScopeLegacy.ts
function runLegacy(modifierStageFactory, modifier, target) {
  const targets = getEveryScopeTargets(
    modifierStageFactory,
    createTargetWithoutExplicitRange(target),
    modifier.scopeType
  );
  const containingIndices = getContainingIndices(target.contentRange, targets);
  return calculateIndicesAndCreateTarget(
    modifier,
    target,
    targets,
    containingIndices
  );
}
function calculateIndicesAndCreateTarget(modifier, target, targets, containingIndices) {
  const isForward = modifier.direction === "forward";
  const proximalIndex = computeProximalIndex(
    modifier,
    target.contentRange,
    targets,
    isForward,
    containingIndices
  );
  const distalIndex = isForward ? proximalIndex + modifier.length - 1 : proximalIndex - modifier.length + 1;
  const startIndex = Math.min(proximalIndex, distalIndex);
  const endIndex = Math.max(proximalIndex, distalIndex);
  return [
    createRangeTargetFromIndices(
      target.isReversed,
      targets,
      startIndex,
      endIndex
    )
  ];
}
function computeProximalIndex(modifier, inputTargetRange, targets, isForward, containingIndices) {
  const includeIntersectingScopes = modifier.offset === 0;
  if (containingIndices == null) {
    const adjacentTargetIndex = isForward ? targets.findIndex(
      (t) => t.contentRange.start.isAfter(inputTargetRange.start)
    ) : (0, import_lodash34.findLastIndex)(
      targets,
      (t) => t.contentRange.start.isBefore(inputTargetRange.start)
    );
    if (adjacentTargetIndex === -1) {
      throw new OutOfRangeError();
    }
    if (includeIntersectingScopes) {
      return adjacentTargetIndex;
    }
    return isForward ? adjacentTargetIndex + modifier.offset - 1 : adjacentTargetIndex - modifier.offset + 1;
  }
  const intersectingStartIndex = containingIndices.start;
  const intersectingEndIndex = containingIndices.end;
  if (includeIntersectingScopes) {
    const intersectingLength = intersectingEndIndex - intersectingStartIndex + 1;
    if (intersectingLength > modifier.length) {
      throw new TooFewScopesError(
        modifier.length,
        intersectingLength,
        modifier.scopeType.type
      );
    }
    return isForward ? intersectingStartIndex : intersectingEndIndex;
  }
  return isForward ? intersectingEndIndex + modifier.offset : intersectingStartIndex - modifier.offset;
}
function getContainingIndices(inputTargetRange, targets) {
  const targetsWithIntersection = targets.map((t, i) => ({
    index: i,
    intersection: t.contentRange.intersection(inputTargetRange)
  })).filter((t) => t.intersection != null);
  if (inputTargetRange.isEmpty) {
    if (targetsWithIntersection.length === 0) {
      return void 0;
    }
    const index = targetsWithIntersection.at(-1).index;
    return { start: index, end: index };
  }
  const targetsWithNonEmptyIntersection = targetsWithIntersection.filter((t) => !t.intersection.isEmpty).map((t) => t.index);
  if (targetsWithNonEmptyIntersection.length === 0) {
    return void 0;
  }
  return {
    start: targetsWithNonEmptyIntersection[0],
    end: targetsWithNonEmptyIntersection.at(-1)
  };
}
function createTargetWithoutExplicitRange(target) {
  return new UntypedTarget({
    editor: target.editor,
    isReversed: target.isReversed,
    contentRange: target.contentRange,
    hasExplicitRange: false
  });
}

// ../cursorless-engine/src/processTargets/modifiers/RelativeScopeStage.ts
var RelativeScopeStage = class {
  constructor(modifierStageFactory, scopeHandlerFactory, modifier) {
    this.modifierStageFactory = modifierStageFactory;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifier = modifier;
  }
  run(target) {
    const scopeHandler = this.scopeHandlerFactory.create(
      this.modifier.scopeType,
      target.editor.document.languageId
    );
    if (scopeHandler == null) {
      return runLegacy(this.modifierStageFactory, this.modifier, target);
    }
    const scopes = Array.from(
      this.modifier.offset === 0 ? generateScopesInclusive(scopeHandler, target, this.modifier) : generateScopesExclusive(scopeHandler, target, this.modifier)
    );
    if (scopes.length < this.modifier.length) {
      throw new OutOfRangeError();
    }
    const { isReversed } = target;
    if (this.modifier.isEvery) {
      return scopes.flatMap((scope) => scope.getTargets(isReversed));
    }
    return constructScopeRangeTarget(
      isReversed,
      scopes[0],
      scopes[scopes.length - 1]
    );
  }
};
function generateScopesInclusive(scopeHandler, target, modifier) {
  const { editor, contentRange } = target;
  const { length: desiredScopeCount, direction } = modifier;
  const initialRange = getPreferredScopeTouchingPosition(
    scopeHandler,
    editor,
    direction === "forward" ? contentRange.start : contentRange.end,
    direction
  )?.domain;
  if (initialRange == null) {
    throw new NoContainingScopeError(modifier.scopeType.type);
  }
  return itake(
    desiredScopeCount,
    scopeHandler.generateScopes(
      editor,
      direction === "forward" ? initialRange.start : initialRange.end,
      direction,
      {
        skipAncestorScopes: true
      }
    )
  );
}
function generateScopesExclusive(scopeHandler, target, modifier) {
  const { editor, contentRange: inputRange } = target;
  const { length: desiredScopeCount, direction, offset } = modifier;
  const initialPosition = direction === "forward" ? inputRange.end : inputRange.start;
  const containment = inputRange.isEmpty ? "disallowed" : "disallowedIfStrict";
  return islice(
    scopeHandler.generateScopes(editor, initialPosition, direction, {
      containment,
      skipAncestorScopes: true
    }),
    offset - 1,
    offset + desiredScopeCount - 1
  );
}

// ../cursorless-engine/src/processTargets/modifiers/SurroundingPairStage.ts
var SurroundingPairStage = class {
  constructor(languageDefinitions, modifier) {
    this.languageDefinitions = languageDefinitions;
    this.modifier = modifier;
  }
  run(target) {
    if (this.modifier.type === "everyScope") {
      throw Error(`Unsupported every scope ${this.modifier.scopeType.type}`);
    }
    return processedSurroundingPairTarget(
      this.languageDefinitions,
      this.modifier,
      target
    );
  }
};
function processedSurroundingPairTarget(languageDefinitions, modifier, target) {
  const outputTarget = processSurroundingPair(
    languageDefinitions,
    target,
    modifier.scopeType
  );
  if (outputTarget == null) {
    throw new Error("Couldn't find containing pair");
  }
  return [outputTarget];
}

// ../cursorless-engine/src/processTargets/modifiers/VisibleStage.ts
var VisibleStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    return target.editor.visibleRanges.map(
      (range4) => new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: range4
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeTypeStages/BoundedNonWhitespaceStage.ts
var BoundedNonWhitespaceSequenceStage = class {
  constructor(languageDefinitions, modifierStageFactory, modifier) {
    this.languageDefinitions = languageDefinitions;
    this.modifierStageFactory = modifierStageFactory;
    this.modifier = modifier;
  }
  run(target) {
    const paintStage = this.modifierStageFactory.create({
      type: this.modifier.type,
      scopeType: { type: "nonWhitespaceSequence" }
    });
    const paintTargets = paintStage.run(target);
    const pairInfo = processSurroundingPair(this.languageDefinitions, target, {
      type: "surroundingPair",
      delimiter: "any",
      requireStrongContainment: true
    });
    if (pairInfo == null) {
      return paintTargets;
    }
    const targets = paintTargets.flatMap((paintTarget) => {
      const contentRange = paintTarget.contentRange.intersection(
        pairInfo.getInteriorStrict()[0].contentRange
      );
      if (contentRange == null || contentRange.isEmpty) {
        return [];
      }
      return [
        new TokenTarget({
          editor: target.editor,
          isReversed: target.isReversed,
          contentRange
        })
      ];
    });
    if (targets.length === 0) {
      throw new NoContainingScopeError(this.modifier.scopeType.type);
    }
    return targets;
  }
};

// ../cursorless-engine/src/processTargets/modifiers/scopeTypeStages/NotebookCellStage.ts
var NotebookCellStage = class {
  constructor(modifier) {
    this.modifier = modifier;
  }
  run(target) {
    if (this.modifier.type === "everyScope") {
      throw new Error(`Every ${this.modifier.type} not yet implemented`);
    }
    return [
      new NotebookCellTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: target.contentRange
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/ModifierStageFactoryImpl.ts
var ModifierStageFactoryImpl = class {
  constructor(languageDefinitions, storedTargets, scopeHandlerFactory) {
    this.languageDefinitions = languageDefinitions;
    this.storedTargets = storedTargets;
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.create = this.create.bind(this);
  }
  create(modifier) {
    switch (modifier.type) {
      case "startOf":
        return new StartOfStage();
      case "endOf":
        return new EndOfStage();
      case "extendThroughStartOf":
        return new HeadStage(this, modifier);
      case "extendThroughEndOf":
        return new TailStage(this, modifier);
      case "toRawSelection":
        return new RawSelectionStage(modifier);
      case "interiorOnly":
        return new InteriorOnlyStage(this, modifier);
      case "excludeInterior":
        return new ExcludeInteriorStage(this, modifier);
      case "leading":
        return new LeadingStage(this, modifier);
      case "trailing":
        return new TrailingStage(this, modifier);
      case "visible":
        return new VisibleStage(modifier);
      case "containingScope":
        return new ContainingScopeStage(
          this,
          this.scopeHandlerFactory,
          modifier
        );
      case "everyScope":
        if (modifier.scopeType.type === "instance") {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        return new EveryScopeStage(this, this.scopeHandlerFactory, modifier);
      case "ordinalScope":
        if (modifier.scopeType.type === "instance") {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        return new OrdinalScopeStage(this, modifier);
      case "relativeScope":
        if (modifier.scopeType.type === "instance") {
          return new InstanceStage(this, this.storedTargets, modifier);
        }
        return new RelativeScopeStage(this, this.scopeHandlerFactory, modifier);
      case "keepContentFilter":
        return new KeepContentFilterStage(modifier);
      case "keepEmptyFilter":
        return new KeepEmptyFilterStage(modifier);
      case "cascading":
        return new CascadingStage(this, modifier);
      case "modifyIfUntyped":
        return new ModifyIfUntypedStage(this, modifier);
      case "range":
        return new RangeModifierStage(this, modifier);
      case "inferPreviousMark":
        throw Error(
          `Unexpected modifier '${modifier.type}'; it should have been removed during inference`
        );
    }
  }
  /**
   * Any scope type that has not been fully migrated to the new
   * {@link ScopeHandler} setup should have a branch in this `switch` statement.
   * Once the scope type is fully migrated, remove the branch and the legacy
   * modifier stage.
   *
   * Note that it is possible for a scope type to be partially migrated.  For
   * example, we could support modern scope handlers for a certain scope type in
   * Ruby, but not yet in Python.
   *
   * @param modifier The modifier for which to get the modifier stage
   * @returns A scope stage implementing the modifier for the given scope type
   */
  getLegacyScopeStage(modifier) {
    switch (modifier.scopeType.type) {
      case "notebookCell":
        return new NotebookCellStage(modifier);
      case "boundedNonWhitespaceSequence":
        return new BoundedNonWhitespaceSequenceStage(
          this.languageDefinitions,
          this,
          modifier
        );
      case "collectionItem":
        return new ItemStage(this.languageDefinitions, modifier);
      case "surroundingPair":
        return new SurroundingPairStage(
          this.languageDefinitions,
          modifier
        );
      default:
        return new LegacyContainingSyntaxScopeStage(
          this.languageDefinitions,
          modifier
        );
    }
  }
};

// ../cursorless-engine/src/actions/BreakLine.ts
var import_lodash37 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/core/updateSelections/updateSelections.ts
var import_lodash35 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/performDocumentEdits.ts
async function performDocumentEdits(rangeUpdater, editor, edits) {
  const deregister = rangeUpdater.registerReplaceEditList(
    editor.document,
    edits.filter((edit) => edit.isReplace)
  );
  const wereEditsApplied = await editor.edit(edits);
  deregister();
  return wereEditsApplied;
}

// ../cursorless-engine/src/core/updateSelections/updateSelections.ts
function getSelectionInfo(document, selection, rangeBehavior) {
  return getSelectionInfoInternal(
    document,
    selection,
    !selection.isReversed,
    rangeBehavior
  );
}
function getSelectionInfoInternal(document, range4, isForward, rangeBehavior) {
  return {
    range: range4,
    isForward,
    expansionBehavior: {
      start: {
        type: rangeBehavior === 1 /* closedClosed */ || rangeBehavior === 3 /* closedOpen */ ? "closed" : "open"
      },
      end: {
        type: rangeBehavior === 1 /* closedClosed */ || rangeBehavior === 2 /* openClosed */ ? "closed" : "open"
      }
    },
    offsets: {
      start: document.offsetAt(range4.start),
      end: document.offsetAt(range4.end)
    },
    text: document.getText(range4)
  };
}
function selectionsToSelectionInfos(document, selectionMatrix, rangeBehavior = 1 /* closedClosed */) {
  return selectionMatrix.map(
    (selections) => selections.map(
      (selection) => getSelectionInfo(document, selection, rangeBehavior)
    )
  );
}
function rangesToSelectionInfos(document, rangeMatrix, rangeBehavior = 1 /* closedClosed */) {
  return rangeMatrix.map(
    (ranges) => ranges.map(
      (range4) => getSelectionInfoInternal(document, range4, false, rangeBehavior)
    )
  );
}
function selectionInfosToSelections(selectionInfoMatrix) {
  return selectionInfoMatrix.map(
    (selectionInfos) => selectionInfos.map(
      ({ range: { start, end }, isForward }) => isForward ? new Selection(start, end) : new Selection(end, start)
    )
  );
}
async function callFunctionAndUpdateSelections(rangeUpdater, func, document, selectionMatrix) {
  const selectionInfoMatrix = selectionsToSelectionInfos(
    document,
    selectionMatrix
  );
  return await callFunctionAndUpdateSelectionInfos(
    rangeUpdater,
    func,
    document,
    selectionInfoMatrix
  );
}
async function callFunctionAndUpdateRanges(rangeUpdater, func, document, rangeMatrix) {
  const selectionInfoMatrix = rangesToSelectionInfos(document, rangeMatrix);
  return await callFunctionAndUpdateSelectionInfos(
    rangeUpdater,
    func,
    document,
    selectionInfoMatrix
  );
}
async function callFunctionAndUpdateSelectionInfos(rangeUpdater, func, document, selectionInfoMatrix) {
  const unsubscribe = rangeUpdater.registerRangeInfoList(
    document,
    (0, import_lodash35.flatten)(selectionInfoMatrix)
  );
  await func();
  unsubscribe();
  return selectionInfosToSelections(selectionInfoMatrix);
}
function callFunctionAndUpdateSelectionsWithBehavior(rangeUpdater, func, document, originalSelections) {
  return callFunctionAndUpdateSelectionInfos(
    rangeUpdater,
    func,
    document,
    originalSelections.map(
      (selectionsWithBehavior) => selectionsWithBehavior.selections.map(
        (selection) => getSelectionInfo(
          document,
          selection,
          selectionsWithBehavior.rangeBehavior ?? 1 /* closedClosed */
        )
      )
    )
  );
}
async function performEditsAndUpdateSelections(rangeUpdater, editor, edits, originalSelections) {
  const document = editor.document;
  const selectionInfoMatrix = selectionsToSelectionInfos(
    document,
    originalSelections
  );
  return performEditsAndUpdateFullSelectionInfos(
    rangeUpdater,
    editor,
    edits,
    selectionInfoMatrix
  );
}
function performEditsAndUpdateSelectionsWithBehavior(rangeUpdater, editor, edits, originalSelections) {
  return performEditsAndUpdateFullSelectionInfos(
    rangeUpdater,
    editor,
    edits,
    originalSelections.map(
      (selectionsWithBehavior) => selectionsWithBehavior.selections.map(
        (selection) => getSelectionInfo(
          editor.document,
          selection,
          selectionsWithBehavior.rangeBehavior ?? 1 /* closedClosed */
        )
      )
    )
  );
}
async function performEditsAndUpdateRanges(rangeUpdater, editor, edits, originalRanges) {
  const document = editor.document;
  const selectionInfoMatrix = rangesToSelectionInfos(document, originalRanges);
  return performEditsAndUpdateFullSelectionInfos(
    rangeUpdater,
    editor,
    edits,
    selectionInfoMatrix
  );
}
async function performEditsAndUpdateFullSelectionInfos(rangeUpdater, editor, edits, originalSelectionInfos) {
  const func = async () => {
    const wereEditsApplied = await performDocumentEdits(
      rangeUpdater,
      editor,
      edits
    );
    if (!wereEditsApplied) {
      throw new Error("Could not apply edits");
    }
  };
  return await callFunctionAndUpdateSelectionInfos(
    rangeUpdater,
    func,
    editor.document,
    originalSelectionInfos
  );
}

// ../cursorless-engine/src/util/targetUtils.ts
var import_lodash36 = __toESM(require_lodash(), 1);
function ensureSingleEditor2(targets) {
  if (targets.length === 0) {
    throw new Error("Require at least one target with this action");
  }
  const editors = targets.map((target) => target.editor);
  if (new Set(editors).size > 1) {
    throw new Error("Can only have one editor with this action");
  }
  return editors[0];
}
function ensureSingleTarget(targets) {
  if (targets.length !== 1) {
    throw new Error("Can only have one target with this action");
  }
  return targets[0];
}
async function runForEachEditor(targets, getEditor, func) {
  return Promise.all(
    groupForEachEditor(targets, getEditor).map(
      ([editor, editorTargets]) => func(editor, editorTargets)
    )
  );
}
async function runOnTargetsForEachEditor(targets, func) {
  return runForEachEditor(targets, (target) => target.editor, func);
}
async function runOnTargetsForEachEditorSequentially(targets, func) {
  const editorGroups = groupForEachEditor(targets, (target) => target.editor);
  const result = [];
  for (const [editor, targets2] of editorGroups) {
    result.push(await func(editor, targets2));
  }
  return result;
}
function groupTargetsForEachEditor(targets) {
  return groupForEachEditor(targets, (target) => target.editor);
}
function groupForEachEditor(targets, getEditor) {
  const getDocumentUri = (target) => getEditor(target).document.uri;
  const editorMap = groupBy(targets, getDocumentUri);
  return Array.from(editorMap.values(), (editorTargets) => {
    const editor = getEditor(editorTargets[0]);
    return [editor, editorTargets];
  });
}
function getContentRange2(target) {
  return target.contentRange;
}
function createThatMark(targets, ranges) {
  const thatMark = ranges != null ? (0, import_lodash36.zip)(targets, ranges).map(([target, range4]) => ({
    editor: target.editor,
    selection: target?.isReversed ? new Selection(range4.end, range4.start) : new Selection(range4.start, range4.end)
  })) : targets.map((target) => ({
    editor: target.editor,
    selection: target.contentSelection
  }));
  return thatMark;
}
function toGeneralizedRange(target) {
  const range4 = target.contentRange;
  return target.isLine ? toLineRange(range4) : toCharacterRange(range4);
}
function flashTargets(ide2, targets, style, getRange = getContentRange2) {
  return ide2.flashRanges(
    targets.map((target) => {
      const range4 = getRange(target);
      if (range4 == null) {
        return null;
      }
      return {
        editor: target.editor,
        range: target.isLine ? toLineRange(range4) : toCharacterRange(range4),
        style
      };
    }).filter((flash) => flash != null)
  );
}

// ../cursorless-engine/src/actions/BreakLine.ts
var BreakLine = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const thatSelections = (0, import_lodash37.flatten)(
      await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
        const contentRanges = targets2.map(({ contentRange }) => contentRange);
        const edits = getEdits(editor, contentRanges);
        const [updatedRanges] = await performEditsAndUpdateRanges(
          this.rangeUpdater,
          ide().getEditableTextEditor(editor),
          edits,
          [contentRanges]
        );
        return (0, import_lodash37.zip)(targets2, updatedRanges).map(([target, range4]) => ({
          editor: target.editor,
          selection: range4.toSelection(target.isReversed)
        }));
      })
    );
    return { thatSelections };
  }
};
function getEdits(editor, contentRanges) {
  const { document } = editor;
  const edits = [];
  for (const range4 of contentRanges) {
    const position = range4.start;
    const line = document.lineAt(position);
    const indentation = line.text.slice(
      0,
      line.firstNonWhitespaceCharacterIndex
    );
    const characterTrailingWhitespace = line.text.slice(0, position.character).search(/\s+$/);
    const replacementRange = characterTrailingWhitespace > -1 ? new Range(
      new Position(line.lineNumber, characterTrailingWhitespace),
      position
    ) : position.toEmptyRange();
    edits.push({
      range: replacementRange,
      text: "\n" + indentation,
      isReplace: !replacementRange.isEmpty
    });
  }
  return edits;
}

// ../cursorless-engine/src/actions/BringMoveSwap.ts
var import_lodash38 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/util/setSelectionsAndFocusEditor.ts
async function setSelectionsAndFocusEditor(editor, selections, revealRange = true) {
  await setSelectionsWithoutFocusingEditor(editor, selections);
  if (revealRange) {
    await editor.revealRange(editor.selections[0]);
  }
  await editor.focus();
}
async function setSelectionsWithoutFocusingEditor(editor, selections) {
  await editor.setSelections(
    uniqWithHash(
      selections,
      (a, b) => a.isEqual(b),
      (s) => s.concise()
    )
  );
}

// ../cursorless-engine/src/util/unifyRanges.ts
function unifyRemovalTargets(targets) {
  if (targets.length < 2) {
    return targets;
  }
  return groupTargetsForEachEditor(targets).flatMap(([_editor, targets2]) => {
    if (targets2.length < 2) {
      return targets2;
    }
    let results = [...targets2];
    results.sort(
      (a, b) => a.contentRange.start.compareTo(b.contentRange.start)
    );
    let run = true;
    while (run) {
      [results, run] = unifyTargetsOnePass(results);
    }
    return results;
  });
}
function unifyTargetsOnePass(targets) {
  if (targets.length < 2) {
    return [targets, false];
  }
  const results = [];
  let currentGroup = [];
  targets.forEach((target) => {
    if (currentGroup.length && !intersects(currentGroup[currentGroup.length - 1], target)) {
      results.push(mergeTargets(currentGroup));
      currentGroup = [target];
    } else {
      currentGroup.push(target);
    }
  });
  results.push(mergeTargets(currentGroup));
  return [results, results.length !== targets.length];
}
function mergeTargets(targets) {
  if (targets.length === 1) {
    return targets[0];
  }
  const first = targets[0];
  const last2 = targets[targets.length - 1];
  return targetsToContinuousTarget(first, last2);
}
function intersects(targetA, targetB) {
  return !!targetA.getRemovalRange().intersection(targetB.getRemovalRange());
}

// ../cursorless-engine/src/actions/BringMoveSwap.ts
var BringMoveSwap = class {
  constructor(rangeUpdater, type2) {
    this.rangeUpdater = rangeUpdater;
    this.type = type2;
  }
  async decorateTargets(sources, destinations) {
    await Promise.all([
      flashTargets(
        ide(),
        sources,
        this.decoration.sourceStyle,
        this.decoration.getSourceRangeCallback
      ),
      flashTargets(ide(), destinations, this.decoration.destinationStyle)
    ]);
  }
  getEditsBringMove(sources, destinations) {
    const usedSources = [];
    const results = [];
    const shouldJoinSources = sources.length !== destinations.length && destinations.length === 1;
    sources.forEach((source, i) => {
      let destination = destinations[i];
      if ((source == null || destination == null) && !shouldJoinSources) {
        throw new Error("Targets must have same number of args");
      }
      if (destination != null) {
        let text;
        if (shouldJoinSources) {
          text = sources.map((source2, i2) => {
            const text2 = source2.contentText;
            const delimiter = (destination.isRaw ? null : destination.insertionDelimiter) ?? (source2.isRaw ? null : source2.insertionDelimiter);
            return i2 > 0 && delimiter != null ? delimiter + text2 : text2;
          }).join("");
        } else {
          text = source.contentText;
        }
        results.push({
          edit: destination.constructChangeEdit(text),
          editor: destination.editor,
          originalTarget: destination.target,
          isSource: false
        });
      } else {
        destination = destinations[0];
      }
      if (!usedSources.includes(source)) {
        usedSources.push(source);
        if (this.type === "bring") {
          results.push({
            edit: source.toDestination("to").constructChangeEdit(destination.target.contentText),
            editor: source.editor,
            originalTarget: source,
            isSource: true
          });
        }
      }
    });
    if (this.type === "move") {
      unifyRemovalTargets(usedSources).forEach((source) => {
        results.push({
          edit: source.constructRemovalEdit(),
          editor: source.editor,
          originalTarget: source,
          isSource: true
        });
      });
    }
    return results;
  }
  async performEditsAndComputeThatMark(edits) {
    return (0, import_lodash38.flatten)(
      await runForEachEditor(
        edits,
        (edit) => edit.editor,
        async (editor, edits2) => {
          const filteredEdits = this.type !== "bring" ? edits2 : edits2.filter(({ isSource }) => !isSource);
          const sourceEdits = this.type === "swap" ? [] : edits2.filter(({ isSource }) => isSource);
          const destinationEdits = this.type === "swap" ? edits2 : edits2.filter(({ isSource }) => !isSource);
          const sourceEditSelectionInfos = sourceEdits.map(
            ({ edit: { range: range4 }, originalTarget }) => getSelectionInfo(
              editor.document,
              range4.toSelection(originalTarget.isReversed),
              1 /* closedClosed */
            )
          );
          const destinationEditSelectionInfos = destinationEdits.map(
            ({ edit: { range: range4 }, originalTarget }) => getSelectionInfo(
              editor.document,
              range4.toSelection(originalTarget.isReversed),
              0 /* openOpen */
            )
          );
          const cursorSelectionInfos = editor.selections.map(
            (selection) => getSelectionInfo(
              editor.document,
              selection,
              1 /* closedClosed */
            )
          );
          const editableEditor = ide().getEditableTextEditor(editor);
          const [
            updatedSourceEditSelections,
            updatedDestinationEditSelections,
            cursorSelections
          ] = await performEditsAndUpdateFullSelectionInfos(
            this.rangeUpdater,
            editableEditor,
            filteredEdits.map(({ edit }) => edit),
            [
              sourceEditSelectionInfos,
              destinationEditSelectionInfos,
              cursorSelectionInfos
            ]
          );
          await setSelectionsWithoutFocusingEditor(
            editableEditor,
            cursorSelections
          );
          const marks2 = [
            ...this.getMarks(sourceEdits, updatedSourceEditSelections),
            ...this.getMarks(
              destinationEdits,
              updatedDestinationEditSelections
            )
          ];
          marks2.sort(
            (a, b) => edits2.findIndex((e) => e.originalTarget === a.target) - edits2.findIndex((e) => e.originalTarget === b.target)
          );
          return marks2;
        }
      )
    );
  }
  getMarks(edits, selections) {
    return edits.map((edit, index) => {
      const selection = selections[index];
      const range4 = edit.edit.updateRange(selection);
      const target = edit.originalTarget;
      return {
        editor: edit.editor,
        selection: range4.toSelection(target.isReversed),
        isSource: edit.isSource,
        target
      };
    });
  }
  async decorateThatMark(thatMark) {
    const getRange = (target) => thatMark.find((t) => t.target === target).selection;
    return Promise.all([
      flashTargets(
        ide(),
        thatMark.filter(({ isSource }) => isSource).map(({ target }) => target),
        this.decoration.sourceStyle,
        getRange
      ),
      flashTargets(
        ide(),
        thatMark.filter(({ isSource }) => !isSource).map(({ target }) => target),
        this.decoration.destinationStyle,
        getRange
      )
    ]);
  }
  calculateMarksBringMove(markEntries) {
    return {
      thatMark: markEntries.filter(({ isSource }) => !isSource),
      sourceMark: markEntries.filter(({ isSource }) => isSource)
    };
  }
};
function broadcastSource(sources, destinations) {
  if (sources.length === 1) {
    return Array(destinations.length).fill(sources[0]);
  }
  return sources;
}
var Bring = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "bring");
    this.decoration = {
      sourceStyle: "referenced" /* referenced */,
      destinationStyle: "pendingModification0" /* pendingModification0 */,
      getSourceRangeCallback: getContentRange2
    };
    this.run = this.run.bind(this);
  }
  async run(sources, destinations) {
    sources = broadcastSource(sources, destinations);
    await this.decorateTargets(
      sources,
      destinations.map((d) => d.target)
    );
    const edits = this.getEditsBringMove(sources, destinations);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    const { thatMark, sourceMark } = this.calculateMarksBringMove(markEntries);
    await this.decorateThatMark(thatMark);
    return { thatSelections: thatMark, sourceSelections: sourceMark };
  }
};
var Move = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "move");
    this.decoration = {
      sourceStyle: "pendingDelete" /* pendingDelete */,
      destinationStyle: "pendingModification0" /* pendingModification0 */,
      getSourceRangeCallback: getRemovalHighlightRange
    };
    this.run = this.run.bind(this);
  }
  async run(sources, destinations) {
    sources = broadcastSource(sources, destinations);
    await this.decorateTargets(
      sources,
      destinations.map((d) => d.target)
    );
    const edits = this.getEditsBringMove(sources, destinations);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    const { thatMark, sourceMark } = this.calculateMarksBringMove(markEntries);
    await this.decorateThatMark(thatMark);
    return { thatSelections: thatMark, sourceSelections: sourceMark };
  }
};
var Swap = class extends BringMoveSwap {
  constructor(rangeUpdater) {
    super(rangeUpdater, "swap");
    this.decoration = {
      sourceStyle: "pendingModification1" /* pendingModification1 */,
      destinationStyle: "pendingModification0" /* pendingModification0 */,
      getSourceRangeCallback: getContentRange2
    };
    this.run = this.run.bind(this);
  }
  async run(targets1, targets2) {
    await this.decorateTargets(targets1, targets2);
    const edits = this.getEditsSwap(targets1, targets2);
    const markEntries = await this.performEditsAndComputeThatMark(edits);
    await this.decorateThatMark(markEntries);
    return { thatSelections: markEntries, sourceSelections: [] };
  }
  getEditsSwap(targets1, targets2) {
    const results = [];
    targets1.forEach((target1, i) => {
      const target2 = targets2[i];
      if (target1 == null || target2 == null) {
        throw new Error("Targets must have same number of args");
      }
      results.push({
        edit: target2.toDestination("to").constructChangeEdit(target1.contentText),
        editor: target2.editor,
        originalTarget: target2,
        isSource: false
      });
      results.push({
        edit: target1.toDestination("to").constructChangeEdit(target2.contentText),
        editor: target1.editor,
        originalTarget: target1,
        isSource: true
      });
    });
    return results;
  }
};
function getRemovalHighlightRange(target) {
  return target.getRemovalHighlightRange();
}

// ../cursorless-engine/src/actions/Call.ts
var Call = class {
  constructor(actions2) {
    this.actions = actions2;
    this.run = this.run.bind(this);
  }
  async run(callees, args) {
    ensureSingleTarget(callees);
    const { returnValue: texts } = await this.actions.getText.run(callees, {
      showDecorations: false
    });
    const { thatSelections: thatMark } = await this.actions.wrapWithPairedDelimiter.run(args, texts[0] + "(", ")");
    return { thatSelections: thatMark };
  }
};

// ../cursorless-engine/src/actions/Clear.ts
var Clear = class {
  constructor(actions2) {
    this.actions = actions2;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const editor = ensureSingleEditor2(targets);
    const plainTargets = targets.map(
      (target) => new PlainTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: target.contentRange
      })
    );
    const { thatTargets } = await this.actions.remove.run(plainTargets);
    if (thatTargets != null) {
      await setSelectionsAndFocusEditor(
        ide().getEditableTextEditor(editor),
        thatTargets.map(({ contentSelection }) => contentSelection)
      );
    }
    return { thatTargets };
  }
};

// ../cursorless-engine/src/actions/CutToClipboard.ts
var CutToClipboard = class {
  constructor(actions2) {
    this.actions = actions2;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await ide().flashRanges(
      targets.flatMap((target) => {
        const { editor, contentRange } = target;
        const removalHighlightRange = target.getRemovalHighlightRange();
        if (target.isLine) {
          return [
            {
              editor,
              range: toCharacterRange(contentRange),
              style: "referenced" /* referenced */
            },
            {
              editor,
              range: toLineRange(removalHighlightRange),
              style: "pendingDelete" /* pendingDelete */
            }
          ];
        }
        return [
          {
            editor,
            range: toCharacterRange(contentRange),
            style: "referenced" /* referenced */
          },
          ...getOutsideOverflow(contentRange, removalHighlightRange).map(
            (overflow) => ({
              editor,
              range: toCharacterRange(overflow),
              style: "pendingDelete" /* pendingDelete */
            })
          )
        ];
      })
    );
    const options2 = { showDecorations: false };
    await this.actions.copyToClipboard.run(targets, options2);
    const { thatTargets } = await this.actions.remove.run(targets, options2);
    return { thatTargets };
  }
};
function getOutsideOverflow(insideRange, outsideRange) {
  const { start: insideStart, end: insideEnd } = insideRange;
  const { start: outsideStart, end: outsideEnd } = outsideRange;
  const result = [];
  if (outsideStart.isBefore(insideStart)) {
    result.push(new Range(outsideStart, insideStart));
  }
  if (outsideEnd.isAfter(insideEnd)) {
    result.push(new Range(insideEnd, outsideEnd));
  }
  return result;
}

// ../cursorless-engine/src/actions/Deselect.ts
var Deselect = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
      const newSelections = editor.selections.filter(
        (selection) => !targets2.some((target) => {
          const intersection = target.contentRange.intersection(selection);
          return intersection && (!intersection.isEmpty || selection.isEmpty);
        })
      );
      if (newSelections.length === 0) {
        throw new SelectionRequiredError();
      }
      await setSelectionsWithoutFocusingEditor(
        ide().getEditableTextEditor(editor),
        newSelections
      );
    });
    return {
      thatTargets: targets
    };
  }
};
var SelectionRequiredError = class extends Error {
  constructor() {
    super("Can't deselect every selection. At least one is required");
    this.name = "SelectionRequiredError";
  }
};

// ../cursorless-engine/src/actions/EditNew/runEditTargets.ts
var import_lodash39 = __toESM(require_lodash(), 1);
async function runEditTargets(rangeUpdater, editor, state) {
  const destinations = state.destinations.map((destination, index) => {
    const actionType = destination.getEditNewActionType();
    if (actionType === "edit") {
      return {
        destination,
        index
      };
    }
  }).filter((destination) => !!destination);
  if (destinations.length === 0) {
    return state;
  }
  const edits = destinations.map(
    (destination) => destination.destination.constructChangeEdit("")
  );
  const thatSelections = {
    selections: state.thatRanges.map((r) => r.toSelection(false))
  };
  const cursorInfos = state.cursorRanges.map((range4, index) => ({ range: range4, index })).filter(({ range: range4 }) => range4 != null);
  const cursorIndices = cursorInfos.map(({ index }) => index);
  const cursorSelections = {
    selections: cursorInfos.map(({ range: range4 }) => range4.toSelection(false))
  };
  const editSelections = {
    selections: edits.map((edit) => edit.range.toSelection(false)),
    rangeBehavior: 0 /* openOpen */
  };
  const [
    updatedThatSelections,
    updatedCursorSelections,
    updatedEditSelections
  ] = await performEditsAndUpdateSelectionsWithBehavior(
    rangeUpdater,
    editor,
    edits,
    [thatSelections, cursorSelections, editSelections]
  );
  const updatedCursorRanges = [...state.cursorRanges];
  (0, import_lodash39.zip)(cursorIndices, updatedCursorSelections).forEach(([index, selection]) => {
    updatedCursorRanges[index] = selection;
  });
  destinations.forEach((delimiterTarget, index) => {
    const edit = edits[index];
    const range4 = edit.updateRange(updatedEditSelections[index]);
    updatedCursorRanges[delimiterTarget.index] = range4;
  });
  return {
    destinations: state.destinations,
    thatRanges: updatedThatSelections,
    cursorRanges: updatedCursorRanges
  };
}

// ../cursorless-engine/src/actions/EditNew/runInsertLineAfterTargets.ts
async function runInsertLineAfterTargets(rangeUpdater, editor, state) {
  const destinations = state.destinations.map((destination, index) => {
    const actionType = destination.getEditNewActionType();
    if (actionType === "insertLineAfter") {
      return {
        destination,
        index
      };
    }
  }).filter((destination) => !!destination);
  if (destinations.length === 0) {
    return state;
  }
  const contentRanges = destinations.map(
    ({ destination }) => destination.contentRange
  );
  const [updatedTargetRanges, updatedThatRanges] = await callFunctionAndUpdateRanges(
    rangeUpdater,
    () => editor.insertLineAfter(contentRanges),
    editor.document,
    [
      state.destinations.map(({ contentRange }) => contentRange),
      state.thatRanges
    ]
  );
  const cursorRanges = [...state.cursorRanges];
  destinations.forEach((commandTarget, index) => {
    cursorRanges[commandTarget.index] = editor.selections[index];
  });
  return {
    destinations: state.destinations.map(
      (destination, index) => destination.withTarget(
        destination.target.withContentRange(updatedTargetRanges[index])
      )
    ),
    thatRanges: updatedThatRanges,
    cursorRanges
  };
}

// ../cursorless-engine/src/actions/EditNew/runNotebookCellTargets.ts
async function runEditNewNotebookCellTargets(actions2, destinations) {
  const destination = ensureSingleTarget(destinations);
  const editor = ide().getEditableTextEditor(destination.editor);
  const isAbove = destination.insertionMode === "before";
  if (destination.insertionMode === "to") {
    throw Error(
      `Unsupported insertion mode '${destination.insertionMode}' for notebookcapell`
    );
  }
  await actions2.setSelection.run([destination.target]);
  let modifyThatMark = (selection) => selection;
  if (isAbove) {
    modifyThatMark = await editor.editNewNotebookCellAbove();
  } else {
    await editor.editNewNotebookCellBelow();
  }
  const thatMark = createThatMark([destination.target.thatTarget]);
  thatMark[0].selection = modifyThatMark(thatMark[0].selection);
  return { thatSelections: thatMark };
}

// ../cursorless-engine/src/actions/EditNew/EditNew.ts
var EditNew = class {
  constructor(rangeUpdater, actions2) {
    this.rangeUpdater = rangeUpdater;
    this.actions = actions2;
    this.run = this.run.bind(this);
  }
  async run(destinations) {
    if (destinations.some(({ target }) => target.isNotebookCell)) {
      return runEditNewNotebookCellTargets(this.actions, destinations);
    }
    const editableEditor = ide().getEditableTextEditor(
      ensureSingleEditor2(destinations)
    );
    let state = {
      destinations,
      thatRanges: destinations.map(
        ({ target }) => target.thatTarget.contentRange
      ),
      cursorRanges: new Array(destinations.length).fill(
        void 0
      )
    };
    state = await runInsertLineAfterTargets(
      this.rangeUpdater,
      editableEditor,
      state
    );
    state = await runEditTargets(this.rangeUpdater, editableEditor, state);
    const newSelections = state.destinations.map(
      (destination, index) => state.cursorRanges[index].toSelection(destination.target.isReversed)
    );
    await setSelectionsAndFocusEditor(editableEditor, newSelections);
    return {
      thatSelections: createThatMark(
        state.destinations.map((d) => d.target),
        state.thatRanges
      )
    };
  }
};

// ../cursorless-engine/src/actions/EditNewLineAction.ts
var EditNewLineAction = class {
  constructor(actions2, modifierStageFactory) {
    this.actions = actions2;
    this.modifierStageFactory = modifierStageFactory;
    this.run = this.run.bind(this);
  }
  getFinalStages() {
    return [this.modifierStageFactory.create(containingLineIfUntypedModifier)];
  }
  run(targets) {
    return this.actions.editNew.run(
      targets.map((target) => target.toDestination(this.insertionMode))
    );
  }
};
var EditNewBefore = class extends EditNewLineAction {
  constructor() {
    super(...arguments);
    this.insertionMode = "before";
  }
};
var EditNewAfter = class extends EditNewLineAction {
  constructor() {
    super(...arguments);
    this.insertionMode = "after";
  }
};

// ../cursorless-engine/src/actions/CallbackAction.ts
var import_lodash40 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/core/commandRunner/selectionToStoredTarget.ts
var selectionToStoredTarget = (selection) => new UntypedTarget({
  editor: selection.editor,
  isReversed: selection.selection.isReversed,
  contentRange: selection.selection,
  hasExplicitRange: true
});

// ../cursorless-engine/src/actions/CallbackAction.ts
var CallbackAction = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, options2) {
    if (options2.showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    if (options2.ensureSingleEditor) {
      ensureSingleEditor2(targets);
    }
    if (options2.ensureSingleTarget) {
      ensureSingleTarget(targets);
    }
    const originalEditor = ide().activeEditableTextEditor;
    const runOnTargets = options2.setSelection ? runOnTargetsForEachEditorSequentially : runOnTargetsForEachEditor;
    const thatTargets = (0, import_lodash40.flatten)(
      await runOnTargets(
        targets,
        (editor, targets2) => this.runForEditor(options2, editor, targets2)
      )
    );
    if (options2.setSelection && options2.restoreSelection && originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    return { thatTargets };
  }
  async runForEditor(options2, editor, targets) {
    const editableEditor = ide().getEditableTextEditor(editor);
    const originalSelections = editor.selections;
    const originalEditorVersion = editor.document.version;
    const targetSelections = targets.map((target) => target.contentSelection);
    if (options2.setSelection) {
      await setSelectionsAndFocusEditor(
        editableEditor,
        targetSelections,
        false
      );
    }
    const [updatedOriginalSelections, updatedTargetSelections] = await callFunctionAndUpdateSelections(
      this.rangeUpdater,
      () => options2.callback(editableEditor, targets),
      editor.document,
      [originalSelections, targetSelections]
    );
    if (options2.setSelection && options2.restoreSelection) {
      await setSelectionsWithoutFocusingEditor(
        editableEditor,
        updatedOriginalSelections
      );
    }
    return editor.document.version === originalEditorVersion ? targets : updatedTargetSelections.map(
      (selection) => selectionToStoredTarget({
        editor,
        selection
      })
    );
  }
};

// ../cursorless-engine/src/actions/ExecuteCommand.ts
var ExecuteCommand = class {
  constructor(rangeUpdater) {
    this.callbackAction = new CallbackAction(rangeUpdater);
    this.run = this.run.bind(this);
  }
  async run(targets, commandId, {
    commandArgs,
    ensureSingleEditor: ensureSingleEditor3,
    ensureSingleTarget: ensureSingleTarget2,
    restoreSelection,
    showDecorations
  } = {}) {
    const args = commandArgs ?? [];
    return this.callbackAction.run(targets, {
      callback: () => ide().executeCommand(commandId, ...args),
      setSelection: true,
      ensureSingleEditor: ensureSingleEditor3 ?? false,
      ensureSingleTarget: ensureSingleTarget2 ?? false,
      restoreSelection: restoreSelection ?? true,
      showDecorations: showDecorations ?? true
    });
  }
};

// ../cursorless-engine/src/actions/Find.ts
var Find = class {
  constructor(actions2) {
    this.actions = actions2;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    ensureSingleTarget(targets);
    const { returnValue, thatTargets } = await this.actions.getText.run(targets);
    const [text] = returnValue;
    let query;
    if (text.length > 200) {
      query = text.substring(0, 200);
      showWarning(
        ide().messages,
        "truncatedSearchText",
        "Search text is longer than 200 characters; truncating"
      );
    } else {
      query = text;
    }
    await this.find(query);
    return { thatTargets };
  }
};
var FindInDocument = class extends Find {
  find(query) {
    return ide().findInDocument(query);
  }
};
var FindInWorkspace = class extends Find {
  find(query) {
    return ide().findInWorkspace(query);
  }
};

// ../cursorless-engine/src/actions/FollowLink.ts
var FollowLink = class {
  constructor(actions2) {
    this.actions = actions2;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const target = ensureSingleTarget(targets);
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    const openedLink = await ide().getEditableTextEditor(target.editor).openLink(target.contentRange);
    if (!openedLink) {
      await this.actions.executeCommand.run(
        targets,
        "editor.action.revealDefinition",
        { restoreSelection: false }
      );
    }
    return {
      thatSelections: createThatMark(targets)
    };
  }
};

// ../cursorless-engine/src/actions/GenerateSnippet/constructSnippetBody.ts
var import_lodash41 = __toESM(require_lodash(), 1);
function constructSnippetBody(text, linePrefix) {
  const outputLines = [];
  let currentTabCount = 0;
  let currentIndentationString = null;
  const [firstLine, ...remainingLines] = text.split(/\r?\n/);
  const lines = [
    {
      text: linePrefix + firstLine,
      startIndex: linePrefix.length
    },
    ...remainingLines.map((line) => ({ text: line, startIndex: 0 }))
  ];
  lines.forEach(({ text: text2, startIndex }) => {
    const newIndentationString = text2.match(/^\s*/)?.[0] ?? "";
    const firstNonWhitespaceCharacterIndex = newIndentationString.length;
    if (currentIndentationString != null) {
      if (newIndentationString.length > currentIndentationString.length) {
        currentTabCount++;
      } else if (newIndentationString.length < currentIndentationString.length) {
        currentTabCount--;
      }
    }
    currentIndentationString = newIndentationString;
    const lineContentStart = Math.max(
      firstNonWhitespaceCharacterIndex,
      startIndex
    );
    const snippetIndentationString = (0, import_lodash41.repeat)("	", currentTabCount);
    const lineContent = text2.slice(lineContentStart);
    outputLines.push(snippetIndentationString + lineContent);
  });
  return outputLines;
}

// ../cursorless-engine/src/actions/GenerateSnippet/editText.ts
var import_lodash42 = __toESM(require_lodash(), 1);
function editText(text, edits) {
  const sortedEdits = (0, import_lodash42.sortBy)(edits, (edit) => edit.offsets.start);
  let output = "";
  let currentOffset = 0;
  for (const edit of sortedEdits) {
    output += text.slice(currentOffset, edit.offsets.start) + edit.text;
    currentOffset = edit.offsets.end;
  }
  output += text.slice(currentOffset);
  return output;
}

// ../cursorless-engine/src/actions/GenerateSnippet/openNewSnippetFile.ts
var import_promises4 = require("fs/promises");
var import_path4 = require("path");
async function openNewSnippetFile(snippetName) {
  const userSnippetsDir = ide().configuration.getOwnConfiguration(
    "experimental.snippetsDir"
  );
  if (!userSnippetsDir) {
    throw new Error("User snippets dir not configured.");
  }
  const path8 = (0, import_path4.join)(userSnippetsDir, `${snippetName}.cursorless-snippets`);
  await touch(path8);
  await ide().openTextDocument(path8);
}
async function touch(path8) {
  const file = await (0, import_promises4.open)(path8, "w");
  await file.close();
}

// ../cursorless-engine/src/actions/GenerateSnippet/Substituter.ts
var Substituter = class {
  constructor() {
    this.substitutions = [];
  }
  /**
   * Get a random id that can be put into your text body that will then be
   * replaced by {@link to} when you call {@link makeSubstitutions}.
   * @param to The string that you'd like to end up in the final document after
   * replacements
   * @param isQuoted Use this variable to indicate that in the final text the
   * variable will end up quoted. This occurs if you use the replacement string
   * as a stand alone string in a json document and then you serialize it
   * @returns A unique random id that can be put into the document that will
   * then be substituted later
   */
  addSubstitution(to, isQuoted = false) {
    const randomId = makeid(10);
    this.substitutions.push({
      to,
      randomId,
      isQuoted
    });
    return randomId;
  }
  /**
   * Performs substitutions on {@link text}, replacing the random ids generated
   * by {@link addSubstitution} with the values passed in for `to`.
   * @param text The text to perform substitutions on
   * @returns The text with variable substituted for the original values you
   * desired
   */
  makeSubstitutions(text) {
    this.substitutions.forEach(({ to, randomId, isQuoted }) => {
      const from = isQuoted ? `"${randomId}"` : randomId;
      text = text.split(from).join(to);
    });
    return text;
  }
};
function makeid(length) {
  let result = "";
  const characters2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters2.length;
  for (let i = 0; i < length; i++) {
    result += characters2.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}

// ../cursorless-engine/src/actions/GenerateSnippet/GenerateSnippet.ts
var GenerateSnippet = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets, snippetName) {
    const target = ensureSingleTarget(targets);
    const editor = target.editor;
    flashTargets(ide(), targets, "referenced" /* referenced */);
    if (snippetName == null) {
      snippetName = await ide().showInputBox({
        prompt: "Name of snippet",
        placeHolder: "helloWorld"
      });
    }
    if (snippetName == null) {
      return {};
    }
    let currentPlaceholderIndex = 1;
    const baseOffset = editor.document.offsetAt(target.contentRange.start);
    const variables = editor.selections.filter((selection) => target.contentRange.contains(selection)).map((selection, index) => ({
      offsets: {
        start: editor.document.offsetAt(selection.start) - baseOffset,
        end: editor.document.offsetAt(selection.end) - baseOffset
      },
      defaultName: `variable${index + 1}`,
      placeholderIndex: currentPlaceholderIndex++
    }));
    const substituter = new Substituter();
    const linePrefix = editor.document.getText(
      new Range(
        target.contentRange.start.with(void 0, 0),
        target.contentRange.start
      )
    );
    const originalText = editor.document.getText(target.contentRange);
    const snippetBodyText = editText(originalText, [
      ...matchAll(originalText, /\$|\\/g, (match2) => ({
        offsets: {
          start: match2.index,
          end: match2.index + match2[0].length
        },
        text: match2[0] === "\\" ? `\\${match2[0]}` : `\\\\${match2[0]}`
      })),
      ...variables.map(({ offsets, defaultName, placeholderIndex }) => ({
        offsets,
        // Note that the reason we use the substituter here is primarily so
        // that the `\` below doesn't get escaped upon conversion to json.
        text: substituter.addSubstitution(
          [
            // This `\$` will end up being a `$` in the final document.  It
            // indicates the start of a variable in the user snippet.  We need
            // the `\` so that the meta-snippet doesn't see it as one of its
            // placeholders.
            "\\$",
            // The remaining text here is a placeholder in the meta-snippet
            // that the user can use to name their snippet variable that will
            // be in the user snippet.
            "${",
            placeholderIndex,
            ":",
            defaultName,
            "}"
          ].join("")
        )
      }))
    ]);
    const snippetLines = constructSnippetBody(snippetBodyText, linePrefix);
    const constructVariableDescriptionEntry = ({
      placeholderIndex
    }) => {
      const key = "$" + placeholderIndex;
      const value = substituter.addSubstitution(
        "{$" + currentPlaceholderIndex++ + "}",
        true
      );
      return [key, value];
    };
    const snippet2 = {
      [snippetName]: {
        definitions: [
          {
            scope: {
              langIds: [editor.document.languageId]
            },
            body: snippetLines
          }
        ],
        description: "$" + currentPlaceholderIndex++,
        variables: variables.length === 0 ? void 0 : Object.fromEntries(
          variables.map(constructVariableDescriptionEntry)
        )
      }
    };
    const snippetText = substituter.makeSubstitutions(
      JSON.stringify(snippet2, null, 2)
    );
    const editableEditor = ide().getEditableTextEditor(editor);
    if (isTesting()) {
      await editableEditor.setSelections([
        editor.document.range.toSelection(false)
      ]);
    } else {
      await openNewSnippetFile(snippetName);
    }
    await editableEditor.insertSnippet(snippetText);
    return {
      thatSelections: targets.map(({ editor: editor2, contentSelection }) => ({
        editor: editor2,
        selection: contentSelection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/GetTargets.ts
var GetTargets = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets) {
    return {
      returnValue: targets.map(({ contentRange }) => ({
        contentRange
      })),
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/GetText.ts
var GetText = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets, {
    showDecorations = true,
    ensureSingleTarget: doEnsureSingleTarget = false
  } = {}) {
    if (showDecorations) {
      await flashTargets(ide(), targets, "referenced" /* referenced */);
    }
    if (doEnsureSingleTarget) {
      ensureSingleTarget(targets);
    }
    return {
      returnValue: targets.map((target) => target.contentText),
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/Highlight.ts
var Highlight = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  async run(targets, highlightId) {
    if (ide().capabilities.commands["highlight"] == null) {
      throw Error(`The highlight action is not supported by your ide`);
    }
    if (targets.length === 0) {
      await Promise.all(
        ide().visibleTextEditors.map(
          (editor) => ide().setHighlightRanges(highlightId, editor, [])
        )
      );
    } else {
      await runOnTargetsForEachEditor(
        targets,
        (editor, targets2) => ide().setHighlightRanges(
          highlightId,
          editor,
          targets2.map(toGeneralizedRange)
        )
      );
    }
    return {
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/InsertCopy.ts
var import_lodash43 = __toESM(require_lodash(), 1);
var InsertCopy = class {
  constructor(rangeUpdater, modifierStageFactory, isBefore) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.isBefore = isBefore;
    this.getFinalStages = () => [
      this.modifierStageFactory.create(containingLineIfUntypedModifier)
    ];
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets) {
    const results = (0, import_lodash43.flatten)(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    await ide().flashRanges(
      results.flatMap(
        (result) => result.thatMark.map((that) => ({
          editor: that.editor,
          range: toCharacterRange(that.selection),
          style: "justAdded" /* justAdded */
        }))
      )
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
  async runForEditor(editor, targets) {
    const position = this.isBefore ? "after" : "before";
    const edits = targets.flatMap(
      (target) => target.toDestination(position).constructChangeEdit(target.contentText)
    );
    const cursorSelections = { selections: editor.selections };
    const contentSelections = {
      selections: targets.map(({ contentSelection }) => contentSelection)
    };
    const editSelections = {
      selections: edits.map(
        ({ range: range4 }) => new Selection(range4.start, range4.end)
      ),
      rangeBehavior: 0 /* openOpen */
    };
    const editableEditor = ide().getEditableTextEditor(editor);
    const [
      updatedCursorSelections,
      updatedContentSelections,
      updatedEditSelections
    ] = await performEditsAndUpdateSelectionsWithBehavior(
      this.rangeUpdater,
      editableEditor,
      edits,
      [cursorSelections, contentSelections, editSelections]
    );
    const insertionRanges = (0, import_lodash43.zip)(edits, updatedEditSelections).map(
      ([edit, selection]) => edit.updateRange(selection)
    );
    await setSelectionsWithoutFocusingEditor(
      editableEditor,
      updatedCursorSelections
    );
    const primarySelection = editor.selections[0];
    if (updatedContentSelections.some(
      (selection) => selection.intersection(primarySelection) != null
    )) {
      await editableEditor.revealRange(primarySelection);
    }
    return {
      sourceMark: createThatMark(targets, insertionRanges),
      thatMark: createThatMark(targets, updatedContentSelections)
    };
  }
};
var CopyContentBefore = class extends InsertCopy {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory, true);
  }
};
var CopyContentAfter = class extends InsertCopy {
  constructor(rangeUpdater, modifierStageFactory) {
    super(rangeUpdater, modifierStageFactory, false);
  }
};

// ../cursorless-engine/src/actions/InsertEmptyLines.ts
var import_lodash44 = __toESM(require_lodash(), 1);
var InsertEmptyLines = class {
  constructor(rangeUpdater, insertAbove, insertBelow) {
    this.rangeUpdater = rangeUpdater;
    this.insertAbove = insertAbove;
    this.insertBelow = insertBelow;
    this.run = this.run.bind(this);
  }
  getRanges(targets) {
    let lines = targets.flatMap((target) => {
      const lines2 = [];
      if (this.insertAbove) {
        lines2.push(target.contentRange.start.line);
      }
      if (this.insertBelow) {
        lines2.push(target.contentRange.end.line + 1);
      }
      return lines2;
    });
    lines = [...new Set(lines)];
    return lines.map((line) => new Range(line, 0, line, 0));
  }
  getEdits(ranges) {
    return ranges.map((range4) => ({
      range: range4,
      text: "\n"
    }));
  }
  async run(targets) {
    const results = (0, import_lodash44.flatten)(
      await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
        const ranges = this.getRanges(targets2);
        const edits = this.getEdits(ranges);
        const editableEditor = ide().getEditableTextEditor(editor);
        const [updatedThatSelections, lineSelections, updatedCursorSelections] = await performEditsAndUpdateSelections(
          this.rangeUpdater,
          editableEditor,
          edits,
          [
            targets2.map((target) => target.thatTarget.contentSelection),
            ranges.map((range4) => new Selection(range4.start, range4.end)),
            editor.selections
          ]
        );
        await setSelectionsWithoutFocusingEditor(
          editableEditor,
          updatedCursorSelections
        );
        return {
          thatMark: updatedThatSelections.map((selection) => ({
            editor,
            selection
          })),
          lineSelections: lineSelections.map((selection, index) => ({
            editor,
            range: ranges[index].start.line < editor.document.lineCount - 1 ? new Range(
              selection.start.translate(-1, void 0),
              selection.end.translate(-1, void 0)
            ) : selection
          }))
        };
      })
    );
    await ide().flashRanges(
      results.flatMap(
        (result) => result.lineSelections.map(({ editor, range: range4 }) => ({
          editor,
          range: toLineRange(range4),
          style: "justAdded" /* justAdded */
        }))
      )
    );
    const thatMark = results.flatMap((result) => result.thatMark);
    return { thatSelections: thatMark };
  }
};
var InsertEmptyLinesAround = class extends InsertEmptyLines {
  constructor(rangeUpdater) {
    super(rangeUpdater, true, true);
  }
};
var InsertEmptyLineAbove = class extends InsertEmptyLines {
  constructor(rangeUpdater) {
    super(rangeUpdater, true, false);
  }
};
var InsertEmptyLineBelow = class extends InsertEmptyLines {
  constructor(rangeUpdater) {
    super(rangeUpdater, false, true);
  }
};

// ../cursorless-engine/src/snippets/vendor/vscodeSnippet/snippetParser.ts
var Scanner = class _Scanner {
  constructor() {
    this.value = "";
    this.pos = 0;
  }
  static {
    this._table = {
      [36 /* DollarSign */]: 0 /* Dollar */,
      [58 /* Colon */]: 1 /* Colon */,
      [44 /* Comma */]: 2 /* Comma */,
      [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,
      [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,
      [92 /* Backslash */]: 5 /* Backslash */,
      [47 /* Slash */]: 6 /* Forwardslash */,
      [124 /* Pipe */]: 7 /* Pipe */,
      [43 /* Plus */]: 11 /* Plus */,
      [45 /* Dash */]: 12 /* Dash */,
      [63 /* QuestionMark */]: 13 /* QuestionMark */
    };
  }
  static isDigitCharacter(ch) {
    return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
  }
  static isVariableCharacter(ch) {
    return ch === 95 /* Underline */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 65 /* A */ && ch <= 90 /* Z */;
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return { type: 14 /* EOF */, pos: this.pos, len: 0 };
    }
    let pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type2;
    type2 = _Scanner._table[ch];
    if (typeof type2 === "number") {
      this.pos += 1;
      return { type: type2, pos, len: 1 };
    }
    if (_Scanner.isDigitCharacter(ch)) {
      type2 = 8 /* Int */;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (_Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type: type2, pos, len };
    }
    if (_Scanner.isVariableCharacter(ch)) {
      type2 = 9 /* VariableName */;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type: type2, pos, len };
    }
    type2 = 10 /* Format */;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
    this.pos += len;
    return { type: type2, pos, len };
  }
};
var Marker = class {
  constructor() {
    this._children = [];
  }
  appendChild(child) {
    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  replace(child, others) {
    const { parent } = child;
    const idx = parent.children.indexOf(child);
    const newChildren = parent.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent._children = newChildren;
    (function _fixParent(children, parent2) {
      for (const child2 of children) {
        child2.parent = parent2;
        _fixParent(child2.children, child2);
      }
    })(others, parent);
  }
  get children() {
    return this._children;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
};
var Text = class _Text extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  toString() {
    return this.value;
  }
  toTextmateString() {
    return _Text.escape(this.value);
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new _Text(this.value);
  }
};
var TransformableMarker = class extends Marker {
};
var Placeholder = class _Placeholder extends TransformableMarker {
  constructor(index) {
    super();
    this.index = index;
  }
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0 && !this.transform) {
      return `$${this.index}`;
    } else if (this.children.length === 0) {
      return `\${${this.index}${transformString}}`;
    } else if (this.choice) {
      return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
    } else {
      return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    let ret = new _Placeholder(this.index);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var Choice = class _Choice extends Marker {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  appendChild(marker) {
    if (marker instanceof Text) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  toTextmateString() {
    return this.options.map((option) => option.value.replace(/\||,|\\/g, "\\$&")).join(",");
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    let ret = new _Choice();
    this.options.forEach(ret.appendChild, ret);
    return ret;
  }
};
var Transform = class _Transform extends Marker {
  constructor() {
    super(...arguments);
    this.regexp = new RegExp("");
  }
  resolve(value) {
    const _this = this;
    let didMatch = false;
    let ret = value.replace(this.regexp, function() {
      didMatch = true;
      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret = this._replace([]);
    }
    return ret;
  }
  _replace(groups) {
    let ret = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret += value;
      } else {
        ret += marker.toString();
      }
    }
    return ret;
  }
  toString() {
    return "";
  }
  toTextmateString() {
    return `/${this.regexp.source}/${this.children.map((c) => c.toTextmateString())}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
  }
  clone() {
    let ret = new _Transform();
    ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var FormatString = class _FormatString extends Marker {
  constructor(index, shorthandName, ifValue, elseValue) {
    super();
    this.index = index;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (this.shorthandName === "camelcase") {
      return !value ? "" : this._toCamelCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!Boolean(value) && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match2 = value.match(/[a-z0-9]+/gi);
    if (!match2) {
      return value;
    }
    return match2.map((word) => {
      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
    }).join("");
  }
  _toCamelCase(value) {
    const match2 = value.match(/[a-z0-9]+/gi);
    if (!match2) {
      return value;
    }
    return match2.map((word, index) => {
      if (index === 0) {
        return word.toLowerCase();
      } else {
        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
      }
    }).join("");
  }
  toTextmateString() {
    let value = "${";
    value += this.index;
    if (this.shorthandName) {
      value += `:/${this.shorthandName}`;
    } else if (this.ifValue && this.elseValue) {
      value += `:?${this.ifValue}:${this.elseValue}`;
    } else if (this.ifValue) {
      value += `:+${this.ifValue}`;
    } else if (this.elseValue) {
      value += `:-${this.elseValue}`;
    }
    value += "}";
    return value;
  }
  clone() {
    let ret = new _FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret;
  }
};
var Variable = class _Variable extends TransformableMarker {
  constructor(name) {
    super();
    this.name = name;
  }
  resolve(resolver) {
    let value = resolver.resolve(this);
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text(value)];
      return true;
    }
    return false;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0) {
      return `\${${this.name}${transformString}}`;
    } else {
      return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    const ret = new _Variable(this.name);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var TextmateSnippet = class _TextmateSnippet extends Marker {
  get placeholderInfo() {
    if (!this._placeholders) {
      let all = [];
      let last2;
      this.walk(function(candidate) {
        if (candidate instanceof Placeholder) {
          all.push(candidate);
          last2 = !last2 || last2.index < candidate.index ? candidate : last2;
        }
        return true;
      });
      this._placeholders = { all, last: last2 };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all } = this.placeholderInfo;
    return all;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret = 0;
    walk([marker], (marker2) => {
      ret += marker2.len();
      return true;
    });
    return ret;
  }
  enclosingPlaceholders(placeholder) {
    let ret = [];
    let { parent } = placeholder;
    while (parent) {
      if (parent instanceof Placeholder) {
        ret.push(parent);
      }
      parent = parent.parent;
    }
    return ret;
  }
  resolveVariables(resolver) {
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        if (candidate.resolve(resolver)) {
          this._placeholders = void 0;
        }
      }
      return true;
    });
    return this;
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  toTextmateString() {
    return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
  }
  clone() {
    let ret = new _TextmateSnippet();
    this._children = this.children.map((child) => child.clone());
    return ret;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
var SnippetParser = class {
  constructor() {
    this._scanner = new Scanner();
    this._token = { type: 14 /* EOF */, pos: 0, len: 0 };
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(template) {
    return /\${?CLIPBOARD/.test(template);
  }
  text(value) {
    return this.parse(value).toString();
  }
  parse(value, insertFinalTabstop, enforceFinalTabstop) {
    this._scanner.text(value);
    this._token = this._scanner.next();
    const snippet2 = new TextmateSnippet();
    while (this._parse(snippet2)) {
    }
    const placeholderDefaultValues = /* @__PURE__ */ new Map();
    const incompletePlaceholders = [];
    let placeholderCount = 0;
    snippet2.walk((marker) => {
      if (marker instanceof Placeholder) {
        placeholderCount += 1;
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    for (const placeholder of incompletePlaceholders) {
      const defaultValues = placeholderDefaultValues.get(placeholder.index);
      if (defaultValues) {
        const clone = new Placeholder(placeholder.index);
        clone.transform = placeholder.transform;
        for (const child of defaultValues) {
          clone.appendChild(child.clone());
        }
        snippet2.replace(placeholder, [clone]);
      }
    }
    if (!enforceFinalTabstop) {
      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;
    }
    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {
      snippet2.appendChild(new Placeholder(0));
    }
    return snippet2;
  }
  _accept(type2, value) {
    if (type2 === void 0 || this._token.type === type2) {
      let ret = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type2) {
    const start = this._token;
    while (this._token.type !== type2) {
      if (this._token.type === 14 /* EOF */) {
        return false;
      } else if (this._token.type === 5 /* Backslash */) {
        const nextToken = this._scanner.next();
        if (nextToken.type !== 0 /* Dollar */ && nextToken.type !== 4 /* CurlyClose */ && nextToken.type !== 5 /* Backslash */) {
          return false;
        }
      }
      this._token = this._scanner.next();
    }
    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  // \$, \\, \} -> just text
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5 /* Backslash */, true)) {
      value = this._accept(0 /* Dollar */, true) || this._accept(4 /* CurlyClose */, true) || this._accept(5 /* Backslash */, true) || value;
      marker.appendChild(new Text(value));
      return true;
    }
    return false;
  }
  // $foo -> variable, $1 -> tabstop
  _parseTabstopOrVariableName(parent) {
    let value;
    const token = this._token;
    const match2 = this._accept(0 /* Dollar */) && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));
    if (!match2) {
      return this._backTo(token);
    }
    parent.appendChild(
      /^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value)
    );
    return true;
  }
  // ${1:<children>}, ${1} -> placeholder
  _parseComplexPlaceholder(parent) {
    let index;
    const token = this._token;
    const match2 = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (index = this._accept(8 /* Int */, true));
    if (!match2) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index));
    if (this._accept(1 /* Colon */)) {
      while (true) {
        if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent.appendChild(new Text("${" + index + ":"));
        placeholder.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(2 /* Comma */)) {
            continue;
          }
          if (this._accept(7 /* Pipe */)) {
            placeholder.appendChild(choice);
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(6 /* Forwardslash */)) {
      if (this._parseTransform(placeholder)) {
        parent.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent) {
    const token = this._token;
    const values2 = [];
    while (true) {
      if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {
        break;
      }
      let value;
      if (value = this._accept(5 /* Backslash */, true)) {
        value = this._accept(2 /* Comma */, true) || this._accept(7 /* Pipe */, true) || this._accept(5 /* Backslash */, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values2.push(value);
    }
    if (values2.length === 0) {
      this._backTo(token);
      return false;
    }
    parent.appendChild(new Text(values2.join("")));
    return true;
  }
  // ${foo:<children>}, ${foo} -> variable
  _parseComplexVariable(parent) {
    let name;
    const token = this._token;
    const match2 = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (name = this._accept(9 /* VariableName */, true));
    if (!match2) {
      return this._backTo(token);
    }
    const variable = new Variable(name);
    if (this._accept(1 /* Colon */)) {
      while (true) {
        if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent.appendChild(new Text("${" + name + ":"));
        variable.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (this._accept(6 /* Forwardslash */)) {
      if (this._parseTransform(variable)) {
        parent.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent) {
    let transform = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(6 /* Forwardslash */)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5 /* Backslash */, true)) {
        escaped = this._accept(6 /* Forwardslash */, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14 /* EOF */) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(6 /* Forwardslash */)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5 /* Backslash */, true)) {
        escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;
        transform.appendChild(new Text(escaped));
        continue;
      }
      if (this._parseFormatString(transform) || this._parseAnything(transform)) {
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(4 /* CurlyClose */)) {
        break;
      }
      if (this._token.type !== 14 /* EOF */) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent.transform = transform;
    return true;
  }
  _parseFormatString(parent) {
    const token = this._token;
    if (!this._accept(0 /* Dollar */)) {
      return false;
    }
    let complex = false;
    if (this._accept(3 /* CurlyOpen */)) {
      complex = true;
    }
    let index = this._accept(8 /* Int */, true);
    if (!index) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (this._accept(4 /* CurlyClose */)) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (!this._accept(1 /* Colon */)) {
      this._backTo(token);
      return false;
    }
    if (this._accept(6 /* Forwardslash */)) {
      let shorthand = this._accept(9 /* VariableName */, true);
      if (!shorthand || !this._accept(4 /* CurlyClose */)) {
        this._backTo(token);
        return false;
      } else {
        parent.appendChild(new FormatString(Number(index), shorthand));
        return true;
      }
    } else if (this._accept(11 /* Plus */)) {
      let ifValue = this._until(4 /* CurlyClose */);
      if (ifValue) {
        parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(12 /* Dash */)) {
      let elseValue = this._until(4 /* CurlyClose */);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(13 /* QuestionMark */)) {
      let ifValue = this._until(1 /* Colon */);
      if (ifValue) {
        let elseValue = this._until(4 /* CurlyClose */);
        if (elseValue) {
          parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      let elseValue = this._until(4 /* CurlyClose */);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14 /* EOF */) {
      marker.appendChild(new Text(this._scanner.tokenText(this._token)));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};

// ../cursorless-engine/src/snippets/vendor/vscodeSnippet/snippetVariables.ts
var KnownSnippetVariableNames = Object.freeze({
  "CURRENT_YEAR": true,
  "CURRENT_YEAR_SHORT": true,
  "CURRENT_MONTH": true,
  "CURRENT_DATE": true,
  "CURRENT_HOUR": true,
  "CURRENT_MINUTE": true,
  "CURRENT_SECOND": true,
  "CURRENT_DAY_NAME": true,
  "CURRENT_DAY_NAME_SHORT": true,
  "CURRENT_MONTH_NAME": true,
  "CURRENT_MONTH_NAME_SHORT": true,
  "CURRENT_SECONDS_UNIX": true,
  "SELECTION": true,
  "CLIPBOARD": true,
  "TM_SELECTED_TEXT": true,
  "TM_CURRENT_LINE": true,
  "TM_CURRENT_WORD": true,
  "TM_LINE_INDEX": true,
  "TM_LINE_NUMBER": true,
  "TM_FILENAME": true,
  "TM_FILENAME_BASE": true,
  "TM_DIRECTORY": true,
  "TM_FILEPATH": true,
  "RELATIVE_FILEPATH": true,
  "BLOCK_COMMENT_START": true,
  "BLOCK_COMMENT_END": true,
  "LINE_COMMENT": true,
  "WORKSPACE_NAME": true,
  "WORKSPACE_FOLDER": true,
  "RANDOM": true,
  "RANDOM_HEX": true,
  "UUID": true
});

// ../cursorless-engine/src/snippets/snippet.ts
function transformSnippetVariables(parsedSnippet, placeholderName, substitutions) {
  let nextPlaceholderIndex = getMaxPlaceholderIndex(parsedSnippet) + 1;
  const placeholderIndexMap = {};
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Variable) {
      if (candidate.name === placeholderName) {
        candidate.name = "TM_SELECTED_TEXT";
      } else if (substitutions != null && Object.prototype.hasOwnProperty.call(substitutions, candidate.name)) {
        candidate.parent.replace(candidate, [
          new Text(substitutions[candidate.name])
        ]);
      } else if (!KnownSnippetVariableNames[candidate.name]) {
        let placeholderIndex;
        if (candidate.name in placeholderIndexMap) {
          placeholderIndex = placeholderIndexMap[candidate.name];
        } else {
          placeholderIndex = nextPlaceholderIndex++;
          placeholderIndexMap[candidate.name] = placeholderIndex;
        }
        const placeholder = new Placeholder(placeholderIndex);
        candidate.children.forEach((child) => placeholder.appendChild(child));
        candidate.parent.replace(candidate, [placeholder]);
      }
    } else if (candidate instanceof Placeholder) {
      if (candidate.index.toString() === placeholderName) {
        candidate.parent.replace(candidate, [new Variable("TM_SELECTED_TEXT")]);
      }
    }
    return true;
  });
}
function getMaxPlaceholderIndex(parsedSnippet) {
  let placeholderIndex = 0;
  parsedSnippet.walk((candidate) => {
    if (candidate instanceof Placeholder) {
      placeholderIndex = Math.max(placeholderIndex, candidate.index);
    }
    return true;
  });
  return placeholderIndex;
}
function findMatchingSnippetDefinitionStrict(modifierStageFactory, targets, definitions) {
  const definitionIndices = targets.map(
    (target) => findMatchingSnippetDefinitionForSingleTarget(
      modifierStageFactory,
      target,
      definitions
    )
  );
  const definitionIndex = definitionIndices[0];
  if (!definitionIndices.every((index) => index === definitionIndex)) {
    throw new Error("Multiple snippet definitions match the given context");
  }
  if (definitionIndex === -1) {
    throw new Error("Couldn't find matching snippet definition");
  }
  return definitions[definitionIndex];
}
function findMatchingSnippetDefinitionForSingleTarget(modifierStageFactory, target, definitions) {
  const languageId = target.editor.document.languageId;
  return definitions.findIndex(({ scope }) => {
    if (scope == null) {
      return true;
    }
    const { langIds, scopeTypes, excludeDescendantScopeTypes } = scope;
    if (langIds != null && !langIds.includes(languageId)) {
      return false;
    }
    if (scopeTypes != null) {
      const allScopeTypes = scopeTypes.concat(
        excludeDescendantScopeTypes ?? []
      );
      let matchingTarget = void 0;
      let matchingScopeType = void 0;
      for (const scopeTypeType of allScopeTypes) {
        try {
          let containingTarget = modifierStageFactory.create({
            type: "containingScope",
            scopeType: { type: scopeTypeType }
          }).run(target)[0];
          if (target.contentRange.isRangeEqual(containingTarget.contentRange)) {
            containingTarget = modifierStageFactory.create({
              type: "containingScope",
              scopeType: { type: scopeTypeType },
              ancestorIndex: 1
            }).run(target)[0];
          }
          if (matchingTarget == null || matchingTarget.contentRange.contains(containingTarget.contentRange)) {
            matchingTarget = containingTarget;
            matchingScopeType = scopeTypeType;
          }
        } catch (e) {
          continue;
        }
      }
      return matchingTarget != null && !(excludeDescendantScopeTypes ?? []).includes(matchingScopeType);
    }
    return true;
  });
}

// ../cursorless-engine/src/actions/InsertSnippet.ts
var InsertSnippet = class {
  constructor(rangeUpdater, snippets, actions2, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.snippets = snippets;
    this.actions = actions2;
    this.modifierStageFactory = modifierStageFactory;
    this.snippetParser = new SnippetParser();
    this.run = this.run.bind(this);
  }
  getFinalStages(snippetDescription) {
    const defaultScopeTypes = this.getScopeTypes(snippetDescription);
    return defaultScopeTypes.length === 0 ? [] : [
      new ModifyIfUntypedExplicitStage(this.modifierStageFactory, {
        type: "cascading",
        modifiers: defaultScopeTypes.map((scopeType) => ({
          type: "containingScope",
          scopeType
        }))
      })
    ];
  }
  getScopeTypes(snippetDescription) {
    if (snippetDescription.type === "named") {
      const { name } = snippetDescription;
      const snippet2 = this.snippets.getSnippetStrict(name);
      const scopeTypeTypes = snippet2.insertionScopeTypes;
      return scopeTypeTypes == null ? [] : scopeTypeTypes.map((scopeTypeType) => ({
        type: scopeTypeType
      }));
    } else {
      return snippetDescription.scopeTypes ?? [];
    }
  }
  getSnippetInfo(snippetDescription, targets) {
    if (snippetDescription.type === "named") {
      const { name } = snippetDescription;
      const snippet2 = this.snippets.getSnippetStrict(name);
      const definition = findMatchingSnippetDefinitionStrict(
        this.modifierStageFactory,
        targets,
        snippet2.definitions
      );
      return {
        body: definition.body.join("\n"),
        formatSubstitutions(substitutions) {
          return substitutions == null ? void 0 : formatSubstitutions(snippet2, definition, substitutions);
        }
      };
    } else {
      return {
        body: snippetDescription.body,
        formatSubstitutions(substitutions) {
          return substitutions;
        }
      };
    }
  }
  async run(destinations, snippetDescription) {
    const editor = ide().getEditableTextEditor(
      ensureSingleEditor2(destinations)
    );
    await this.actions.editNew.run(destinations);
    const targetSelectionInfos = editor.selections.map(
      (selection) => getSelectionInfo(
        editor.document,
        selection,
        0 /* openOpen */
      )
    );
    const { body, formatSubstitutions: formatSubstitutions2 } = this.getSnippetInfo(
      snippetDescription,
      // Use new selection locations instead of original targets because
      // that's where we'll be doing the snippet insertion
      editor.selections.map(
        (selection) => new UntypedTarget({
          editor,
          contentRange: selection,
          isReversed: false,
          hasExplicitRange: true
        })
      )
    );
    const parsedSnippet = this.snippetParser.parse(body);
    transformSnippetVariables(
      parsedSnippet,
      null,
      formatSubstitutions2(snippetDescription.substitutions)
    );
    const snippetString = parsedSnippet.toTextmateString();
    const [updatedTargetSelections] = await callFunctionAndUpdateSelectionInfos(
      this.rangeUpdater,
      () => editor.insertSnippet(snippetString),
      editor.document,
      [targetSelectionInfos]
    );
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};
function formatSubstitutions(snippet2, definition, substitutions) {
  return Object.fromEntries(
    Object.entries(substitutions).map(([variableName, value]) => {
      const formatterName = (definition.variables ?? {})[variableName]?.formatter ?? (snippet2.variables ?? {})[variableName]?.formatter;
      if (formatterName == null) {
        return [variableName, value];
      }
      const formatter = textFormatters[formatterName];
      if (formatter == null) {
        throw new Error(
          `Couldn't find formatter ${formatterName} for variable ${variableName}`
        );
      }
      return [variableName, formatter(value.split(" "))];
    })
  );
}

// ../cursorless-engine/src/actions/JoinLines.ts
var import_lodash45 = __toESM(require_lodash(), 1);
var JoinLines = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const thatSelections = (0, import_lodash45.flatten)(
      await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
        const contentRanges = targets2.map(({ contentRange }) => contentRange);
        const edits = getEdits2(editor, contentRanges);
        const [updatedRanges] = await performEditsAndUpdateRanges(
          this.rangeUpdater,
          ide().getEditableTextEditor(editor),
          edits,
          [contentRanges]
        );
        return (0, import_lodash45.zip)(targets2, updatedRanges).map(([target, range4]) => ({
          editor: target.editor,
          selection: range4.toSelection(target.isReversed)
        }));
      })
    );
    return { thatSelections };
  }
};
function getEdits2(editor, contentRanges) {
  const { document } = editor;
  const edits = [];
  for (const range4 of contentRanges) {
    const startLine = range4.start.line;
    const endLine = range4.isSingleLine ? startLine + 1 : range4.end.line;
    const lineIter = map2(
      range2(startLine, endLine + 1),
      (i) => document.lineAt(i)
    );
    for (const [line1, line2] of pairwise(lineIter)) {
      edits.push({
        range: new Range(
          line1.range.end.line,
          line1.lastNonWhitespaceCharacterIndex,
          line2.range.start.line,
          line2.firstNonWhitespaceCharacterIndex
        ),
        text: line2.isEmptyOrWhitespace ? "" : " ",
        isReplace: true
      });
    }
  }
  return edits;
}

// ../cursorless-engine/src/actions/PasteFromClipboard.ts
var PasteFromClipboard = class {
  constructor(rangeUpdater, actions2) {
    this.rangeUpdater = rangeUpdater;
    this.actions = actions2;
  }
  async run(destinations) {
    const editor = ide().getEditableTextEditor(
      ensureSingleEditor2(destinations)
    );
    const originalEditor = ide().activeEditableTextEditor;
    const [originalCursorSelections] = await callFunctionAndUpdateSelections(
      this.rangeUpdater,
      async () => {
        await this.actions.editNew.run(destinations);
      },
      editor.document,
      [editor.selections]
    );
    const [updatedCursorSelections, updatedTargetSelections] = await callFunctionAndUpdateSelectionsWithBehavior(
      this.rangeUpdater,
      () => editor.clipboardPaste(),
      editor.document,
      [
        {
          selections: originalCursorSelections
        },
        {
          selections: editor.selections,
          rangeBehavior: 0 /* openOpen */
        }
      ]
    );
    await setSelectionsWithoutFocusingEditor(editor, updatedCursorSelections);
    if (originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    await ide().flashRanges(
      updatedTargetSelections.map((selection) => ({
        editor,
        range: toCharacterRange(selection),
        style: "justAdded" /* justAdded */
      }))
    );
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/Remove.ts
var import_lodash46 = __toESM(require_lodash(), 1);
var Delete = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
    this.runForEditor = this.runForEditor.bind(this);
  }
  async run(targets, { showDecorations = true } = {}) {
    targets = unifyRemovalTargets(targets);
    if (showDecorations) {
      await flashTargets(
        ide(),
        targets,
        "pendingDelete" /* pendingDelete */,
        (target) => target.getRemovalHighlightRange()
      );
    }
    const thatTargets = (0, import_lodash46.flatten)(
      await runOnTargetsForEachEditor(targets, this.runForEditor)
    );
    return { thatTargets };
  }
  async runForEditor(editor, targets) {
    const edits = targets.map((target) => target.constructRemovalEdit());
    const cursorSelections = editor.selections;
    const editSelections = edits.map(({ range: range4 }) => range4.toSelection(false));
    const editableEditor = ide().getEditableTextEditor(editor);
    const [updatedCursorSelections, updatedEditSelections] = await performEditsAndUpdateSelections(
      this.rangeUpdater,
      editableEditor,
      edits,
      [cursorSelections, editSelections]
    );
    await setSelectionsWithoutFocusingEditor(
      editableEditor,
      updatedCursorSelections
    );
    return (0, import_lodash46.zip)(targets, updatedEditSelections).map(
      ([target, range4]) => new RawSelectionTarget({
        editor: target.editor,
        isReversed: target.isReversed,
        contentRange: range4
      })
    );
  }
};

// ../cursorless-engine/src/actions/Replace.ts
var import_lodash47 = __toESM(require_lodash(), 1);
var Replace = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  getTexts(destinations, replaceWith) {
    if (Array.isArray(replaceWith)) {
      if (replaceWith.length === 1) {
        return Array(destinations.length).fill(replaceWith[0]);
      }
      return replaceWith;
    }
    const numbers2 = [];
    for (let i = 0; i < destinations.length; ++i) {
      numbers2[i] = (replaceWith.start + i).toString();
    }
    return numbers2;
  }
  async run(destinations, replaceWith) {
    await flashTargets(
      ide(),
      destinations.map((d) => d.target),
      "pendingModification0" /* pendingModification0 */
    );
    const texts = this.getTexts(destinations, replaceWith);
    if (destinations.length !== texts.length) {
      throw new Error("Targets and texts must have same length");
    }
    const edits = (0, import_lodash47.zip)(destinations, texts).map(([destination, text]) => ({
      editor: destination.editor,
      target: destination.target,
      edit: destination.constructChangeEdit(text)
    }));
    const sourceTargets = [];
    const thatSelections = [];
    await runForEachEditor(
      edits,
      (edit) => edit.editor,
      async (editor, edits2) => {
        const contentSelections = {
          selections: edits2.map(({ target }) => target.contentSelection)
        };
        const editSelections = {
          selections: edits2.map(({ edit }) => edit.range.toSelection(false)),
          rangeBehavior: 0 /* openOpen */
        };
        const [updatedContentSelections, updatedEditSelections] = await performEditsAndUpdateSelectionsWithBehavior(
          this.rangeUpdater,
          ide().getEditableTextEditor(editor),
          edits2.map(({ edit }) => edit),
          [contentSelections, editSelections]
        );
        for (const [edit, selection] of (0, import_lodash47.zip)(edits2, updatedContentSelections)) {
          sourceTargets.push(edit.target.withContentRange(selection));
        }
        for (const [edit, selection] of (0, import_lodash47.zip)(edits2, updatedEditSelections)) {
          thatSelections.push({
            editor,
            selection: edit.edit.updateRange(selection).toSelection(selection.isReversed)
          });
        }
      }
    );
    return { sourceTargets, thatSelections };
  }
};

// ../cursorless-engine/src/actions/Rewrap.ts
var Rewrap = class {
  constructor(rangeUpdater, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.getFinalStages = () => [
      this.modifierStageFactory.create(
        containingSurroundingPairIfUntypedModifier
      )
    ];
    this.run = this.run.bind(this);
  }
  async run(targets, left, right) {
    const boundaryTargets = targets.flatMap((target) => {
      const boundary = target.getBoundaryStrict();
      if (boundary.length !== 2) {
        throw Error("Target must have an opening and closing delimiter");
      }
      return boundary;
    });
    await flashTargets(ide(), boundaryTargets, "pendingModification0" /* pendingModification0 */);
    const results = await runOnTargetsForEachEditor(
      boundaryTargets,
      async (editor, boundaryTargets2) => {
        const edits = boundaryTargets2.map((target, i) => ({
          editor,
          range: target.contentRange,
          text: i % 2 === 0 ? left : right
        }));
        const [updatedSourceRanges, updatedThatRanges] = await performEditsAndUpdateRanges(
          this.rangeUpdater,
          ide().getEditableTextEditor(editor),
          edits,
          [
            targets.map((target) => target.thatTarget.contentRange),
            targets.map((target) => target.contentRange)
          ]
        );
        return {
          sourceMark: createThatMark(targets, updatedSourceRanges),
          thatMark: createThatMark(targets, updatedThatRanges)
        };
      }
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
};

// ../cursorless-engine/src/actions/Scroll.ts
var Scroll = class {
  constructor(at) {
    this.at = at;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const selectionGroups = groupBy(targets, (t) => t.editor);
    const lines = Array.from(selectionGroups, ([editor, targets2]) => {
      return { lineNumber: getLineNumber(targets2, this.at), editor };
    });
    const originalEditor = ide().activeEditableTextEditor;
    for (const lineWithEditor of lines) {
      await ide().getEditableTextEditor(lineWithEditor.editor).revealLine(lineWithEditor.lineNumber, this.at);
    }
    if (originalEditor != null && !originalEditor.isActive) {
      await originalEditor.focus();
    }
    const decorationTargets = targets.filter((target) => {
      const visibleRanges = target.editor.visibleRanges;
      const startLine = visibleRanges[0].start.line;
      const endLine = visibleRanges[visibleRanges.length - 1].end.line;
      return target.contentRange.start.line > startLine || target.contentRange.end.line < endLine || target.contentRange.start.line === startLine && target.contentRange.end.line === endLine;
    });
    await ide().flashRanges(
      decorationTargets.map((target) => ({
        editor: target.editor,
        range: toLineRange(target.contentRange),
        style: "referenced" /* referenced */
      }))
    );
    return {
      thatTargets: targets
    };
  }
};
var ScrollToTop = class extends Scroll {
  constructor() {
    super("top" /* top */);
  }
};
var ScrollToCenter = class extends Scroll {
  constructor() {
    super("center" /* center */);
  }
};
var ScrollToBottom = class extends Scroll {
  constructor() {
    super("bottom" /* bottom */);
  }
};
function getLineNumber(targets, at) {
  let startLine = Number.MAX_SAFE_INTEGER;
  let endLine = 0;
  targets.forEach((target) => {
    startLine = Math.min(startLine, target.contentRange.start.line);
    endLine = Math.max(endLine, target.contentRange.end.line);
  });
  if (at === "top" /* top */) {
    return startLine;
  }
  if (at === "bottom" /* bottom */) {
    return endLine;
  }
  return Math.floor((startLine + endLine) / 2);
}

// ../cursorless-engine/src/actions/SetSelection.ts
var SetSelection = class {
  constructor() {
    this.run = this.run.bind(this);
  }
  getSelection(target) {
    return target.contentSelection;
  }
  async run(targets) {
    const editor = ensureSingleEditor2(targets);
    const selections = targets.map(this.getSelection);
    await setSelectionsAndFocusEditor(
      ide().getEditableTextEditor(editor),
      selections
    );
    return {
      thatTargets: targets
    };
  }
};
var SetSelectionBefore = class extends SetSelection {
  getSelection(target) {
    return new Selection(target.contentRange.start, target.contentRange.start);
  }
};
var SetSelectionAfter = class extends SetSelection {
  getSelection(target) {
    return new Selection(target.contentRange.end, target.contentRange.end);
  }
};

// ../cursorless-engine/src/actions/SetSpecialTarget.ts
var SetSpecialTarget = class {
  constructor(key) {
    this.key = key;
    this.noAutomaticTokenExpansion = true;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    return {
      thatTargets: targets,
      [`${this.key}Targets`]: targets
    };
  }
};

// ../cursorless-engine/src/actions/ShowParseTree.ts
var path4 = __toESM(require("node:path"), 1);
var ShowParseTree = class {
  constructor(treeSitter) {
    this.treeSitter = treeSitter;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    await flashTargets(ide(), targets, "referenced" /* referenced */);
    const results = ["# Cursorless parse tree"];
    for (const target of targets) {
      const { editor, contentRange } = target;
      const tree = this.treeSitter.getTree(editor.document);
      results.push(parseTree(editor.document, tree, contentRange));
    }
    ide().openUntitledTextDocument({
      language: "markdown",
      content: results.join("\n\n")
    });
    return { thatTargets: targets };
  }
};
function parseTree(document, tree, contentRange) {
  const resultPlayground = [];
  const resultQuery = [];
  parseCursor(resultPlayground, resultQuery, contentRange, tree.walk(), 0);
  return [
    `## ${path4.basename(document.uri.path)} [${contentRange}]
`,
    `\`\`\`${document.languageId}`,
    document.getText(contentRange),
    "```",
    "",
    "```scm",
    ...resultQuery,
    "```",
    "",
    "```js",
    ...resultPlayground,
    "```",
    ""
  ].join("\n");
}
function parseCursor(resultPlayground, resultQuery, contentRange, cursor, numIndents) {
  while (true) {
    const nodeRange = new Range(
      cursor.startPosition.row,
      cursor.startPosition.column,
      cursor.endPosition.row,
      cursor.endPosition.column
    );
    if (contentRange.intersection(nodeRange) != null) {
      const indentation = "  ".repeat(numIndents);
      const fieldName = getFieldName(cursor);
      const prefix = indentation + fieldName;
      if (cursor.nodeIsNamed) {
        resultPlayground.push(`${prefix}${cursor.nodeType} [${nodeRange}]`);
        resultQuery.push(`${prefix}(${cursor.nodeType}`);
        if (cursor.gotoFirstChild()) {
          parseCursor(
            resultPlayground,
            resultQuery,
            contentRange,
            cursor,
            numIndents + 1
          );
          cursor.gotoParent();
          resultQuery.push(`${indentation})`);
        } else {
          resultQuery[resultQuery.length - 1] += ")";
        }
      } else {
        const type2 = `"${cursor.nodeType}"`;
        resultPlayground.push(`${prefix}${type2} [${nodeRange}]`);
        resultQuery.push(`${prefix}${type2}`);
      }
    }
    if (!cursor.gotoNextSibling()) {
      return;
    }
  }
}
function getFieldName(cursor) {
  const field = cursor.currentFieldName();
  return field != null ? `${field}: ` : "";
}

// ../cursorless-engine/src/actions/SimpleIdeCommandActions.ts
var SimpleIdeCommandAction = class {
  constructor(rangeUpdater) {
    this.ensureSingleEditor = false;
    this.ensureSingleTarget = false;
    this.restoreSelection = true;
    this.showDecorations = true;
    this.callbackAction = new CallbackAction(rangeUpdater);
    this.run = this.run.bind(this);
  }
  async run(targets, { showDecorations } = {}) {
    const capabilities = ide().capabilities.commands[this.command];
    if (capabilities == null) {
      throw Error(`Action ${this.command} is not supported by your ide`);
    }
    const { acceptsLocation } = capabilities;
    return this.callbackAction.run(targets, {
      callback: (editor, targets2) => callback(
        editor,
        acceptsLocation ? targets2.map((t) => t.contentRange) : void 0,
        this.command
      ),
      setSelection: !acceptsLocation,
      ensureSingleEditor: this.ensureSingleEditor,
      ensureSingleTarget: this.ensureSingleTarget,
      restoreSelection: this.restoreSelection,
      showDecorations: showDecorations ?? this.showDecorations
    });
  }
};
var CopyToClipboard = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "clipboardCopy";
    this.ensureSingleEditor = true;
  }
};
var ToggleLineComment = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "toggleLineComment";
  }
};
var IndentLine = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "indentLine";
  }
};
var OutdentLine = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "outdentLine";
  }
};
var Fold = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "fold";
  }
};
var Unfold = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "unfold";
  }
};
var Rename = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "rename";
    this.ensureSingleTarget = true;
  }
};
var ShowReferences = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "showReferences";
    this.ensureSingleTarget = true;
  }
};
var ShowQuickFix = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "quickFix";
    this.ensureSingleTarget = true;
  }
};
var RevealDefinition = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "revealDefinition";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var RevealTypeDefinition = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "revealTypeDefinition";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var ShowHover = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "showHover";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var ShowDebugHover = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "showDebugHover";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
var ExtractVariable = class extends SimpleIdeCommandAction {
  constructor() {
    super(...arguments);
    this.command = "extractVariable";
    this.ensureSingleTarget = true;
    this.restoreSelection = false;
  }
};
function callback(editor, ranges, command) {
  switch (command) {
    case "toggleLineComment":
      return editor.toggleLineComment(ranges);
    case "indentLine":
      return editor.indentLine(ranges);
    case "outdentLine":
      return editor.outdentLine(ranges);
    case "clipboardCopy":
      return editor.clipboardCopy(ranges);
    case "fold":
      return editor.fold(ranges);
    case "unfold":
      return editor.unfold(ranges);
    case "rename":
      return editor.rename(ranges?.[0]);
    case "showReferences":
      return editor.showReferences(ranges?.[0]);
    case "quickFix":
      return editor.quickFix(ranges?.[0]);
    case "revealDefinition":
      return editor.revealDefinition(ranges?.[0]);
    case "revealTypeDefinition":
      return editor.revealTypeDefinition(ranges?.[0]);
    case "showHover":
      return editor.showHover(ranges?.[0]);
    case "showDebugHover":
      return editor.showDebugHover(ranges?.[0]);
    case "extractVariable":
      return editor.extractVariable(ranges?.[0]);
    case "highlight":
      throw Error("Highlight command not supported as simple action");
  }
}

// ../cursorless-engine/src/actions/Sort.ts
var import_lodash48 = __toESM(require_lodash(), 1);
var SortBase = class {
  constructor(actions2) {
    this.actions = actions2;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    if (targets.length < 2) {
      showWarning(
        ide().messages,
        "tooFewTargets",
        'This action works on multiple targets, e.g. "sort every line block" instead of "sort block".'
      );
    }
    const sortedTargets = targets.slice().sort((a, b) => a.contentRange.start.compareTo(b.contentRange.start));
    const { returnValue: unsortedTexts } = await this.actions.getText.run(
      sortedTargets,
      {
        showDecorations: false
      }
    );
    const sortedTexts = this.sortTexts(unsortedTexts);
    const { thatSelections } = await this.actions.replace.run(
      sortedTargets.map((target) => target.toDestination("to")),
      sortedTexts
    );
    return { thatSelections };
  }
};
var Sort = class extends SortBase {
  constructor() {
    super(...arguments);
    this.collator = new Intl.Collator(void 0, {
      numeric: true,
      caseFirst: "upper"
    });
  }
  sortTexts(texts) {
    return texts.sort(this.collator.compare);
  }
};
var Reverse = class extends SortBase {
  sortTexts(texts) {
    return texts.reverse();
  }
};
var Random = class extends SortBase {
  sortTexts(texts) {
    return (0, import_lodash48.shuffle)(texts);
  }
};

// ../cursorless-engine/src/actions/ToggleBreakpoint.ts
var ToggleBreakpoint = class {
  constructor(modifierStageFactory) {
    this.modifierStageFactory = modifierStageFactory;
    this.getFinalStages = () => [
      this.modifierStageFactory.create(containingLineIfUntypedModifier)
    ];
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const thatTargets = targets.map(({ thatTarget }) => thatTarget);
    await flashTargets(ide(), thatTargets, "referenced" /* referenced */);
    await runOnTargetsForEachEditor(targets, async (editor, targets2) => {
      const breakpointDescriptors = targets2.map(
        (target) => {
          const range4 = target.contentRange;
          return target.isLine ? {
            type: "line",
            startLine: range4.start.line,
            endLine: range4.end.line
          } : {
            type: "inline",
            range: range4
          };
        }
      );
      await ide().getEditableTextEditor(editor).toggleBreakpoint(breakpointDescriptors);
    });
    return {
      thatTargets: targets
    };
  }
};

// ../cursorless-engine/src/actions/Wrap.ts
var Wrap = class {
  constructor(rangeUpdater) {
    this.rangeUpdater = rangeUpdater;
    this.run = this.run.bind(this);
  }
  async run(targets, left, right) {
    const results = await runOnTargetsForEachEditor(
      targets,
      async (editor, targets2) => {
        const { document } = editor;
        const boundaries = targets2.map((target) => ({
          start: new Selection(
            target.contentRange.start,
            target.contentRange.start
          ),
          end: new Selection(target.contentRange.end, target.contentRange.end)
        }));
        const edits = boundaries.flatMap(({ start, end }) => [
          {
            text: left,
            range: start
          },
          {
            text: right,
            range: end,
            isReplace: true
          }
        ]);
        const delimiterSelectionInfos = boundaries.flatMap(
          ({ start, end }) => {
            return [
              getSelectionInfo(
                document,
                start,
                2 /* openClosed */
              ),
              getSelectionInfo(
                document,
                end,
                3 /* closedOpen */
              )
            ];
          }
        );
        const cursorSelectionInfos = editor.selections.map(
          (selection) => getSelectionInfo(
            document,
            selection,
            1 /* closedClosed */
          )
        );
        const sourceMarkSelectionInfos = targets2.map(
          (target) => getSelectionInfo(
            document,
            target.contentSelection,
            1 /* closedClosed */
          )
        );
        const thatMarkSelectionInfos = targets2.map(
          (target) => getSelectionInfo(
            document,
            target.contentSelection,
            0 /* openOpen */
          )
        );
        const editableEditor = ide().getEditableTextEditor(editor);
        const [
          delimiterSelections,
          cursorSelections,
          sourceMarkSelections,
          thatMarkSelections
        ] = await performEditsAndUpdateFullSelectionInfos(
          this.rangeUpdater,
          editableEditor,
          edits,
          [
            delimiterSelectionInfos,
            cursorSelectionInfos,
            sourceMarkSelectionInfos,
            thatMarkSelectionInfos
          ]
        );
        await setSelectionsWithoutFocusingEditor(
          editableEditor,
          cursorSelections
        );
        await ide().flashRanges(
          delimiterSelections.map((selection) => ({
            editor,
            range: toCharacterRange(selection),
            style: "justAdded" /* justAdded */
          }))
        );
        return {
          sourceMark: sourceMarkSelections.map((selection) => ({
            editor,
            selection
          })),
          thatMark: thatMarkSelections.map((selection) => ({
            editor,
            selection
          }))
        };
      }
    );
    return {
      sourceSelections: results.flatMap(({ sourceMark }) => sourceMark),
      thatSelections: results.flatMap(({ thatMark }) => thatMark)
    };
  }
};

// ../cursorless-engine/src/actions/WrapWithSnippet.ts
var WrapWithSnippet = class {
  constructor(rangeUpdater, snippets, modifierStageFactory) {
    this.rangeUpdater = rangeUpdater;
    this.snippets = snippets;
    this.modifierStageFactory = modifierStageFactory;
    this.snippetParser = new SnippetParser();
    this.run = this.run.bind(this);
  }
  getFinalStages(snippet2) {
    const defaultScopeType = this.getScopeType(snippet2);
    if (defaultScopeType == null) {
      return [];
    }
    return [
      new ModifyIfUntypedStage(this.modifierStageFactory, {
        type: "modifyIfUntyped",
        modifier: {
          type: "containingScope",
          scopeType: defaultScopeType
        }
      })
    ];
  }
  getScopeType(snippetDescription) {
    if (snippetDescription.type === "named") {
      const { name, variableName } = snippetDescription;
      const snippet2 = this.snippets.getSnippetStrict(name);
      const variables = snippet2.variables ?? {};
      const scopeTypeType = variables[variableName]?.wrapperScopeType;
      return scopeTypeType == null ? void 0 : {
        type: scopeTypeType
      };
    } else {
      return snippetDescription.scopeType;
    }
  }
  getBody(snippetDescription, targets) {
    if (snippetDescription.type === "named") {
      const { name } = snippetDescription;
      const snippet2 = this.snippets.getSnippetStrict(name);
      const definition = findMatchingSnippetDefinitionStrict(
        this.modifierStageFactory,
        targets,
        snippet2.definitions
      );
      return definition.body.join("\n");
    } else {
      return snippetDescription.body;
    }
  }
  async run(targets, snippetDescription) {
    const editor = ide().getEditableTextEditor(ensureSingleEditor2(targets));
    const body = this.getBody(snippetDescription, targets);
    const parsedSnippet = this.snippetParser.parse(body);
    transformSnippetVariables(parsedSnippet, snippetDescription.variableName);
    const snippetString = parsedSnippet.toTextmateString();
    await flashTargets(ide(), targets, "pendingModification0" /* pendingModification0 */);
    const targetSelections = targets.map((target) => target.contentSelection);
    const [updatedTargetSelections] = await callFunctionAndUpdateSelections(
      this.rangeUpdater,
      () => editor.insertSnippet(snippetString, targetSelections),
      editor.document,
      [targetSelections]
    );
    return {
      thatSelections: updatedTargetSelections.map((selection) => ({
        editor,
        selection
      }))
    };
  }
};

// ../cursorless-engine/src/actions/incrementDecrement.ts
var REGEX = /-?\d+(\.\d+)?/g;
var IncrementDecrement = class {
  constructor(actions2, isIncrement) {
    this.actions = actions2;
    this.isIncrement = isIncrement;
    this.run = this.run.bind(this);
  }
  async run(targets) {
    const thatSelections = [];
    await runForEachEditor(
      targets,
      (target) => target.editor,
      async (editor, targets2) => {
        const selections = await this.runOnEditor(editor, targets2);
        thatSelections.push(...selections);
      }
    );
    return { thatSelections };
  }
  async runOnEditor(editor, targets) {
    const { document } = editor;
    const destinations = [];
    const replaceWith = [];
    for (const target of targets) {
      const offset = document.offsetAt(target.contentRange.start);
      const text = target.contentText;
      const matches = matchText(text, REGEX);
      for (const match2 of matches) {
        destinations.push(createDestination(editor, offset, match2));
        replaceWith.push(updateNumber(this.isIncrement, match2.text));
      }
    }
    const { thatSelections } = await this.actions.replace.run(
      destinations,
      replaceWith
    );
    return thatSelections;
  }
};
var Increment = class extends IncrementDecrement {
  constructor(actions2) {
    super(actions2, true);
  }
};
var Decrement = class extends IncrementDecrement {
  constructor(actions2) {
    super(actions2, false);
  }
};
function createDestination(editor, offset, match2) {
  const target = new PlainTarget({
    editor,
    isReversed: false,
    contentRange: new Range(
      editor.document.positionAt(offset + match2.index),
      editor.document.positionAt(offset + match2.index + match2.text.length)
    )
  });
  return target.toDestination("to");
}
function updateNumber(isIncrement, text) {
  return text.includes(".") ? updateFloat(isIncrement, text).toString() : updateInteger(isIncrement, text).toString();
}
function updateInteger(isIncrement, text) {
  const original = parseInt(text);
  const diff = 1;
  return original + (isIncrement ? diff : -diff);
}
function updateFloat(isIncrement, text) {
  const original = parseFloat(text);
  const isPercentage = Math.abs(original) <= 1;
  const diff = isPercentage ? 0.1 : 1;
  const updated = original + (isIncrement ? diff : -diff);
  return parseFloat(updated.toPrecision(15)) / 1;
}

// ../cursorless-engine/src/actions/Actions.ts
var Actions = class {
  constructor(treeSitter, snippets, rangeUpdater, modifierStageFactory) {
    this.treeSitter = treeSitter;
    this.snippets = snippets;
    this.rangeUpdater = rangeUpdater;
    this.modifierStageFactory = modifierStageFactory;
    this.callAsFunction = new Call(this);
    this.clearAndSetSelection = new Clear(this);
    this.copyToClipboard = new CopyToClipboard(this.rangeUpdater);
    this.cutToClipboard = new CutToClipboard(this);
    this.decrement = new Decrement(this);
    this.deselect = new Deselect();
    this.editNew = new EditNew(this.rangeUpdater, this);
    this.editNewLineAfter = new EditNewAfter(
      this,
      this.modifierStageFactory
    );
    this.editNewLineBefore = new EditNewBefore(
      this,
      this.modifierStageFactory
    );
    this.executeCommand = new ExecuteCommand(this.rangeUpdater);
    this.extractVariable = new ExtractVariable(this.rangeUpdater);
    this.findInDocument = new FindInDocument(this);
    this.findInWorkspace = new FindInWorkspace(this);
    this.foldRegion = new Fold(this.rangeUpdater);
    this.followLink = new FollowLink(this);
    this.generateSnippet = new GenerateSnippet();
    this.getText = new GetText();
    this.highlight = new Highlight();
    this.increment = new Increment(this);
    this.indentLine = new IndentLine(this.rangeUpdater);
    this.insertCopyAfter = new CopyContentAfter(
      this.rangeUpdater,
      this.modifierStageFactory
    );
    this.insertCopyBefore = new CopyContentBefore(
      this.rangeUpdater,
      this.modifierStageFactory
    );
    this.insertEmptyLineAfter = new InsertEmptyLineBelow(this.rangeUpdater);
    this.insertEmptyLineBefore = new InsertEmptyLineAbove(this.rangeUpdater);
    this.insertEmptyLinesAround = new InsertEmptyLinesAround(this.rangeUpdater);
    this.insertSnippet = new InsertSnippet(
      this.rangeUpdater,
      this.snippets,
      this,
      this.modifierStageFactory
    );
    this.joinLines = new JoinLines(this.rangeUpdater);
    this.breakLine = new BreakLine(this.rangeUpdater);
    this.moveToTarget = new Move(this.rangeUpdater);
    this.outdentLine = new OutdentLine(this.rangeUpdater);
    this.pasteFromClipboard = new PasteFromClipboard(this.rangeUpdater, this);
    this.randomizeTargets = new Random(this);
    this.remove = new Delete(this.rangeUpdater);
    this.rename = new Rename(this.rangeUpdater);
    this.replace = new Replace(this.rangeUpdater);
    this.replaceWithTarget = new Bring(this.rangeUpdater);
    this.revealDefinition = new RevealDefinition(this.rangeUpdater);
    this.revealTypeDefinition = new RevealTypeDefinition(this.rangeUpdater);
    this.reverseTargets = new Reverse(this);
    this.rewrapWithPairedDelimiter = new Rewrap(
      this.rangeUpdater,
      this.modifierStageFactory
    );
    this.scrollToBottom = new ScrollToBottom();
    this.scrollToCenter = new ScrollToCenter();
    this.scrollToTop = new ScrollToTop();
    this["private.setKeyboardTarget"] = new SetSpecialTarget("keyboard");
    this["experimental.setInstanceReference"] = new SetSpecialTarget(
      "instanceReference"
    );
    this.setSelection = new SetSelection();
    this.setSelectionAfter = new SetSelectionAfter();
    this.setSelectionBefore = new SetSelectionBefore();
    this.showDebugHover = new ShowDebugHover(this.rangeUpdater);
    this.showHover = new ShowHover(this.rangeUpdater);
    this.showQuickFix = new ShowQuickFix(this.rangeUpdater);
    this.showReferences = new ShowReferences(this.rangeUpdater);
    this.sortTargets = new Sort(this);
    this.swapTargets = new Swap(this.rangeUpdater);
    this.toggleLineBreakpoint = new ToggleBreakpoint(this.modifierStageFactory);
    this.toggleLineComment = new ToggleLineComment(this.rangeUpdater);
    this.unfoldRegion = new Unfold(this.rangeUpdater);
    this.wrapWithPairedDelimiter = new Wrap(this.rangeUpdater);
    this.wrapWithSnippet = new WrapWithSnippet(
      this.rangeUpdater,
      this.snippets,
      this.modifierStageFactory
    );
    this["private.showParseTree"] = new ShowParseTree(this.treeSitter);
    this["private.getTargets"] = new GetTargets();
  }
};

// ../cursorless-engine/src/core/getCommandFallback.ts
async function getCommandFallback(commandServerApi, runAction, command) {
  const focusedElementType = await commandServerApi?.getFocusedElementType();
  if (focusedElementType == null || focusedElementType === "textEditor") {
    return null;
  }
  const action = command.action;
  switch (action.name) {
    case "replace":
      return destinationIsSelection(action.destination) && Array.isArray(action.replaceWith) ? {
        action: "insert",
        modifiers: getModifiersFromDestination(action.destination),
        text: action.replaceWith.join("\n")
      } : null;
    case "replaceWithTarget":
      if (destinationIsSelection(action.destination)) {
        return {
          action: "insert",
          modifiers: getModifiersFromDestination(action.destination),
          text: await getText(runAction, action.source)
        };
      }
      return null;
    case "moveToTarget":
      if (destinationIsSelection(action.destination)) {
        const text = await getText(runAction, action.source);
        await remove(runAction, action.source);
        return {
          action: "insert",
          modifiers: getModifiersFromDestination(action.destination),
          text
        };
      }
      return null;
    case "callAsFunction":
      if (targetIsSelection(action.argument)) {
        return {
          action: action.name,
          modifiers: getModifiersFromTarget(action.argument),
          callee: await getText(runAction, action.callee)
        };
      }
      return null;
    case "wrapWithPairedDelimiter":
    case "rewrapWithPairedDelimiter":
      return targetIsSelection(action.target) ? {
        action: action.name,
        modifiers: getModifiersFromTarget(action.target),
        left: action.left,
        right: action.right
      } : null;
    case "pasteFromClipboard":
      return destinationIsSelection(action.destination) ? {
        action: action.name,
        modifiers: getModifiersFromDestination(action.destination)
      } : null;
    case "swapTargets":
    case "editNew":
    case "insertSnippet":
    case "generateSnippet":
    case "wrapWithSnippet":
      return null;
    default:
      return targetIsSelection(action.target) ? {
        action: action.name,
        modifiers: getModifiersFromTarget(action.target)
      } : null;
  }
}
function destinationIsSelection(destination) {
  if (destination.type === "implicit") {
    return true;
  }
  if (destination.type === "primitive") {
    return destination.insertionMode === "to" && targetIsSelection(destination.target);
  }
  return false;
}
function targetIsSelection(target) {
  if (target.type === "implicit") {
    return true;
  }
  if (target.type === "primitive") {
    return target.mark == null || target.mark.type === "cursor";
  }
  return false;
}
function getModifiersFromDestination(destination) {
  if (destination.type === "primitive") {
    return getModifiersFromTarget(destination.target);
  }
  return [];
}
function getModifiersFromTarget(target) {
  if (target.type === "primitive") {
    if (target.modifiers != null && target.modifiers.length > 0) {
      return target.modifiers;
    }
    if (target.mark?.type === "cursor") {
      return [{ type: "containingTokenIfEmpty" }];
    }
  }
  return [];
}
async function getText(runAction, target) {
  const response = await runAction({ name: "getText", target });
  const texts = response.returnValue;
  return texts.join("\n");
}
async function remove(runAction, target) {
  await runAction({ name: "remove", target });
}

// ../cursorless-engine/src/core/handleHoistedModifiers.ts
var import_lodash49 = __toESM(require_lodash(), 1);
function handleHoistedModifiers(targetDescriptor, isAnchorMarkImplicit) {
  const { anchor, rangeType, active } = targetDescriptor;
  if (anchor.type !== "primitive" || rangeType !== "continuous") {
    return targetDescriptor;
  }
  const indexedModifiers = anchor.modifiers.map((v, i) => [v, i]);
  for (const [modifier, idx] of indexedModifiers.reverse()) {
    for (const hoistedModifierType of hoistedModifierTypes) {
      const acceptanceInfo = hoistedModifierType.accept(modifier);
      if (acceptanceInfo.accepted) {
        const [hoistedModifiers, unhoistedModifiers] = [
          anchor.modifiers.slice(0, idx + 1),
          anchor.modifiers.slice(idx + 1)
        ];
        let pipelineInputDescriptor = {
          ...targetDescriptor,
          anchor: (
            // If they say "every line past bat", the anchor is implicit, even though
            // it comes across the wire as a primitive target due to the "every line",
            // which we've now removed
            unhoistedModifiers.length === 0 && isAnchorMarkImplicit ? { type: "implicit" } : {
              type: "primitive",
              mark: anchor.mark,
              modifiers: unhoistedModifiers
            }
          ),
          // Remove the hoisted modifier (and everything before it) from the
          // active if it ended up there from inference
          active: produce(active, (draft) => {
            draft.modifiers = draft.modifiers.slice(
              (0, import_lodash49.findLastIndex)(
                draft.modifiers,
                (modifier2) => hoistedModifierType.accept(modifier2).accepted
              ) + 1
            );
          })
        };
        pipelineInputDescriptor = acceptanceInfo.transformTarget?.(pipelineInputDescriptor) ?? pipelineInputDescriptor;
        return {
          type: "primitive",
          mark: {
            type: "target",
            target: pipelineInputDescriptor
          },
          modifiers: hoistedModifiers
        };
      }
    }
  }
  return targetDescriptor;
}
var hoistedModifierTypes = [
  // "every" ranges, eg "every line air past bat"
  {
    accept(modifier) {
      return modifier.type === "everyScope" && modifier.scopeType.type !== "instance" ? {
        accepted: true,
        transformTarget(target) {
          return {
            ...target,
            exclusionScopeType: modifier.scopeType
          };
        }
      } : { accepted: false };
    }
  },
  // "instance" modifiers treat the range as the instance to search for, eg
  // "every instance air past bat" searches for instances of the text of the
  // range "air past bat".
  {
    accept(modifier) {
      return {
        accepted: (modifier.type === "everyScope" || modifier.type === "relativeScope" || modifier.type === "ordinalScope") && modifier.scopeType.type === "instance"
      };
    }
  }
];

// ../cursorless-engine/src/core/inferFullTargetDescriptor.ts
function inferFullTargetDescriptor(target, previousTargets) {
  switch (target.type) {
    case "list":
      return inferListTarget(target, previousTargets);
    case "range":
      return inferRangeTargetWithHoist(target, previousTargets);
    case "primitive":
      return inferPrimitiveTarget(target, previousTargets);
    case "implicit":
      return target;
  }
}
function inferListTarget(target, previousTargets) {
  return {
    ...target,
    elements: target.elements.map((element, index) => {
      const elementPreviousTargets = previousTargets.concat(
        target.elements.slice(0, index)
      );
      switch (element.type) {
        case "range":
          return inferRangeTargetWithHoist(element, elementPreviousTargets);
        case "primitive":
          return inferPrimitiveTarget(element, elementPreviousTargets);
      }
    })
  };
}
function inferRangeTargetWithHoist(target, previousTargets) {
  const fullTarget = inferRangeTarget(target, previousTargets);
  const isAnchorMarkImplicit = target.anchor.type === "implicit" || target.anchor.mark == null;
  return handleHoistedModifiers(fullTarget, isAnchorMarkImplicit);
}
function inferRangeTarget(target, previousTargets) {
  return {
    type: "range",
    rangeType: target.rangeType ?? "continuous",
    excludeAnchor: target.excludeAnchor ?? false,
    excludeActive: target.excludeActive ?? false,
    anchor: target.anchor.type === "implicit" ? target.anchor : inferPrimitiveTarget(target.anchor, previousTargets),
    active: inferPrimitiveTarget(
      target.active,
      previousTargets.concat(target.anchor)
    )
  };
}
function inferPrimitiveTarget(target, previousTargets) {
  const mark = target.mark ?? (shouldInferPreviousMark(target) ? getPreviousMark(previousTargets) : null) ?? {
    type: "cursor"
  };
  const modifiers = getPreservedModifiers(target) ?? getPreviousPreservedModifiers(previousTargets) ?? getPreviousLineNumberMarkModifiers(previousTargets) ?? [];
  return {
    type: target.type,
    mark,
    modifiers
  };
}
function shouldInferPreviousMark(target) {
  return target.modifiers?.some((m) => m.type === "inferPreviousMark") ?? false;
}
function getPreservedModifiers(target) {
  const preservedModifiers = target.modifiers?.filter(
    (modifier) => modifier.type !== "inferPreviousMark"
  ) ?? [];
  return preservedModifiers.length !== 0 ? preservedModifiers : void 0;
}
function getLineNumberMarkModifiers(target) {
  if (isLineNumberMark(target)) {
    return [
      {
        type: "containingScope",
        scopeType: {
          type: "line"
        }
      }
    ];
  }
  return void 0;
}
function isLineNumberMark(target) {
  const isLineNumber = (mark) => mark?.type === "lineNumber";
  if (isLineNumber(target.mark)) {
    return true;
  }
  if (target.mark?.type === "range") {
    return isLineNumber(target.mark.anchor) && isLineNumber(target.mark.active);
  }
  return false;
}
function getPreviousMark(previousTargets) {
  return getPreviousTargetAttribute(
    previousTargets,
    (target) => target.mark
  );
}
function getPreviousPreservedModifiers(previousTargets) {
  return getPreviousTargetAttribute(previousTargets, getPreservedModifiers);
}
function getPreviousLineNumberMarkModifiers(previousTargets) {
  return getPreviousTargetAttribute(
    previousTargets,
    getLineNumberMarkModifiers
  );
}
function getPreviousTargetAttribute(previousTargets, getAttribute) {
  for (let i = previousTargets.length - 1; i > -1; --i) {
    const target = previousTargets[i];
    switch (target.type) {
      case "primitive": {
        const attributeValue = getAttribute(target);
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
      case "range": {
        const attributeValue = getPreviousTargetAttribute(
          [target.anchor],
          getAttribute
        );
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
      case "list": {
        const attributeValue = getPreviousTargetAttribute(
          target.elements,
          getAttribute
        );
        if (attributeValue != null) {
          return attributeValue;
        }
        break;
      }
    }
  }
  return void 0;
}

// ../cursorless-engine/src/core/commandRunner/CommandRunnerImpl.ts
var CommandRunnerImpl = class {
  constructor(commandServerApi, debug, storedTargets, pipelineRunner, actions2) {
    this.commandServerApi = commandServerApi;
    this.debug = debug;
    this.storedTargets = storedTargets;
    this.pipelineRunner = pipelineRunner;
    this.actions = actions2;
    this.finalStages = [];
    this.runAction = this.runAction.bind(this);
    this.inferenceContext = new InferenceContext(this.debug);
  }
  /**
   * Runs a Cursorless command. We proceed as follows:
   *
   * 1. Perform inference on targets to fill in details left out using things
   *    like previous targets. For example we would automatically infer that
   *    `"take funk air and bat"` is equivalent to `"take funk air and funk
   *    bat"`. See {@link inferFullTargetDescriptors} for details of how this is done.
   * 2. Call {@link processTargets} to map each abstract {@link Target} object
   *    to a concrete list of {@link Target} objects.
   * 3. Run the requested action on the given selections. The mapping from
   *    action id (eg `remove`) to implementation is defined in {@link Actions}.
   *    To understand how actions work, see some examples, such as `"take"`
   *    {@link SetSelection} and `"chuck"` {@link Delete}. See
   * 4. Update `source` and `that` marks, if they have been returned from the
   *    action, and returns the desired return value indicated by the action, if
   *    it has one.
   */
  async run(command) {
    if (clientSupportsFallback(command)) {
      const fallback = await getCommandFallback(
        this.commandServerApi,
        this.runAction,
        command
      );
      if (fallback != null) {
        return { fallback };
      }
    }
    const {
      returnValue,
      thatSelections: newThatSelections,
      thatTargets: newThatTargets,
      sourceSelections: newSourceSelections,
      sourceTargets: newSourceTargets,
      instanceReferenceTargets: newInstanceReferenceTargets,
      keyboardTargets: newKeyboardTargets
    } = await this.runAction(command.action);
    this.storedTargets.set(
      "that",
      constructStoredTarget(newThatTargets, newThatSelections)
    );
    this.storedTargets.set(
      "source",
      constructStoredTarget(newSourceTargets, newSourceSelections)
    );
    this.storedTargets.set("instanceReference", newInstanceReferenceTargets);
    this.storedTargets.set("keyboard", newKeyboardTargets);
    return { returnValue };
  }
  runAction(actionDescriptor) {
    this.inferenceContext.reset();
    this.finalStages = [];
    switch (actionDescriptor.name) {
      case "replaceWithTarget":
        return this.actions.replaceWithTarget.run(
          this.getTargets(actionDescriptor.source),
          this.getDestinations(actionDescriptor.destination)
        );
      case "moveToTarget":
        return this.actions.moveToTarget.run(
          this.getTargets(actionDescriptor.source),
          this.getDestinations(actionDescriptor.destination)
        );
      case "swapTargets":
        return this.actions.swapTargets.run(
          this.getTargets(actionDescriptor.target1),
          this.getTargets(actionDescriptor.target2)
        );
      case "callAsFunction":
        return this.actions.callAsFunction.run(
          this.getTargets(actionDescriptor.callee),
          this.getTargets(actionDescriptor.argument)
        );
      case "wrapWithPairedDelimiter":
        return this.actions.wrapWithPairedDelimiter.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.left,
          actionDescriptor.right
        );
      case "rewrapWithPairedDelimiter":
        this.finalStages = this.actions.rewrapWithPairedDelimiter.getFinalStages();
        return this.actions.rewrapWithPairedDelimiter.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.left,
          actionDescriptor.right
        );
      case "pasteFromClipboard":
        return this.actions.pasteFromClipboard.run(
          this.getDestinations(actionDescriptor.destination)
        );
      case "executeCommand":
        return this.actions.executeCommand.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.commandId,
          actionDescriptor.options
        );
      case "replace":
        return this.actions.replace.run(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.replaceWith
        );
      case "highlight":
        return this.actions.highlight.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.highlightId
        );
      case "generateSnippet":
        return this.actions.generateSnippet.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.snippetName
        );
      case "insertSnippet":
        this.finalStages = this.actions.insertSnippet.getFinalStages(
          actionDescriptor.snippetDescription
        );
        return this.actions.insertSnippet.run(
          this.getDestinations(actionDescriptor.destination),
          actionDescriptor.snippetDescription
        );
      case "wrapWithSnippet":
        this.finalStages = this.actions.wrapWithSnippet.getFinalStages(
          actionDescriptor.snippetDescription
        );
        return this.actions.wrapWithSnippet.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.snippetDescription
        );
      case "editNew":
        return this.actions.editNew.run(
          this.getDestinations(actionDescriptor.destination)
        );
      case "getText":
        return this.actions.getText.run(
          this.getTargets(actionDescriptor.target),
          actionDescriptor.options
        );
      default: {
        const action = this.actions[actionDescriptor.name];
        this.finalStages = action.getFinalStages?.() ?? [];
        this.noAutomaticTokenExpansion = action.noAutomaticTokenExpansion ?? false;
        return action.run(this.getTargets(actionDescriptor.target));
      }
    }
  }
  getTargets(partialTargetsDescriptor) {
    const targetDescriptor = this.inferenceContext.run(
      partialTargetsDescriptor
    );
    return this.pipelineRunner.run(targetDescriptor, {
      actionFinalStages: this.finalStages,
      noAutomaticTokenExpansion: this.noAutomaticTokenExpansion
    });
  }
  getDestinations(destinationDescriptor) {
    switch (destinationDescriptor.type) {
      case "list":
        return destinationDescriptor.destinations.flatMap(
          (destination) => this.getDestinations(destination)
        );
      case "primitive":
        return this.getTargets(destinationDescriptor.target).map(
          (target) => target.toDestination(destinationDescriptor.insertionMode)
        );
      case "implicit":
        return this.getTargets({ type: "implicit" }).map(
          (target) => target.toDestination("to")
        );
    }
  }
};
var InferenceContext = class {
  constructor(debug) {
    this.debug = debug;
    this.previousTargets = [];
  }
  run(target) {
    const ret = inferFullTargetDescriptor(target, this.previousTargets);
    if (this.debug.active) {
      this.debug.log("Full target:");
      this.debug.log(JSON.stringify(ret, null, 2));
    }
    this.previousTargets.push(target);
    return ret;
  }
  reset() {
    this.previousTargets = [];
  }
};
function constructStoredTarget(targets, selections) {
  if (targets != null && selections != null) {
    throw Error(
      "Actions may only return full targets or selections for that mark"
    );
  }
  if (selections != null) {
    return selections.map(selectionToStoredTarget);
  } else {
    return targets;
  }
}

// ../cursorless-engine/src/util/getPrimitiveTargets.ts
function getPartialPrimitiveTargets(targets) {
  return targets.flatMap(getPartialPrimitiveTargetsHelper);
}
function getPartialPrimitiveTargetsHelper(target) {
  switch (target.type) {
    case "primitive":
      return [target];
    case "list":
      return target.elements.flatMap(getPartialPrimitiveTargetsHelper);
    case "range":
      return [target.anchor, target.active].flatMap(
        getPartialPrimitiveTargetsHelper
      );
    case "implicit":
      return [];
  }
}

// ../cursorless-engine/src/core/commandVersionUpgrades/canonicalizeTargetsInPlace.ts
var SCOPE_TYPE_CANONICALIZATION_MAPPING = {
  arrowFunction: "anonymousFunction",
  dictionary: "map",
  regex: "regularExpression"
};
var COLOR_CANONICALIZATION_MAPPING = {
  purple: "pink"
};
function canonicalizeScopeTypesInPlace(target) {
  target.modifiers?.forEach((mod) => {
    if (mod.type === "containingScope" || mod.type === "everyScope") {
      mod.scopeType.type = SCOPE_TYPE_CANONICALIZATION_MAPPING[mod.scopeType.type] ?? mod.scopeType.type;
    }
  });
}
function canonicalizeColorsInPlace(target) {
  if (target.mark?.type === "decoratedSymbol") {
    target.mark.symbolColor = COLOR_CANONICALIZATION_MAPPING[target.mark.symbolColor] ?? target.mark.symbolColor;
  }
}
function canonicalizeTargetsInPlace(partialTargets) {
  getPartialPrimitiveTargets(partialTargets).forEach((target) => {
    canonicalizeScopeTypesInPlace(target);
    canonicalizeColorsInPlace(target);
  });
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV0ToV1/upgradeV0ToV1.ts
function upgradeV0ToV1(command) {
  return { ...command, version: 1 };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV1ToV2/upgradeStrictHere.ts
var import_lodash50 = __toESM(require_lodash(), 1);
var STRICT_HERE = {
  type: "primitive",
  mark: { type: "cursor" },
  selectionType: "token",
  position: "contents",
  modifier: { type: "identity" },
  insideOutsideType: "inside"
};
var IMPLICIT_TARGET = {
  type: "primitive",
  isImplicit: true
};
var upgradeStrictHere = (target) => (0, import_lodash50.isEqual)(target, STRICT_HERE) ? IMPLICIT_TARGET : target;

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV1ToV2/upgradeV1ToV2.ts
function upgradeV1ToV2(command) {
  const actionName = command.action;
  return {
    spokenForm: command.spokenForm,
    action: {
      name: actionName,
      args: command.extraArgs
    },
    targets: upgradeTargets(command.targets, actionName),
    usePrePhraseSnapshot: command.usePrePhraseSnapshot ?? false,
    version: 2
  };
}
function upgradeModifier(modifier) {
  switch (modifier.type) {
    case "identity":
      return [];
    case "containingScope": {
      const { includeSiblings, scopeType, type: type2, ...rest } = modifier;
      return [
        {
          type: includeSiblings ? "everyScope" : "containingScope",
          scopeType: {
            type: scopeType
          },
          ...rest
        }
      ];
    }
    case "surroundingPair": {
      const { delimiterInclusion, ...rest } = modifier;
      const surroundingPairModifier = {
        type: "containingScope",
        scopeType: rest
      };
      if (delimiterInclusion === "interiorOnly" || delimiterInclusion === "excludeInterior") {
        if (surroundingPairModifier.scopeType.delimiter === "any") {
          return [{ type: delimiterInclusion }];
        }
        return [{ type: delimiterInclusion }, surroundingPairModifier];
      }
      return [surroundingPairModifier];
    }
    case "subpiece": {
      const { type: type2, pieceType, ...rest } = modifier;
      return [
        {
          type: "ordinalRange",
          scopeType: { type: pieceType },
          ...rest
        }
      ];
    }
    case "head":
      return [{ type: "extendThroughStartOf" }];
    case "tail":
      return [{ type: "extendThroughEndOf" }];
    default:
      return [modifier];
  }
}
function upgradePrimitiveTarget(target, action) {
  const {
    type: type2,
    isImplicit,
    mark,
    insideOutsideType,
    modifier,
    selectionType,
    position
  } = target;
  const modifiers = [];
  if (position && position !== "contents") {
    if (position === "before") {
      if (insideOutsideType === "inside") {
        modifiers.push({ type: "position", position: "start" });
      } else if (action === "remove") {
        modifiers.push({ type: "leading" });
      } else {
        modifiers.push({ type: "position", position: "before" });
      }
    } else {
      if (insideOutsideType === "inside") {
        modifiers.push({ type: "position", position: "end" });
      } else if (action === "remove") {
        modifiers.push({ type: "trailing" });
      } else {
        modifiers.push({ type: "position", position: "after" });
      }
    }
  }
  if (selectionType) {
    switch (selectionType) {
      case "token":
        if (modifier?.type === "subpiece") {
          break;
        }
      case "line":
        if (mark?.type === "lineNumber") {
          break;
        }
      default:
        modifiers.push({
          type: "containingScope",
          scopeType: { type: selectionType }
        });
    }
  }
  if (modifier) {
    modifiers.push(...upgradeModifier(modifier));
  }
  return {
    type: type2,
    isImplicit,
    // Empty array of modifiers is not allowed
    modifiers: modifiers.length > 0 ? modifiers : void 0,
    // Cursor token is just cursor position but treated as a token. This is done in the pipeline for normal cursor now
    mark: mark?.type === "cursorToken" ? void 0 : mark
  };
}
function upgradeTarget(target, action) {
  switch (target.type) {
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          (target2) => upgradeTarget(target2, action)
        )
      };
    case "range": {
      const { type: type2, rangeType, start, end, excludeStart, excludeEnd } = target;
      return {
        type: type2,
        rangeType,
        anchor: upgradePrimitiveTarget(start, action),
        active: upgradePrimitiveTarget(end, action),
        excludeAnchor: excludeStart ?? false,
        excludeActive: excludeEnd ?? false
      };
    }
    case "primitive":
      return upgradePrimitiveTarget(target, action);
  }
}
function upgradeTargets(partialTargets, action) {
  return partialTargets.map((target) => upgradeTarget(target, action)).map(
    (target) => target.type === "primitive" ? upgradeStrictHere(target) : target
  );
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV2ToV3/upgradeV2ToV3.ts
var import_lodash51 = __toESM(require_lodash(), 1);
function upgradeV2ToV3(command) {
  return {
    ...command,
    version: 3,
    targets: command.targets.map(upgradeTarget2)
  };
}
function upgradeTarget2(target) {
  switch (target.type) {
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          (target2) => upgradeTarget2(target2)
        )
      };
    case "range": {
      const { anchor, active, ...rest } = target;
      return {
        anchor: upgradePrimitiveTarget2(
          anchor
        ),
        active: upgradePrimitiveTarget2(
          active
        ),
        ...rest
      };
    }
    case "primitive":
      return upgradePrimitiveTarget2(target);
  }
}
function upgradePrimitiveTarget2(target) {
  const modifiers = target.modifiers != null ? target.modifiers.map(updateModifier) : void 0;
  if (target.mark?.type === "lineNumber") {
    const { anchor, active } = target.mark;
    if (anchor.type !== active.type || anchor.lineNumber < 0 !== active.lineNumber < 0) {
      return {
        type: "range",
        anchor: {
          type: "primitive",
          mark: createLineNumberMarkFromPos(anchor),
          modifiers
        },
        active: {
          type: "primitive",
          mark: createLineNumberMarkFromPos(active)
        },
        excludeAnchor: false,
        excludeActive: false
      };
    }
  }
  return {
    ...target,
    mark: target.mark != null ? updateMark(target.mark) : void 0,
    modifiers
  };
}
function updateMark(mark) {
  switch (mark.type) {
    case "lineNumber":
      return createLineNumberMark(mark);
    default:
      return mark;
  }
}
function updateModifier(modifier) {
  switch (modifier.type) {
    case "ordinalRange":
      return createOrdinalModifier(modifier);
    default:
      return modifier;
  }
}
function createLineNumberMark(mark) {
  if ((0, import_lodash51.isEqual)(mark.anchor, mark.active)) {
    return createLineNumberMarkFromPos(mark.anchor);
  }
  return {
    type: "range",
    anchor: createLineNumberMarkFromPos(mark.anchor),
    active: createLineNumberMarkFromPos(mark.active)
  };
}
function createOrdinalModifier(modifier) {
  if (modifier.anchor === modifier.active) {
    return createAbsoluteOrdinalModifier(modifier.scopeType, modifier.anchor);
  }
  if (modifier.anchor === 0 && modifier.active > modifier.anchor) {
    return createAbsoluteOrdinalModifier(
      modifier.scopeType,
      modifier.anchor,
      modifier.active - modifier.anchor + 1
    );
  }
  if (modifier.anchor < 0 && modifier.active === -1) {
    return createAbsoluteOrdinalModifier(
      modifier.scopeType,
      modifier.anchor,
      -modifier.anchor
    );
  }
  return {
    type: "range",
    anchor: createAbsoluteOrdinalModifier(modifier.scopeType, modifier.anchor),
    active: createAbsoluteOrdinalModifier(modifier.scopeType, modifier.active),
    excludeAnchor: modifier.excludeAnchor,
    excludeActive: modifier.excludeActive
  };
}
function createLineNumberMarkFromPos(position) {
  return {
    type: "lineNumber",
    lineNumberType: position.type,
    lineNumber: position.lineNumber
  };
}
function createAbsoluteOrdinalModifier(scopeType, start, length = 1) {
  return {
    type: "ordinalScope",
    scopeType,
    start,
    length
  };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV3ToV4/upgradeV3ToV4.ts
function upgradeV3ToV4(command) {
  return {
    ...command,
    version: 4,
    targets: command.targets.map(upgradeTarget3)
  };
}
function upgradeTarget3(target) {
  switch (target.type) {
    case "primitive":
      return upgradePrimitiveTarget3(target);
    case "range": {
      const { anchor, ...rest } = target;
      return {
        ...rest,
        anchor: upgradePrimitiveTarget3(anchor)
      };
    }
    case "list": {
      const { elements, ...rest } = target;
      return {
        ...rest,
        elements: elements.map(upgradeTarget3)
      };
    }
  }
}
function upgradePrimitiveTarget3(target) {
  if (target.mark == null && target.modifiers == null || target.isImplicit) {
    return { type: "implicit" };
  }
  return target;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV4ToV5/upgradeV4ToV5.ts
function upgradeV4ToV5(command) {
  return {
    ...command,
    version: 5,
    action: upgradeAction(command.action),
    targets: command.targets.map(upgradeTarget4)
  };
}
function upgradeAction(action) {
  switch (action.name) {
    case "wrapWithSnippet": {
      const [name, variableName] = parseSnippetLocation(
        action.args[0]
      );
      return {
        name: "wrapWithSnippet",
        args: [
          {
            type: "named",
            name,
            variableName
          }
        ]
      };
    }
    case "insertSnippet": {
      const [name, substitutions] = action.args;
      const snippetDescription = {
        type: "named",
        name
      };
      if (substitutions != null) {
        snippetDescription.substitutions = substitutions;
      }
      return {
        name: "insertSnippet",
        args: [snippetDescription]
      };
    }
    default:
      return action;
  }
}
function parseSnippetLocation(snippetLocation) {
  const [snippetName, placeholderName] = snippetLocation.split(".");
  if (snippetName == null || placeholderName == null) {
    throw new Error("Snippet location missing '.'");
  }
  return [snippetName, placeholderName];
}
function upgradeTarget4(target) {
  switch (target.type) {
    case "implicit":
      return target;
    case "list":
      return {
        ...target,
        elements: target.elements.map(
          upgradeTarget4
        )
      };
    case "range":
      return {
        ...target,
        anchor: upgradeTarget4(
          target.anchor
        ),
        active: upgradeTarget4(
          target.active
        )
      };
    case "primitive":
      return {
        ...target,
        mark: target.mark != null ? upgradeMark(target.mark) : void 0,
        modifiers: target.modifiers != null && target.modifiers.length > 0 ? target.modifiers.map(upgradeModifier2) : void 0
      };
  }
}
function upgradeMark(mark) {
  if (mark.type === "range") {
    return {
      ...mark,
      anchor: upgradeMark(mark.anchor),
      active: upgradeMark(mark.active),
      excludeAnchor: mark.excludeAnchor ?? false,
      excludeActive: mark.excludeActive ?? false
    };
  }
  return mark;
}
function upgradeModifier2(modifier) {
  if (modifier.type === "range") {
    return {
      ...modifier,
      anchor: upgradeModifier2(modifier.anchor),
      active: upgradeModifier2(modifier.active),
      excludeAnchor: modifier.excludeAnchor ?? false,
      excludeActive: modifier.excludeActive ?? false
    };
  }
  return modifier;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV5ToV6/canonicalizeActionName.ts
var actionAliasToCanonicalName = {
  bring: "replaceWithTarget",
  call: "callAsFunction",
  clear: "clearAndSetSelection",
  commentLines: "toggleLineComment",
  copy: "copyToClipboard",
  cut: "cutToClipboard",
  delete: "remove",
  editNewLineAbove: "editNewLineBefore",
  editNewLineBelow: "editNewLineAfter",
  findInFiles: "findInWorkspace",
  fold: "foldRegion",
  indentLines: "indentLine",
  insertEmptyLineAbove: "insertEmptyLineBefore",
  insertEmptyLineBelow: "insertEmptyLineAfter",
  insertLineAfter: "editNewLineAfter",
  insertLineBefore: "editNewLineBefore",
  move: "moveToTarget",
  outdentLines: "outdentLine",
  paste: "pasteFromClipboard",
  reverse: "reverseTargets",
  setBreakpoint: "toggleLineBreakpoint",
  sort: "sortTargets",
  swap: "swapTargets",
  unfold: "unfoldRegion",
  use: "replaceWithTarget",
  wrap: "wrapWithPairedDelimiter"
};
function canonicalizeActionName(actionName) {
  const canonicalName = actionAliasToCanonicalName[actionName] ?? actionName;
  if (!actionNames.includes(canonicalName)) {
    throw new Error(`Unknown action name: ${canonicalName}`);
  }
  return canonicalName;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV5ToV6/upgradeV5ToV6.ts
function upgradeV5ToV6(command) {
  return {
    version: 6,
    spokenForm: command.spokenForm,
    usePrePhraseSnapshot: command.usePrePhraseSnapshot,
    action: upgradeAction2(command.action, command.targets)
  };
}
function upgradeAction2(action, targets) {
  const name = canonicalizeActionName(action.name);
  switch (name) {
    case "replaceWithTarget":
    case "moveToTarget":
      return {
        name,
        source: upgradeTarget5(targets[0]),
        destination: targetToDestination(targets[1])
      };
    case "swapTargets":
      return {
        name,
        target1: upgradeTarget5(targets[0]),
        target2: upgradeTarget5(targets[1])
      };
    case "callAsFunction":
      return {
        name,
        callee: upgradeTarget5(targets[0]),
        argument: upgradeTarget5(targets[1])
      };
    case "pasteFromClipboard":
      return {
        name,
        destination: targetToDestination(targets[0])
      };
    case "wrapWithPairedDelimiter":
    case "rewrapWithPairedDelimiter":
      return {
        name,
        left: action.args[0],
        right: action.args[1],
        target: upgradeTarget5(targets[0])
      };
    case "generateSnippet":
      return {
        name,
        snippetName: action.args?.[0],
        target: upgradeTarget5(targets[0])
      };
    case "insertSnippet":
      return {
        name,
        snippetDescription: action.args[0],
        destination: targetToDestination(targets[0])
      };
    case "wrapWithSnippet":
      return {
        name,
        snippetDescription: action.args[0],
        target: upgradeTarget5(targets[0])
      };
    case "executeCommand":
      return {
        name,
        commandId: action.args[0],
        options: action.args?.[1],
        target: upgradeTarget5(targets[0])
      };
    case "replace":
      return {
        name,
        replaceWith: action.args[0],
        destination: targetToDestination(targets[0])
      };
    case "highlight": {
      const result = {
        name,
        target: upgradeTarget5(targets[0])
      };
      if (action.args?.[0] != null) {
        result.highlightId = action.args?.[0];
      }
      return result;
    }
    case "editNew":
      return {
        name,
        destination: targetToDestination(targets[0])
      };
    case "getText":
      return {
        name,
        options: action.args?.[0],
        target: upgradeTarget5(targets[0])
      };
    default:
      return {
        name,
        target: upgradeTarget5(targets[0])
      };
  }
}
function upgradeTarget5(target) {
  switch (target.type) {
    case "list":
    case "range":
    case "primitive":
      return upgradeNonImplicitTarget(target);
    case "implicit":
      return target;
  }
}
function upgradeNonImplicitTarget(target) {
  switch (target.type) {
    case "list":
      return upgradeListTarget(target);
    case "range":
    case "primitive":
      return upgradeRangeOrPrimitiveTarget(target);
  }
}
function upgradeListTarget(target) {
  return {
    ...target,
    elements: target.elements.map(upgradeRangeOrPrimitiveTarget)
  };
}
function upgradeRangeOrPrimitiveTarget(target) {
  switch (target.type) {
    case "range":
      return upgradeRangeTarget(target);
    case "primitive":
      return upgradePrimitiveTarget4(target);
  }
}
function upgradeRangeTarget(target) {
  const { anchor, active } = target;
  const result = {
    type: "range",
    anchor: anchor.type === "implicit" ? anchor : upgradePrimitiveTarget4(anchor),
    active: upgradePrimitiveTarget4(active),
    excludeAnchor: target.excludeAnchor,
    excludeActive: target.excludeActive
  };
  if (target.rangeType != null) {
    result.rangeType = target.rangeType;
  }
  return result;
}
function upgradePrimitiveTarget4(target) {
  const result = {
    type: "primitive"
  };
  const modifiers = upgradeModifiers(target.modifiers);
  if (modifiers != null) {
    result.modifiers = modifiers;
  }
  if (target.mark != null) {
    result.mark = target.mark;
  }
  return result;
}
function targetToDestination(target) {
  switch (target.type) {
    case "list":
      return listTargetToDestination(target);
    case "range":
      return rangeTargetToDestination(target);
    case "primitive":
      return primitiveTargetToDestination(target);
    case "implicit":
      return implicitTargetToDestination();
  }
}
function listTargetToDestination(target) {
  const destinations = [];
  let currentElements = [];
  let currentInsertionMode = void 0;
  const potentiallyAddDestination = () => {
    if (currentElements.length > 0) {
      destinations.push({
        type: "primitive",
        insertionMode: currentInsertionMode ?? "to",
        target: currentElements.length === 1 ? currentElements[0] : {
          type: "list",
          elements: currentElements
        }
      });
    }
  };
  target.elements.forEach((element) => {
    const insertionMode = getInsertionMode(element);
    if (insertionMode != null) {
      potentiallyAddDestination();
      currentElements = [upgradeRangeOrPrimitiveTarget(element)];
      currentInsertionMode = insertionMode;
    } else {
      currentElements.push(upgradeRangeOrPrimitiveTarget(element));
    }
  });
  potentiallyAddDestination();
  if (destinations.length > 1) {
    return {
      type: "list",
      destinations
    };
  }
  return destinations[0];
}
function rangeTargetToDestination(target) {
  return {
    type: "primitive",
    insertionMode: getInsertionMode(target.anchor) ?? "to",
    target: upgradeRangeTarget(target)
  };
}
function primitiveTargetToDestination(target) {
  return {
    type: "primitive",
    insertionMode: getInsertionMode(target) ?? "to",
    target: upgradePrimitiveTarget4(target)
  };
}
function implicitTargetToDestination() {
  return { type: "implicit" };
}
function getInsertionMode(target) {
  switch (target.type) {
    case "implicit":
      return "to";
    case "primitive":
      return getInsertionModeFromPrimitive(target);
    case "range":
      return getInsertionMode(target.anchor);
  }
}
function getInsertionModeFromPrimitive(target) {
  const positionModifier = target.modifiers?.find(
    (m) => m.type === "position"
  );
  if (positionModifier != null) {
    if (target.modifiers.indexOf(positionModifier) !== 0) {
      throw Error("Position modifier has to be at first index");
    }
    if (positionModifier?.position === "before" || positionModifier?.position === "after") {
      return positionModifier.position;
    }
  }
  return void 0;
}
function upgradeModifiers(modifiers) {
  const result = [];
  if (modifiers != null) {
    for (const modifier of modifiers) {
      if (modifier.type === "position") {
        if (modifier.position === "start") {
          result.push({ type: "startOf" });
        } else if (modifier.position === "end") {
          result.push({ type: "endOf" });
        }
      } else {
        result.push(modifier);
      }
    }
  }
  return result.length > 0 ? result : void 0;
}

// ../cursorless-engine/src/core/commandVersionUpgrades/upgradeV6ToV7.ts
function upgradeV6ToV7(command) {
  return { ...command, version: 7 };
}

// ../cursorless-engine/src/core/commandVersionUpgrades/canonicalizeAndValidateCommand.ts
function canonicalizeAndValidateCommand(command) {
  const commandUpgraded = upgradeCommand(command);
  const { action, usePrePhraseSnapshot = false, spokenForm } = commandUpgraded;
  return {
    version: LATEST_VERSION,
    spokenForm,
    action: produce(action, (draft) => {
      const partialTargets = getPartialTargetDescriptors(draft);
      canonicalizeTargetsInPlace(partialTargets);
      validateCommand(action.name, partialTargets);
    }),
    usePrePhraseSnapshot
  };
}
function upgradeCommand(command) {
  if (command.version > LATEST_VERSION) {
    throw new OutdatedExtensionError();
  }
  while (command.version < LATEST_VERSION) {
    switch (command.version) {
      case 0:
        command = upgradeV0ToV1(command);
        break;
      case 1:
        command = upgradeV1ToV2(command);
        break;
      case 2:
        command = upgradeV2ToV3(command);
        break;
      case 3:
        command = upgradeV3ToV4(command);
        break;
      case 4:
        command = upgradeV4ToV5(command);
        break;
      case 5:
        command = upgradeV5ToV6(command);
        break;
      case 6:
        command = upgradeV6ToV7(command);
        break;
      default:
        throw new Error(
          `Can't upgrade from unknown version ${command.version}`
        );
    }
  }
  if (command.version !== LATEST_VERSION) {
    throw new Error("Command is not latest version");
  }
  return command;
}
function validateCommand(actionName, partialTargets) {
  if (usesScopeType("notebookCell", partialTargets) && !["editNewLineBefore", "editNewLineAfter"].includes(actionName)) {
    throw new Error(
      "The notebookCell scope type is currently only supported with the actions editNewLineAbove and editNewLineBelow"
    );
  }
}
function usesScopeType(scopeTypeType, partialTargets) {
  return getPartialPrimitiveTargets(partialTargets).some(
    (partialTarget) => partialTarget.modifiers?.find(
      (mod) => (mod.type === "containingScope" || mod.type === "everyScope") && mod.scopeType.type === scopeTypeType
    )
  );
}

// ../cursorless-engine/src/processTargets/marks/CursorStage.ts
var CursorStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    return getActiveSelections(ide()).map(
      (selection) => new UntypedTarget({
        editor: selection.editor,
        isReversed: selection.selection.isReversed,
        contentRange: selection.selection,
        hasExplicitRange: !selection.selection.isEmpty,
        isToken: false
      })
    );
  }
};

// ../cursorless-engine/src/processTargets/marks/DecoratedSymbolStage.ts
var DecoratedSymbolStage = class {
  constructor(readableHatMap, mark) {
    this.readableHatMap = readableHatMap;
    this.mark = mark;
  }
  run() {
    const token = this.readableHatMap.getToken(
      this.mark.symbolColor,
      this.mark.character
    );
    if (token == null) {
      throw new Error(
        `Couldn't find mark ${this.mark.symbolColor} '${this.mark.character}'`
      );
    }
    return [
      new UntypedTarget({
        editor: token.editor,
        contentRange: token.range,
        isReversed: false,
        hasExplicitRange: false
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/ExplicitMarkStage.ts
var ExplicitMarkStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    const {
      editorId,
      range: { start, end }
    } = this.mark;
    const editor = ide().visibleTextEditors.find((e) => e.id === editorId);
    if (editor == null) {
      throw new Error(`Couldn't find editor '${editorId}'`);
    }
    const contentRange = new Range(
      start.line,
      start.character,
      end.line,
      end.character
    );
    return [
      new UntypedTarget({
        editor,
        contentRange,
        isReversed: false,
        hasExplicitRange: false
      })
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/LineNumberStage.ts
var LineNumberStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    const editor = ide().activeTextEditor;
    if (editor == null) {
      return [];
    }
    const lineNumber = getLineNumber2(
      editor,
      this.mark.lineNumberType,
      this.mark.lineNumber
    );
    const contentRange = editor.document.lineAt(lineNumber).range;
    return [createLineTarget(editor, false, contentRange)];
  }
};
var getLineNumber2 = (editor, lineNumberType, lineNumber) => {
  switch (lineNumberType) {
    case "absolute":
      return lineNumber;
    case "relative":
      return editor.selections[0].active.line + lineNumber;
    case "modulo100": {
      const stepSize = 100;
      const startLine = editor.visibleRanges[0].start.line;
      const endLine = editor.visibleRanges[editor.visibleRanges.length - 1].end.line;
      const base = Math.floor(startLine / stepSize) * stepSize;
      const visibleLines = [];
      const invisibleLines = [];
      let currentLineNumber = base + lineNumber;
      while (currentLineNumber <= endLine) {
        if (currentLineNumber >= startLine) {
          const visible = editor.visibleRanges.find(
            (r) => currentLineNumber >= r.start.line && currentLineNumber <= r.end.line
          );
          if (visible) {
            visibleLines.push(currentLineNumber);
          } else {
            invisibleLines.push(currentLineNumber);
          }
        }
        currentLineNumber += stepSize;
      }
      if (visibleLines.length === 1) {
        return visibleLines[0];
      }
      if (visibleLines.length + invisibleLines.length > 1) {
        throw new Error("Multiple lines matching");
      }
      if (invisibleLines.length === 1) {
        return invisibleLines[0];
      }
      throw new Error("Line is not in viewport");
    }
  }
};

// ../cursorless-engine/src/processTargets/marks/NothingStage.ts
var NothingStage = class {
  constructor(mark) {
    this.mark = mark;
  }
  run() {
    return [];
  }
};

// ../cursorless-engine/src/processTargets/marks/RangeMarkStage.ts
var RangeMarkStage = class {
  constructor(markStageFactory, mark) {
    this.markStageFactory = markStageFactory;
    this.mark = mark;
  }
  run() {
    const anchorStage = this.markStageFactory.create(this.mark.anchor);
    const activeStage = this.markStageFactory.create(this.mark.active);
    const anchorTargets = anchorStage.run();
    const activeTargets = activeStage.run();
    if (anchorTargets.length !== 1 || activeTargets.length !== 1) {
      throw new Error("Expected single anchor and active target");
    }
    return [
      targetsToContinuousTarget(
        anchorTargets[0],
        activeTargets[0],
        this.mark.excludeAnchor,
        this.mark.excludeActive
      )
    ];
  }
};

// ../cursorless-engine/src/processTargets/marks/StoredTargetStage.ts
var StoredTargetStage = class {
  constructor(storedTargets, key) {
    this.storedTargets = storedTargets;
    this.key = key;
  }
  run() {
    const targets = this.storedTargets.get(this.key);
    if (targets == null || targets.length === 0) {
      throw Error(`No available ${this.key} marks`);
    }
    return targets;
  }
};

// ../cursorless-engine/src/processTargets/marks/TargetMarkStage.ts
var TargetMarkStage = class {
  constructor(targetPipelineRunner, mark) {
    this.targetPipelineRunner = targetPipelineRunner;
    this.mark = mark;
  }
  run() {
    return this.targetPipelineRunner.run(this.mark.target);
  }
};

// ../cursorless-engine/src/processTargets/MarkStageFactoryImpl.ts
var MarkStageFactoryImpl = class {
  constructor(readableHatMap, storedTargets) {
    this.readableHatMap = readableHatMap;
    this.storedTargets = storedTargets;
    this.create = this.create.bind(this);
  }
  setPipelineRunner(targetPipelineRunner) {
    this.targetPipelineRunner = targetPipelineRunner;
  }
  create(mark) {
    switch (mark.type) {
      case "cursor":
        return new CursorStage(mark);
      case "that":
      case "source":
      case "keyboard":
        return new StoredTargetStage(this.storedTargets, mark.type);
      case "decoratedSymbol":
        return new DecoratedSymbolStage(this.readableHatMap, mark);
      case "lineNumber":
        return new LineNumberStage(mark);
      case "range":
        return new RangeMarkStage(this, mark);
      case "nothing":
        return new NothingStage(mark);
      case "target":
        return new TargetMarkStage(this.targetPipelineRunner, mark);
      case "explicit":
        return new ExplicitMarkStage(mark);
    }
  }
};

// ../cursorless-engine/src/runCommand.ts
async function runCommand(treeSitter, commandServerApi, debug, hatTokenMap, snippets, storedTargets, languageDefinitions, rangeUpdater, commandRunnerDecorators, command) {
  if (debug.active) {
    debug.log(`command:`);
    debug.log(JSON.stringify(command, null, 2));
  }
  const commandComplete = canonicalizeAndValidateCommand(command);
  const readableHatMap = await hatTokenMap.getReadableMap(
    commandComplete.usePrePhraseSnapshot
  );
  let commandRunner = createCommandRunner(
    treeSitter,
    commandServerApi,
    languageDefinitions,
    debug,
    storedTargets,
    readableHatMap,
    snippets,
    rangeUpdater
  );
  for (const decorator of commandRunnerDecorators) {
    commandRunner = decorator.wrapCommandRunner(readableHatMap, commandRunner);
  }
  const response = await commandRunner.run(commandComplete);
  return await unwrapLegacyCommandResponse(command, response);
}
async function unwrapLegacyCommandResponse(command, response) {
  if (clientSupportsFallback(command)) {
    return response;
  }
  if ("returnValue" in response) {
    return response.returnValue;
  }
  return void 0;
}
function createCommandRunner(treeSitter, commandServerApi, languageDefinitions, debug, storedTargets, readableHatMap, snippets, rangeUpdater) {
  const modifierStageFactory = new ModifierStageFactoryImpl(
    languageDefinitions,
    storedTargets,
    new ScopeHandlerFactoryImpl(languageDefinitions)
  );
  const markStageFactory = new MarkStageFactoryImpl(
    readableHatMap,
    storedTargets
  );
  const targetPipelineRunner = new TargetPipelineRunner(
    modifierStageFactory,
    markStageFactory
  );
  markStageFactory.setPipelineRunner(targetPipelineRunner);
  return new CommandRunnerImpl(
    commandServerApi,
    debug,
    storedTargets,
    targetPipelineRunner,
    new Actions(treeSitter, snippets, rangeUpdater, modifierStageFactory)
  );
}

// ../cursorless-engine/src/languages/LegacyLanguageId.ts
var legacyLanguageIds = [
  "c",
  "clojure",
  "cpp",
  "csharp",
  "css",
  "go",
  "html",
  "java",
  "javascript",
  "javascriptreact",
  "json",
  "jsonc",
  "latex",
  "markdown",
  "php",
  "python",
  "ruby",
  "rust",
  "scala",
  "scss",
  "typescript",
  "typescriptreact",
  "xml"
];

// ../cursorless-engine/src/runIntegrationTests.ts
var import_assert = __toESM(require("assert"), 1);
async function runIntegrationTests(treeSitter, languageDefinitions) {
  await assertNoScopesBothLegacyAndNew(treeSitter, languageDefinitions);
}
async function assertNoScopesBothLegacyAndNew(treeSitter, languageDefinitions) {
  const errors2 = [];
  for (const languageId of legacyLanguageIds) {
    await treeSitter.loadLanguage(languageId);
    await languageDefinitions.loadLanguage(languageId);
    unsafeKeys(languageMatchers[languageId] ?? {}).map((scopeTypeType) => {
      if (languageDefinitions.get(languageId)?.getScopeHandler({
        type: scopeTypeType
      }) != null) {
        errors2.push(
          `Scope '${scopeTypeType}' defined as both legacy and new for language ${languageId}`
        );
      }
    });
  }
  import_assert.default.deepStrictEqual(errors2, []);
}

// ../cursorless-engine/src/scopeProviders/ScopeInfoProvider.ts
var import_lodash52 = __toESM(require_lodash(), 1);

// ../cursorless-engine/src/scopeProviders/scopeTypeToString.ts
function scopeTypeToString(scopeType) {
  if (isSimpleScopeType(scopeType)) {
    return camelCaseToAllDown(scopeType.type).replace(".", " ");
  }
  if (scopeType.type === "surroundingPair") {
    return `Matching pair of ${camelCaseToAllDown(scopeType.delimiter)}`;
  }
  if (scopeType.type === "customRegex") {
    return `Regex \`${scopeType.regex}\``;
  }
  return "Unknown scope type";
}

// ../cursorless-engine/src/scopeProviders/ScopeInfoProvider.ts
var ScopeInfoProvider = class {
  constructor(customSpokenFormGenerator) {
    this.customSpokenFormGenerator = customSpokenFormGenerator;
    this.listeners = [];
    this.disposable = customSpokenFormGenerator.onDidChangeCustomSpokenForms(
      () => this.onChange()
    );
    this.onDidChangeScopeInfo = this.onDidChangeScopeInfo.bind(this);
    this.getScopeTypeInfo = this.getScopeTypeInfo.bind(this);
    this.updateScopeTypeInfos();
  }
  /**
   * Registers a callback to be run when the scope info changes.  The callback
   * will be run immediately once with the current scope info.
   *
   * Includes information about the available scopes, including their custom
   * spoken forms, if available. Note that even custom regex scopes will be
   * available, as reported to the engine by Talon.
   * @param callback The callback to run when the scope support changes
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeInfo(callback2) {
    callback2(this.getScopeTypeInfos());
    this.listeners.push(callback2);
    return {
      dispose: () => {
        (0, import_lodash52.pull)(this.listeners, callback2);
      }
    };
  }
  async onChange() {
    this.updateScopeTypeInfos();
    this.listeners.forEach((listener) => listener(this.scopeInfos));
  }
  updateScopeTypeInfos() {
    const scopeTypes = [
      ...simpleScopeTypeTypes.filter((scopeTypeType) => scopeTypeType !== "instance").map((scopeTypeType) => ({
        type: scopeTypeType
      })),
      ...surroundingPairNames.map(
        (surroundingPairName) => ({
          type: "surroundingPair",
          delimiter: surroundingPairName
        })
      ),
      ...this.customSpokenFormGenerator.getCustomRegexScopeTypes()
    ];
    this.scopeInfos = scopeTypes.map(
      (scopeType) => this.getScopeTypeInfo(scopeType)
    );
  }
  getScopeTypeInfos() {
    return this.scopeInfos;
  }
  getScopeTypeInfo(scopeType) {
    return {
      scopeType,
      spokenForm: this.customSpokenFormGenerator.scopeTypeToSpokenForm(scopeType),
      humanReadableName: scopeTypeToString(scopeType),
      isLanguageSpecific: isLanguageSpecific(scopeType)
    };
  }
  dispose() {
    this.disposable.dispose();
  }
};
function isLanguageSpecific(scopeType) {
  switch (scopeType.type) {
    case "string":
    case "argumentOrParameter":
    case "anonymousFunction":
    case "attribute":
    case "branch":
    case "class":
    case "className":
    case "collectionItem":
    case "collectionKey":
    case "command":
    case "comment":
    case "private.fieldAccess":
    case "functionCall":
    case "functionCallee":
    case "functionName":
    case "ifStatement":
    case "instance":
    case "list":
    case "map":
    case "name":
    case "namedFunction":
    case "regularExpression":
    case "statement":
    case "type":
    case "value":
    case "condition":
    case "section":
    case "sectionLevelOne":
    case "sectionLevelTwo":
    case "sectionLevelThree":
    case "sectionLevelFour":
    case "sectionLevelFive":
    case "sectionLevelSix":
    case "selector":
    case "private.switchStatementSubject":
    case "unit":
    case "xmlBothTags":
    case "xmlElement":
    case "xmlEndTag":
    case "xmlStartTag":
    case "part":
    case "chapter":
    case "subSection":
    case "subSubSection":
    case "namedParagraph":
    case "subParagraph":
    case "environment":
      return true;
    case "character":
    case "word":
    case "token":
    case "identifier":
    case "line":
    case "sentence":
    case "paragraph":
    case "document":
    case "nonWhitespaceSequence":
    case "boundedNonWhitespaceSequence":
    case "url":
    case "notebookCell":
    case "surroundingPair":
    case "customRegex":
    case "glyph":
      return false;
    case "oneOf":
      throw Error(
        `Can't decide whether scope type ${JSON.stringify(
          scopeType,
          void 0,
          3
        )} is language-specific`
      );
  }
}

// ../cursorless-engine/src/scopeProviders/getIterationRange.ts
var import_lodash53 = __toESM(require_lodash(), 1);
function getIterationRange(editor, scopeHandler, visibleOnly) {
  if (!visibleOnly) {
    return editor.document.range;
  }
  let visibleRange = editor.visibleRanges.reduce(
    (acc, range4) => acc.union(range4)
  );
  visibleRange = editor.document.range.intersection(
    visibleRange.with(
      visibleRange.start.translate(-10),
      visibleRange.end.translate(10)
    )
  );
  const expandedStart = (0, import_lodash53.last)(
    Array.from(
      scopeHandler.generateScopes(editor, visibleRange.start, "forward", {
        containment: "required"
      })
    )
  )?.domain ?? visibleRange;
  const expandedEnd = (0, import_lodash53.last)(
    Array.from(
      scopeHandler.generateScopes(editor, visibleRange.end, "forward", {
        containment: "required"
      })
    )
  )?.domain ?? visibleRange;
  return expandedStart.union(expandedEnd);
}

// ../cursorless-engine/src/scopeProviders/getTargetRanges.ts
function getTargetRanges(target) {
  const interior = (() => {
    try {
      return target.getInteriorStrict().map(getTargetRanges);
    } catch (error) {
      if (error instanceof NoContainingScopeError) {
        return void 0;
      }
      throw error;
    }
  })();
  const boundary = (() => {
    try {
      return target.getBoundaryStrict().map(getTargetRanges);
    } catch (error) {
      if (error instanceof NoContainingScopeError) {
        return void 0;
      }
      throw error;
    }
  })();
  return {
    contentRange: target.contentRange,
    removalRange: target.getRemovalRange(),
    removalHighlightRange: target.isLine ? toLineRange(target.getRemovalHighlightRange()) : toCharacterRange(target.getRemovalHighlightRange()),
    leadingDelimiter: getOptionalTarget(target.getLeadingDelimiterTarget()),
    trailingDelimiter: getOptionalTarget(target.getTrailingDelimiterTarget()),
    interior,
    boundary,
    insertionDelimiter: target.insertionDelimiter
  };
}
function getOptionalTarget(target) {
  return target != null ? getTargetRanges(target) : void 0;
}

// ../cursorless-engine/src/scopeProviders/getIterationScopeRanges.ts
function getIterationScopeRanges(editor, iterationScopeHandler, everyStage, iterationRange, includeIterationNestedTargets) {
  return map2(
    iterationScopeHandler.generateScopes(
      editor,
      iterationRange.start,
      "forward",
      {
        includeDescendantScopes: true,
        distalPosition: iterationRange.end
      }
    ),
    (scope) => {
      return {
        domain: scope.domain,
        ranges: scope.getTargets(false).map((target) => ({
          range: target.contentRange,
          targets: includeIterationNestedTargets ? getEveryScopeLenient(everyStage, target).map(getTargetRanges) : void 0
        }))
      };
    }
  );
}
function getEveryScopeLenient(everyStage, target) {
  try {
    return everyStage.run(target);
  } catch (err) {
    if (err.name === "NoContainingScopeError") {
      return [];
    }
    throw err;
  }
}

// ../cursorless-engine/src/scopeProviders/getScopeRanges.ts
function getScopeRanges(editor, scopeHandler, iterationRange) {
  return map2(
    scopeHandler.generateScopes(editor, iterationRange.start, "forward", {
      includeDescendantScopes: true,
      distalPosition: iterationRange.end
    }),
    (scope) => ({
      domain: scope.domain,
      targets: scope.getTargets(false).map(getTargetRanges)
    })
  );
}

// ../cursorless-engine/src/scopeProviders/ScopeRangeProvider.ts
var ScopeRangeProvider = class {
  constructor(scopeHandlerFactory, modifierStageFactory) {
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.modifierStageFactory = modifierStageFactory;
    this.provideScopeRanges = this.provideScopeRanges.bind(this);
    this.provideIterationScopeRanges = this.provideIterationScopeRanges.bind(this);
  }
  provideScopeRanges(editor, { scopeType, visibleOnly }) {
    const scopeHandler = this.scopeHandlerFactory.create(
      scopeType,
      editor.document.languageId
    );
    if (scopeHandler == null) {
      return [];
    }
    return getScopeRanges(
      editor,
      scopeHandler,
      getIterationRange(editor, scopeHandler, visibleOnly)
    );
  }
  provideIterationScopeRanges(editor, { scopeType, visibleOnly, includeNestedTargets }) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.create(scopeType, languageId);
    if (scopeHandler == null) {
      return [];
    }
    const iterationScopeHandler = this.scopeHandlerFactory.create(
      scopeHandler.iterationScopeType,
      languageId
    );
    if (iterationScopeHandler == null) {
      return [];
    }
    return getIterationScopeRanges(
      editor,
      iterationScopeHandler,
      this.modifierStageFactory.create({
        type: "everyScope",
        scopeType
      }),
      getIterationRange(editor, scopeHandler, visibleOnly),
      includeNestedTargets
    );
  }
};

// ../cursorless-engine/src/scopeProviders/ScopeRangeWatcher.ts
var import_lodash54 = __toESM(require_lodash(), 1);
var ScopeRangeWatcher = class {
  constructor(languageDefinitions, scopeRangeProvider) {
    this.scopeRangeProvider = scopeRangeProvider;
    this.disposables = [];
    this.debouncer = new Debouncer(() => this.onChange());
    this.listeners = [];
    this.onChange = this.onChange.bind(this);
    this.onDidChangeScopeRanges = this.onDidChangeScopeRanges.bind(this);
    this.onDidChangeIterationScopeRanges = this.onDidChangeIterationScopeRanges.bind(this);
    this.disposables.push(
      // An Event which fires when the array of visible editors has changed.
      ide().onDidChangeVisibleTextEditors(this.debouncer.run),
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(this.debouncer.run),
      // An Event that fires when a text document closes
      ide().onDidCloseTextDocument(this.debouncer.run),
      // An event that is emitted when a text document is changed. This usually
      // happens when the contents changes but also when other things like the
      // dirty-state changes.
      ide().onDidChangeTextDocument(this.debouncer.run),
      ide().onDidChangeTextEditorVisibleRanges(this.debouncer.run),
      languageDefinitions.onDidChangeDefinition(this.onChange),
      this.debouncer
    );
  }
  /**
   * Registers a callback to be run when the scope ranges change for any visible
   * editor.  The callback will be run immediately once for each visible editor
   * with the current scope ranges.
   * @param callback The callback to run when the scope ranges change
   * @param config The configuration for the scope ranges
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeRanges(callback2, config) {
    const fn = () => {
      ide().visibleTextEditors.forEach((editor) => {
        let scopeRanges;
        try {
          scopeRanges = this.scopeRangeProvider.provideScopeRanges(
            editor,
            config
          );
        } catch (err) {
          showError(
            ide().messages,
            "ScopeRangeWatcher.provide",
            err.message
          );
          scopeRanges = [];
          if (ide().runMode === "test") {
            throw err;
          }
        }
        callback2(editor, scopeRanges);
      });
    };
    this.listeners.push(fn);
    fn();
    return {
      dispose: () => {
        (0, import_lodash54.pull)(this.listeners, fn);
      }
    };
  }
  /**
   * Registers a callback to be run when the iteration scope ranges change for
   * any visible editor.  The callback will be run immediately once for each
   * visible editor with the current iteration scope ranges.
   * @param callback The callback to run when the scope ranges change
   * @param config The configuration for the scope ranges
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeIterationScopeRanges(callback2, config) {
    const fn = () => {
      ide().visibleTextEditors.forEach((editor) => {
        callback2(
          editor,
          this.scopeRangeProvider.provideIterationScopeRanges(editor, config)
        );
      });
    };
    this.listeners.push(fn);
    fn();
    return {
      dispose: () => {
        (0, import_lodash54.pull)(this.listeners, fn);
      }
    };
  }
  onChange() {
    this.listeners.forEach((listener) => listener());
  }
  dispose() {
    this.disposables.forEach(({ dispose }) => {
      try {
        dispose();
      } catch (e) {
      }
    });
  }
};

// ../cursorless-engine/src/scopeProviders/ScopeSupportChecker.ts
var ScopeSupportChecker = class {
  constructor(scopeHandlerFactory) {
    this.scopeHandlerFactory = scopeHandlerFactory;
    this.getScopeSupport = this.getScopeSupport.bind(this);
    this.getIterationScopeSupport = this.getIterationScopeSupport.bind(this);
  }
  /**
   * Determine the level of support for {@link scopeType} in {@link editor}, as
   * determined by its language id.
   * @param editor The editor to check
   * @param scopeType The scope type to check
   * @returns The level of support for {@link scopeType} in {@link editor}
   */
  getScopeSupport(editor, scopeType) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.create(scopeType, languageId);
    if (scopeHandler == null) {
      return getLegacyScopeSupport(languageId, scopeType);
    }
    return editorContainsScope(editor, scopeHandler) ? 0 /* supportedAndPresentInEditor */ : 1 /* supportedButNotPresentInEditor */;
  }
  /**
   * Determine the level of support for the iteration scope of {@link scopeType}
   * in {@link editor}, as determined by its language id.
   * @param editor The editor to check
   * @param scopeType The scope type to check
   * @returns The level of support for the iteration scope of {@link scopeType}
   * in {@link editor}
   */
  getIterationScopeSupport(editor, scopeType) {
    const { languageId } = editor.document;
    const scopeHandler = this.scopeHandlerFactory.create(scopeType, languageId);
    if (scopeHandler == null) {
      return getLegacyScopeSupport(languageId, scopeType);
    }
    const iterationScopeHandler = this.scopeHandlerFactory.create(
      scopeHandler.iterationScopeType,
      languageId
    );
    if (iterationScopeHandler == null) {
      return 3 /* unsupported */;
    }
    return editorContainsScope(editor, iterationScopeHandler) ? 0 /* supportedAndPresentInEditor */ : 1 /* supportedButNotPresentInEditor */;
  }
};
function editorContainsScope(editor, scopeHandler) {
  return !isEmptyIterable(
    scopeHandler.generateScopes(editor, new Position(0, 0), "forward")
  );
}
function getLegacyScopeSupport(languageId, scopeType) {
  switch (scopeType.type) {
    case "boundedNonWhitespaceSequence":
    case "surroundingPair":
      return 2 /* supportedLegacy */;
    case "notebookCell":
      return 3 /* unsupported */;
    default:
      if (languageMatchers[languageId]?.[scopeType.type] != null) {
        return 2 /* supportedLegacy */;
      }
      return 3 /* unsupported */;
  }
}

// ../cursorless-engine/src/scopeProviders/ScopeSupportWatcher.ts
var import_lodash55 = __toESM(require_lodash(), 1);
var ScopeSupportWatcher = class {
  constructor(languageDefinitions, scopeSupportChecker, scopeInfoProvider) {
    this.scopeSupportChecker = scopeSupportChecker;
    this.scopeInfoProvider = scopeInfoProvider;
    this.debouncer = new Debouncer(() => this.onChange());
    this.listeners = [];
    this.onChange = this.onChange.bind(this);
    this.onDidChangeScopeSupport = this.onDidChangeScopeSupport.bind(this);
    this.disposable = disposableFrom(
      // An event that fires when a text document opens
      ide().onDidOpenTextDocument(this.debouncer.run),
      // An Event that fires when a text document closes
      ide().onDidCloseTextDocument(this.debouncer.run),
      // An Event which fires when the active editor has changed. Note that the event also fires when the active editor changes to undefined.
      ide().onDidChangeActiveTextEditor(this.debouncer.run),
      // An event that is emitted when a text document is changed. This usually
      // happens when the contents changes but also when other things like the
      // dirty-state changes.
      ide().onDidChangeTextDocument(this.debouncer.run),
      languageDefinitions.onDidChangeDefinition(this.debouncer.run),
      this.scopeInfoProvider.onDidChangeScopeInfo(this.onChange),
      this.debouncer
    );
  }
  /**
   * Registers a callback to be run when the scope support changes for the active
   * editor.  The callback will be run immediately once with the current support
   * levels for the active editor.
   *
   * Note that this watcher could be expensive, because it runs all the scope
   * handlers for the active editor every time the content of the active editor
   * changes. If you only need info about the available scopes, including their
   * spoken forms, you should use {@link onDidChangeScopeInfo} instead.
   * @param callback The callback to run when the scope support changes
   * @returns A {@link Disposable} which will stop the callback from running
   */
  onDidChangeScopeSupport(callback2) {
    callback2(this.getSupportLevels());
    this.listeners.push(callback2);
    return {
      dispose: () => {
        (0, import_lodash55.pull)(this.listeners, callback2);
      }
    };
  }
  onChange() {
    if (this.listeners.length === 0) {
      return;
    }
    const supportLevels = this.getSupportLevels();
    this.listeners.forEach((listener) => listener(supportLevels));
  }
  getSupportLevels() {
    const activeTextEditor = ide().activeTextEditor;
    const getScopeTypeSupport = activeTextEditor == null ? () => 3 /* unsupported */ : (scopeType) => this.scopeSupportChecker.getScopeSupport(
      activeTextEditor,
      scopeType
    );
    const getIterationScopeTypeSupport = activeTextEditor == null ? () => 3 /* unsupported */ : (scopeType) => this.scopeSupportChecker.getIterationScopeSupport(
      activeTextEditor,
      scopeType
    );
    const scopeTypeInfos = this.scopeInfoProvider.getScopeTypeInfos();
    return scopeTypeInfos.map((scopeTypeInfo) => ({
      ...scopeTypeInfo,
      support: getScopeTypeSupport(scopeTypeInfo.scopeType),
      iterationScopeSupport: getIterationScopeTypeSupport(
        scopeTypeInfo.scopeType
      )
    }));
  }
  dispose() {
    this.disposable.dispose();
  }
};

// ../cursorless-engine/src/cursorlessEngine.ts
async function createCursorlessEngine(treeSitter, ide2, hats, commandServerApi, fileSystem) {
  injectIde(ide2);
  const debug = new Debug(treeSitter);
  const rangeUpdater = new RangeUpdater();
  const snippets = new Snippets();
  snippets.init();
  const hatTokenMap = new HatTokenMapImpl(
    rangeUpdater,
    debug,
    hats,
    commandServerApi
  );
  hatTokenMap.allocateHats();
  const storedTargets = new StoredTargetMap();
  const languageDefinitions = new LanguageDefinitions(fileSystem, treeSitter);
  await languageDefinitions.init();
  const talonSpokenForms = new TalonSpokenFormsJsonReader(fileSystem);
  const customSpokenFormGenerator = new CustomSpokenFormGeneratorImpl(
    talonSpokenForms
  );
  ide2.disposeOnExit(rangeUpdater, languageDefinitions, hatTokenMap, debug);
  const commandRunnerDecorators = [];
  return {
    commandApi: {
      runCommand(command) {
        return runCommand(
          treeSitter,
          commandServerApi,
          debug,
          hatTokenMap,
          snippets,
          storedTargets,
          languageDefinitions,
          rangeUpdater,
          commandRunnerDecorators,
          command
        );
      },
      async runCommandSafe(...args) {
        return runCommand(
          treeSitter,
          commandServerApi,
          debug,
          hatTokenMap,
          snippets,
          storedTargets,
          languageDefinitions,
          rangeUpdater,
          commandRunnerDecorators,
          ensureCommandShape(args)
        );
      }
    },
    scopeProvider: createScopeProvider(
      languageDefinitions,
      storedTargets,
      customSpokenFormGenerator
    ),
    customSpokenFormGenerator,
    storedTargets,
    hatTokenMap,
    snippets,
    injectIde,
    runIntegrationTests: () => runIntegrationTests(treeSitter, languageDefinitions),
    addCommandRunnerDecorator: (decorator) => {
      commandRunnerDecorators.push(decorator);
    }
  };
}
function createScopeProvider(languageDefinitions, storedTargets, customSpokenFormGenerator) {
  const scopeHandlerFactory = new ScopeHandlerFactoryImpl(languageDefinitions);
  const rangeProvider = new ScopeRangeProvider(
    scopeHandlerFactory,
    new ModifierStageFactoryImpl(
      languageDefinitions,
      storedTargets,
      scopeHandlerFactory
    )
  );
  const rangeWatcher = new ScopeRangeWatcher(
    languageDefinitions,
    rangeProvider
  );
  const supportChecker = new ScopeSupportChecker(scopeHandlerFactory);
  const infoProvider = new ScopeInfoProvider(customSpokenFormGenerator);
  const supportWatcher = new ScopeSupportWatcher(
    languageDefinitions,
    supportChecker,
    infoProvider
  );
  return {
    provideScopeRanges: rangeProvider.provideScopeRanges,
    provideIterationScopeRanges: rangeProvider.provideIterationScopeRanges,
    onDidChangeScopeRanges: rangeWatcher.onDidChangeScopeRanges,
    onDidChangeIterationScopeRanges: rangeWatcher.onDidChangeIterationScopeRanges,
    getScopeSupport: supportChecker.getScopeSupport,
    getIterationScopeSupport: supportChecker.getIterationScopeSupport,
    onDidChangeScopeSupport: supportWatcher.onDidChangeScopeSupport,
    getScopeInfo: infoProvider.getScopeTypeInfo,
    onDidChangeScopeInfo: infoProvider.onDidChangeScopeInfo
  };
}

// ../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist(), 1);
var v1 = import_dist.default.v1;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var NIL = import_dist.default.NIL;
var version = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse = import_dist.default.parse;

// ../cursorless-engine/src/CommandHistoryAnalyzer.ts
var import_lodash56 = __toESM(require_lodash(), 1);

// ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob2, position) => {
  const pos = position;
  if (glob2.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i < glob2.length) {
      const c = glob2.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = true;
        i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob2.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob2.length - pos, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
        } else if (c === rangeStart) {
          ranges.push(braceEscape(c));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob2.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-"));
        i += 2;
        continue;
      }
      if (glob2.startsWith("-", i + 1)) {
        rangeStart = c;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob2.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/unescape.js
var unescape2 = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type2, parent, options2 = {}) {
    this.type = type2;
    if (type2)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options2 : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type2 === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str2, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str2.length) {
        const c = str2.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str2.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str2, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str2.length) {
      const c = str2.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str2.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = _AST.#parseAST(str2, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str2.substring(pos - 1)];
    return i;
  }
  static fromGlob(pattern, options2 = {}) {
    const ast = new _AST(null, void 0, options2);
    _AST.#parseAST(pattern, ast, 0, options2);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob2 = this.toString();
    const [re, body, hasMagic2, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic2, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic2;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = void 0;
      return [s, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob2.length; i++) {
      const c = glob2.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape2(glob2), !!hasMagic2, uflag];
  }
};

// ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../node_modules/.pnpm/minimatch@9.0.3/node_modules/minimatch/dist/mjs/index.js
var minimatch = (p, pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (!options2.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options2).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path5 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep2 = defaultPlatform === "win32" ? path5.win32.sep : path5.posix.sep;
minimatch.sep = sep2;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options2 = {}) => (p) => minimatch(p, pattern, options2);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options2 = {}) => orig(p, pattern, ext(def, options2));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options2 = {}) {
        super(pattern, ext(def, options2));
      }
      static defaults(options2) {
        return orig.defaults(ext(def, options2)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type2, parent, options2 = {}) {
        super(type2, parent, ext(def, options2));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options2 = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options2));
      }
    },
    unescape: (s, options2 = {}) => orig.unescape(s, ext(def, options2)),
    escape: (s, options2 = {}) => orig.escape(s, ext(def, options2)),
    filter: (pattern, options2 = {}) => orig.filter(pattern, ext(def, options2)),
    defaults: (options2) => orig.defaults(ext(def, options2)),
    makeRe: (pattern, options2 = {}) => orig.makeRe(pattern, ext(def, options2)),
    braceExpand: (pattern, options2 = {}) => orig.braceExpand(pattern, ext(def, options2)),
    match: (list, pattern, options2 = {}) => orig.match(list, pattern, ext(def, options2)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options2 = {}) => new Minimatch(pattern, options2).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options2 = {}) => {
  const mm = new Minimatch(pattern, options2);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options2 = {}) {
    assertValidPattern(pattern);
    options2 = options2 || {};
    this.options = options2;
    this.pattern = pattern;
    this.platform = options2.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options2.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== void 0 ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options2.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set3 = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set3);
    this.set = set3.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set3, part) => {
        const prev = set3[set3.length - 1];
        if (part === "**" && prev === "**") {
          return set3;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set3.pop();
            return set3;
          }
        }
        set3.push(part);
        return set3;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i] = matched;
        globParts[j] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options2 = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options2 = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options2.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options2.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    return fastTest ? Object.assign(re, { test: fastTest }) : re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set3 = this.set;
    if (!set3.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options2 = this.options;
    const twoStar = options2.noglobstar ? star2 : options2.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options2.nocase ? ["i"] : []);
    let re = set3.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open2, close] = set3.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open2 + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options2 = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set3 = this.set;
    this.debug(this.pattern, "set", set3);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set3.length; i++) {
      const pattern = set3[i];
      let file = ff;
      if (options2.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options2.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options2.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape2;

// ../../node_modules/.pnpm/lru-cache@10.2.0/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type2, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max2, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max2, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max2);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  // properties coming in from the options of these, only max and maxSize
  // really *need* to be protected. The rest can be modified, as they just
  // set defaults for various methods.
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options2, context) => c.#backgroundFetch(k, index, options2, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options2) => c.#indexes(options2),
      rindexes: (options2) => c.#rindexes(options2),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options2) {
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options2;
    if (max2 !== 0 && !isPosInt(max2)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max2);
    }
    this.#max = max2;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max2).fill(void 0);
    this.#valList = new Array(max2).fill(void 0);
    this.#next = new UintArray(max2);
    this.#prev = new UintArray(max2);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max2);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string description of an object.
   * Called by the built-in method Object.prototype.toString.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
   * single key. Always returns stale values, if their info is found in the
   * cache, so be sure to check for expired TTLs if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry2 = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry2.ttl = remain;
        entry2.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry2.size = this.#sizes[i];
    }
    return entry2;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry2 = { value };
      if (this.#ttls && this.#starts) {
        entry2.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry2.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry2.size = this.#sizes[i];
      }
      arr.unshift([key, entry2]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry2] of arr) {
      if (entry2.start) {
        const age = Date.now() - entry2.start;
        entry2.start = perf.now() - age;
      }
      this.set(key, entry2.value, entry2);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options2, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options2;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options: options2,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options2.ignoreFetchAbort && v2 !== void 0;
      if (options2.status) {
        if (aborted && !updateCache) {
          options2.status.fetchAborted = true;
          options2.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options2.status.fetchAbortIgnored = true;
        } else {
          options2.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options2.status)
            options2.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options2.status) {
        options2.status.fetchRejected = true;
        options2.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options2.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
      const noDelete = allowStale || options2.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options2.status && bf2.__staleWhileFetching !== void 0) {
          options2.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
          res(void 0);
          if (options2.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options2.status)
      options2.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options2 = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options2, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options2, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// ../../node_modules/.pnpm/path-scurry@1.10.1/node_modules/path-scurry/dist/mjs/index.js
var import_path5 = require("path");
var import_url = require("url");
var actualFS = __toESM(require("fs"), 1);
var import_fs = require("fs");
var import_promises5 = require("fs/promises");

// ../../node_modules/.pnpm/minipass@7.0.4/node_modules/minipass/dist/esm/index.js
var import_events = require("events");
var import_stream = __toESM(require("stream"), 1);
var import_string_decoder = require("string_decoder");
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof import_stream.default || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof import_events.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_stream.default.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof import_events.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions = (o) => !!o.objectMode;
var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
var Minipass = class extends import_events.EventEmitter {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  /**
   * true if the stream can be written
   */
  writable = true;
  /**
   * true if the stream can be read
   */
  readable = true;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options2 = args[0] || {};
    super();
    if (options2.objectMode && typeof options2.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options2)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options2)) {
      this[ENCODING] = options2.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options2.async;
    this[DECODER] = this[ENCODING] ? new import_string_decoder.StringDecoder(this[ENCODING]) : null;
    if (options2 && options2.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options2 && options2.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options2;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get ["async"]() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c === "string") {
        this[BUFFER][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== void 0)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      if (this[ASYNC])
        defer(() => h.call(this, this[EMITTED_ERROR]));
      else
        h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve({ value, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// ../../node_modules/.pnpm/path-scurry@1.10.1/node_modules/path-scurry/dist/mjs/index.js
var realpathSync = import_fs.realpathSync.native;
var defaultFS = {
  lstatSync: import_fs.lstatSync,
  readdir: import_fs.readdir,
  readdirSync: import_fs.readdirSync,
  readlinkSync: import_fs.readlinkSync,
  realpathSync,
  promises: {
    lstat: import_promises5.lstat,
    readdir: import_promises5.readdir,
    readlink: import_promises5.readlink,
    realpath: import_promises5.realpath
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN2 = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN2;
var normalizeCache = /* @__PURE__ */ new Map();
var normalize = (s) => {
  const c = normalizeCache.get(s);
  if (c)
    return c;
  const n = s.normalize("NFKD");
  normalizeCache.set(s, n);
  return n;
};
var normalizeNocaseCache = /* @__PURE__ */ new Map();
var normalizeNocase = (s) => {
  const c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  const n = normalize(s.toLowerCase());
  normalizeNocaseCache.set(s, n);
  return n;
};
var ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
};
var ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
};
var setAsCwd = Symbol("PathScurry setAsCwd");
var PathBase = class {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['path'] refers to the path of the directory
   * that was passed to readdir.  So, somewhat counterintuitively, this
   * property refers to the *parent* path, not the path object itself.
   * For root entries, it's the path to the entry itself.
   */
  get path() {
    return (this.parent || this).fullpath();
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN2, root, roots, nocase, children, opts) {
    this.name = name;
    this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
    this.#type = type2 & TYPEMASK;
    this.nocase = nocase;
    this.roots = roots;
    this.root = root || this;
    this.#children = children;
    this.#fullpath = opts.fullpath;
    this.#relative = opts.relative;
    this.#relativePosix = opts.relativePosix;
    this.parent = opts.parent;
    if (this.parent) {
      this.#fs = this.parent.#fs;
    } else {
      this.#fs = fsFromOption(opts.fs);
    }
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    if (this.#depth !== void 0)
      return this.#depth;
    if (!this.parent)
      return this.#depth = 0;
    return this.#depth = this.parent.depth() + 1;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path8) {
    if (!path8) {
      return this;
    }
    const rootPath = this.getRootString(path8);
    const dir = path8.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    return result;
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts) {
      p = p.child(part);
    }
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = this.#children.get(this);
    if (cached) {
      return cached;
    }
    const children = Object.assign([], { provisional: 0 });
    this.#children.set(this, children);
    this.#type &= ~READDIR_CALLED;
    return children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
    for (const p of children) {
      if (p.#matchName === name) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
    const pchild = this.newChild(pathPart, UNKNOWN2, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      pchild.#type |= ENOENT;
    }
    children.push(pchild);
    return pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.#relative !== void 0) {
      return this.#relative;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relative = this.name;
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relativePosix = this.fullpathPosix();
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0) {
      return this.#fullpath;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#fullpath = this.name;
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return this.#fullpathPosix = `//?/${p2}`;
      } else {
        return this.#fullpathPosix = p2;
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN2;
  }
  isType(type2) {
    return this[`is${type2}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return true;
    if (!this.parent)
      return false;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN2 && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = await this.#fs.promises.readlink(this.fullpath());
      const linkTarget = this.parent.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = this.#fs.readlinkSync(this.fullpath());
      const linkTarget = this.parent.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++) {
      children[p].#markENOENT();
    }
  }
  #markENOENT() {
    if (this.#type & ENOENT)
      return;
    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
    this.#markChildrenENOENT();
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children) {
      p.#markENOENT();
    }
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH;
    this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    if ((t & IFMT) === IFDIR)
      t &= IFMT_UNKNOWN;
    this.#type = t | ENOTDIR;
    this.#markChildrenENOENT();
  }
  #readdirFail(code = "") {
    if (code === "ENOTDIR" || code === "EPERM") {
      this.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    } else {
      this.children().provisional = 0;
    }
  }
  #lstatFail(code = "") {
    if (code === "ENOTDIR") {
      const p = this.parent;
      p.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    }
  }
  #readlinkFail(code = "") {
    let ter = this.#type;
    ter |= ENOREADLINK;
    if (code === "ENOENT")
      ter |= ENOENT;
    if (code === "EINVAL" || code === "UNKNOWN") {
      ter &= IFMT_UNKNOWN;
    }
    this.#type = ter;
    if (code === "ENOTDIR" && this.parent) {
      this.parent.#markENOTDIR();
    }
  }
  #readdirAddChild(e, c) {
    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
  }
  #readdirAddNewChild(e, c) {
    const type2 = entToType(e);
    const child = this.newChild(e.name, type2, { parent: this });
    const ifmt = child.#type & IFMT;
    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN2) {
      child.#type |= ENOTDIR;
    }
    c.unshift(child);
    c.provisional++;
    return child;
  }
  #readdirMaybePromoteChild(e, c) {
    for (let p = c.provisional; p < c.length; p++) {
      const pchild = c[p];
      const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
      if (name !== pchild.#matchName) {
        continue;
      }
      return this.#readdirPromoteChild(e, pchild, p, c);
    }
  }
  #readdirPromoteChild(e, p, index, c) {
    const v = p.name;
    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
    if (v !== e.name)
      p.name = e.name;
    if (index !== c.provisional) {
      if (index === c.length - 1)
        c.pop();
      else
        c.splice(index, 1);
      c.unshift(p);
    }
    c.provisional++;
    return p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(this.#fs.lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
    this.#atime = atime;
    this.#atimeMs = atimeMs;
    this.#birthtime = birthtime;
    this.#birthtimeMs = birthtimeMs;
    this.#blksize = blksize;
    this.#blocks = blocks;
    this.#ctime = ctime;
    this.#ctimeMs = ctimeMs;
    this.#dev = dev;
    this.#gid = gid;
    this.#ino = ino;
    this.#mode = mode;
    this.#mtime = mtime;
    this.#mtimeMs = mtimeMs;
    this.#nlink = nlink;
    this.#rdev = rdev;
    this.#size = size;
    this.#uid = uid;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
    if (ifmt !== UNKNOWN2 && ifmt !== IFDIR && ifmt !== IFLNK) {
      this.#type |= ENOTDIR;
    }
  }
  #onReaddirCB = [];
  #readdirCBInFlight = false;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = false;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0;
    cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb(null, []);
      else
        queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c = children.slice(0, children.provisional);
      if (allowZalgo)
        cb(null, c);
      else
        queueMicrotask(() => cb(null, c));
      return;
    }
    this.#onReaddirCB.push(cb);
    if (this.#readdirCBInFlight) {
      return;
    }
    this.#readdirCBInFlight = true;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
      if (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      } else {
        for (const e of entries) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
      return;
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight) {
      await this.#asyncReaddirInFlight;
    } else {
      let resolve = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0;
      resolve();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: true
      })) {
        this.#readdirAddChild(e, children);
      }
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return false;
    const ifmt = IFMT & this.#type;
    if (!(ifmt === UNKNOWN2 || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = await this.#fs.promises.realpath(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = this.#fs.realpathSync(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      p.#relative = rp.join(this.sep);
      p.#relativePosix = rp.join("/");
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      p.#relative = void 0;
      p.#relativePosix = void 0;
      p = p.parent;
    }
  }
};
var PathWin32 = class _PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN2, root, roots, nocase, children, opts) {
    super(name, type2, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name, type2 = UNKNOWN2, opts = {}) {
    return new _PathWin32(name, type2, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path8) {
    return import_path5.win32.parse(path8).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare, root] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare)) {
        return this.roots[rootPath] = root;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare;
  }
};
var PathPosix = class _PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN2, root, roots, nocase, children, opts) {
    super(name, type2, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path8) {
    return path8.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name, type2 = UNKNOWN2, opts = {}) {
    return new _PathPosix(name, type2, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
};
var PathScurryBase = class {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd = process.cwd(), pathImpl, sep3, { nocase, childrenCacheSize = 16 * 1024, fs: fs2 = defaultFS } = {}) {
    this.#fs = fsFromOption(fs2);
    if (cwd instanceof URL || cwd.startsWith("file://")) {
      cwd = (0, import_url.fileURLToPath)(cwd);
    }
    const cwdPath = pathImpl.resolve(cwd);
    this.roots = /* @__PURE__ */ Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    this.#resolveCache = new ResolveCache();
    this.#resolvePosixCache = new ResolveCache();
    this.#children = new ChildrenCache(childrenCacheSize);
    const split = cwdPath.substring(this.rootPath.length).split(sep3);
    if (split.length === 1 && !split[0]) {
      split.pop();
    }
    if (nocase === void 0) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(this.#fs);
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split.length - 1;
    const joinSep = pathImpl.sep;
    let abs2 = this.rootPath;
    let sawFirst = false;
    for (const part of split) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs2 += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path8 = this.cwd) {
    if (typeof path8 === "string") {
      path8 = this.cwd.resolve(path8);
    }
    return path8.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolveCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpath();
    this.#resolveCache.set(r, result);
    return result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpathPosix();
    this.#resolvePosixCache.set(r, result);
    return result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry2 = this.cwd) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    }
    return entry2.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry2 = this.cwd) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    }
    return entry2.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry2 = this.cwd) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    }
    return entry2.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry2 = this.cwd) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    }
    return (entry2.parent || entry2).fullpath();
  }
  async readdir(entry2 = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      opts = entry2;
      entry2 = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry2.canReaddir()) {
      return [];
    } else {
      const p = await entry2.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry2 = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      opts = entry2;
      entry2 = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry2.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry2.readdirSync();
    } else {
      return entry2.readdirSync().map((e) => e.name);
    }
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry2 = this.cwd) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    }
    return entry2.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry2 = this.cwd) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    }
    return entry2.lstatSync();
  }
  async readlink(entry2 = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      withFileTypes = entry2.withFileTypes;
      entry2 = this.cwd;
    }
    const e = await entry2.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry2 = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      withFileTypes = entry2.withFileTypes;
      entry2 = this.cwd;
    }
    const e = entry2.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry2 = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      withFileTypes = entry2.withFileTypes;
      entry2 = this.cwd;
    }
    const e = await entry2.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry2 = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      withFileTypes = entry2.withFileTypes;
      entry2 = this.cwd;
    }
    const e = entry2.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry2 = this.cwd, opts = {}) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      opts = entry2;
      entry2 = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry2)) {
      results.push(withFileTypes ? entry2 : entry2.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const walk2 = (dir, cb) => {
      dirs.add(dir);
      dir.readdirCB((er, entries) => {
        if (er) {
          return cb(er);
        }
        let len = entries.length;
        if (!len)
          return cb();
        const next = () => {
          if (--len === 0) {
            cb();
          }
        };
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk2(r, next) : next());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk2(e, next);
            } else {
              next();
            }
          }
        }
      }, true);
    };
    const start = entry2;
    return new Promise((res, rej) => {
      walk2(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry2 = this.cwd, opts = {}) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      opts = entry2;
      entry2 = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry2)) {
      results.push(withFileTypes ? entry2 : entry2.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set([entry2]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry2 = this.cwd, options2 = {}) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      options2 = entry2;
      entry2 = this.cwd;
    }
    return this.stream(entry2, options2)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry2 = this.cwd, opts = {}) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      opts = entry2;
      entry2 = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    if (!filter2 || filter2(entry2)) {
      yield withFileTypes ? entry2 : entry2.fullpath();
    }
    const dirs = /* @__PURE__ */ new Set([entry2]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry2 = this.cwd, opts = {}) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      opts = entry2;
      entry2 = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter2 || filter2(entry2)) {
      results.write(withFileTypes ? entry2 : entry2.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const queue = [entry2];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const onReaddir = (er, entries, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries, true));
              return;
            }
          }
          for (const e of entries) {
            if (e && (!filter2 || filter2(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process2);
          } else if (!sync2) {
            process2();
          }
        };
        let sync2 = true;
        dir.readdirCB(onReaddir, true);
        sync2 = false;
      }
    };
    process2();
    return results;
  }
  streamSync(entry2 = this.cwd, opts = {}) {
    if (typeof entry2 === "string") {
      entry2 = this.cwd.resolve(entry2);
    } else if (!(entry2 instanceof PathBase)) {
      opts = entry2;
      entry2 = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = /* @__PURE__ */ new Set();
    if (!filter2 || filter2(entry2)) {
      results.write(withFileTypes ? entry2 : entry2.fullpath());
    }
    const queue = [entry2];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing--;
        for (const e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process2);
    };
    process2();
    return results;
  }
  chdir(path8 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path8 === "string" ? this.cwd.resolve(path8) : path8;
    this.cwd[setAsCwd](oldCwd);
  }
};
var PathScurryWin32 = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, import_path5.win32, "\\", { ...opts, nocase });
    this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return import_path5.win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs2) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
};
var PathScurryPosix = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd, import_path5.posix, "/", { ...opts, nocase });
    this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs2) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
};
var PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, { ...opts, nocase });
  }
};
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/glob.js
var import_url2 = require("url");

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/pattern.js
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;
var Pattern2 = class _Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = true;
  constructor(patternList, globList, index, platform) {
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index < 0 || index >= this.length) {
      throw new TypeError("index out of range");
    }
    this.#patternList = patternList;
    this.#globList = globList;
    this.#index = index;
    this.#platform = platform;
    if (this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList;
        const [g0, g1, g2, g3, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList;
        const [g1, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] === "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    if (this.#rest !== void 0)
      return this.#rest;
    if (!this.hasMore())
      return this.#rest = null;
    this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
    this.#rest.#isAbsolute = this.#isAbsolute;
    this.#rest.#isUNC = this.#isUNC;
    this.#rest.#isDrive = this.#isDrive;
    return this.#rest;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = this.#patternList[0];
    return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
      return false;
    this.#followGlobstar = false;
    return true;
  }
};

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/ignore.js
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Ignore = class {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    const mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored) {
      const mm = new Minimatch(ign, mmopts);
      for (let i = 0; i < mm.set.length; i++) {
        const parsed = mm.set[i];
        const globParts = mm.globParts[i];
        if (!parsed || !globParts) {
          throw new Error("invalid pattern object");
        }
        const p = new Pattern2(parsed, globParts, 0, platform);
        const m = new Minimatch(p.globString(), mmopts);
        const children = globParts[globParts.length - 1] === "**";
        const absolute = p.isAbsolute();
        if (absolute)
          this.absolute.push(m);
        else
          this.relative.push(m);
        if (children) {
          if (absolute)
            this.absoluteChildren.push(m);
          else
            this.relativeChildren.push(m);
        }
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative2 = p.relative() || ".";
    const relatives = `${relative2}/`;
    for (const m of this.relative) {
      if (m.match(relative2) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative2 = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative2))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
};

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/processor.js
var HasWalkedCache = class _HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new _HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath();
    const cached = this.store.get(fullpath);
    if (cached)
      cached.add(pattern.globString());
    else
      this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
};
var MatchRecord = class {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current2 = this.store.get(target);
    this.store.set(target, current2 === void 0 ? n : n & current2);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path8, n]) => [
      path8,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
};
var SubWalks = class {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir()) {
      return;
    }
    const subs = this.store.get(target);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
};
var Processor = class _Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root) {
        t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
        const rest2 = pattern.rest();
        if (!rest2) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest2;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
        const c = t.resolve(p);
        t = c;
        pattern = rest;
        changed = true;
      }
      p = pattern.pattern();
      rest = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest?.pattern();
        const rrest = rest?.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new _Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries) {
    const patterns = this.subwalks.get(parent);
    const results = this.child();
    for (const e of entries) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest, absolute);
        } else {
          results.testString(e, p, rest, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest) {
      const rp = rest.pattern();
      if (typeof rp === "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
  testString(e, p, rest, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
};

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
var GlobUtil = class {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = false;
  aborted = false;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  constructor(patterns, path8, opts) {
    this.patterns = patterns;
    this.path = path8;
    this.opts = opts;
    this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
    if (opts.ignore) {
      this.#ignore = makeIgnore(opts.ignore, opts);
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        this.#onResume.length = 0;
      });
    }
  }
  #ignored(path8) {
    return this.seen.has(path8) || !!this.#ignore?.ignored?.(path8);
  }
  #childrenIgnored(path8) {
    return !!this.#ignore?.childrenIgnored?.(path8);
  }
  // backpressure mechanism
  pause() {
    this.paused = true;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = false;
    let fn = void 0;
    while (!this.paused && (fn = this.#onResume.shift())) {
      fn();
    }
  }
  onResume(fn) {
    if (this.signal?.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      this.#onResume.push(fn);
    }
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    const abs2 = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs2) {
      const abs3 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs3 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next);
      else {
        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
      }
    }
    next();
  }
  walkCB3(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target2, patterns, processor.child(), next);
    }
    next();
  }
  walkCBSync(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target2, patterns, processor.child(), next);
    }
    next();
  }
};
var GlobWalker = class extends GlobUtil {
  matches;
  constructor(patterns, path8, opts) {
    super(patterns, path8, opts);
    this.matches = /* @__PURE__ */ new Set();
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        if (this.signal?.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
};
var GlobStream = class extends GlobUtil {
  results;
  constructor(patterns, path8, opts) {
    super(patterns, path8, opts);
    this.results = new Minipass({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target = this.path;
    if (target.isUnknown()) {
      target.lstat().then(() => {
        this.walkCB(target, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
};

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Glob = class {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = (0, import_url2.fileURLToPath)(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== void 0) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set3, m) => {
      set3[0].push(...m.set);
      set3[1].push(...m.globParts);
      return set3;
    }, [[], []]);
    this.patterns = matchSet.map((set3, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern2(set3, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/has-magic.js
var hasMagic = (pattern, options2 = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options2).hasMagic())
      return true;
  }
  return false;
};

// ../../node_modules/.pnpm/glob@10.3.10/node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options2 = {}) {
  return new Glob(pattern, options2).streamSync();
}
function globStream(pattern, options2 = {}) {
  return new Glob(pattern, options2).stream();
}
function globSync(pattern, options2 = {}) {
  return new Glob(pattern, options2).walkSync();
}
async function glob_(pattern, options2 = {}) {
  return new Glob(pattern, options2).walk();
}
function globIterateSync(pattern, options2 = {}) {
  return new Glob(pattern, options2).iterateSync();
}
function globIterate(pattern, options2 = {}) {
  return new Glob(pattern, options2).iterate();
}
var streamSync = globStreamSync;
var stream = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape: unescape2
});
glob.glob = glob;

// ../cursorless-engine/src/util/grammarHelpers.ts
var import_lodash57 = __toESM(require_lodash(), 1);
var UNUSED = Symbol("unused");
var ArgPosition = class {
  constructor(position) {
    this.position = position;
  }
};
var argPositions = {
  $0: new ArgPosition(0),
  $1: new ArgPosition(1),
  $2: new ArgPosition(2)
};

// ../neovim-registry/src/NeovimRegistry.ts
var import_node_events = require("node:events");
var NeovimRegistry = class {
  constructor() {
    this.apis = /* @__PURE__ */ new Map();
    this.commands = /* @__PURE__ */ new Map();
    this.eventEmitter = new import_node_events.EventEmitter();
  }
  registerExtensionApi(extensionId, api) {
    this.apis.set(extensionId, api);
  }
  getExtensionApi(extensionId) {
    return this.apis.get(extensionId);
  }
  registerCommand(commandId, callback2) {
    this.commands.set(commandId, callback2);
  }
  async executeCommand(commandId, ...rest) {
    return await this.commands.get(commandId)(...rest);
  }
  onEvent(eventName, listener) {
    return this.eventEmitter.on(eventName, listener);
  }
  emitEvent(eventName, ...args) {
    return this.eventEmitter.emit(eventName, ...args);
  }
};

// ../neovim-registry/src/index.ts
function getNeovimRegistry() {
  if (global._neovimRegistry == null) {
    global._neovimRegistry = new NeovimRegistry();
  }
  return global._neovimRegistry;
}

// ../neovim-common/src/getExtensionApi.ts
var EXTENSION_ID = "pokey.cursorless";

// ../neovim-common/src/neovimApi.ts
async function bufferGetSelections(window2, client) {
  const luaCode = `return require("cursorless.cursorless").buffer_get_selection()`;
  const [startLine, startCol, endLine, endCol, reverse] = await client.executeLua(luaCode, []);
  let selections;
  if (reverse === true) {
    selections = [
      new Selection(
        new Position(endLine - 1, endCol - 1),
        new Position(startLine - 1, startCol - 1)
      )
    ];
  } else {
    selections = [
      new Selection(
        new Position(startLine - 1, startCol - 1),
        new Position(endLine - 1, endCol - 1)
      )
    ];
  }
  console.debug(
    `bufferGetSelections(): selections=(${selections[0].start.line}, ${selections[0].start.character}), (${selections[0].end.line}, ${selections[0].end.character}) neovim=(${startLine},${startCol}),(${endLine},${endCol}),reverse=${reverse}`
  );
  return selections;
}
async function bufferSetSelections(client, selections) {
  if (selections.length !== 1) {
    throw new Error("bufferSetSelections() only supports one selection");
  }
  const luaCode = `return require("cursorless.cursorless").select_range(${selections[0].start.line + 1}, ${selections[0].start.character}, ${selections[0].end.line + 1}, ${selections[0].end.character})`;
  console.debug(
    `bufferSetSelections() selections=(${selections[0].start.line},${selections[0].start.character}),(${selections[0].end.line},${selections[0].end.character}) luaCode="${luaCode}"`
  );
  await client.executeLua(luaCode, []);
}
async function windowGetVisibleRanges(window2, client, lines) {
  const luaCode = `return require("cursorless.cursorless").window_get_visible_lines()`;
  const [firstLine, lastLine] = await client.executeLua(luaCode, []);
  const range4 = new Range(
    new Position(firstLine - 1, 0),
    // subtract -1 to the line.length to get the correct 0-based column number
    new Position(lastLine - 1, lines[lastLine - 1].length - 1)
  );
  console.debug(
    `windowGetVisibleRanges(): range=(${range4.start.line}, ${range4.start.character}), (${range4.end.line}, ${range4.end.character})`
  );
  return [range4];
}
async function getCursorlessNvimPath(client) {
  const luaCode = `return require("cursorless.utils").cursorless_nvim_path()`;
  const data = await client.executeLua(luaCode, []);
  return data;
}
async function putToClipboard(data, client) {
  await client.callFunction("setreg", ["*", data]);
}
async function getFromClipboard(client) {
  return await client.callFunction("getreg", ["*"]);
}
async function pasteFromClipboard(client) {
  const luaCode = `return require("cursorless.utils").paste()`;
  await client.executeLua(luaCode, []);
}
async function modeSwitchNormalTerminal(client) {
  const luaCode = `return require("cursorless.utils").mode_switch_nt()`;
  await client.executeLua(luaCode, []);
}
async function modeSwitchTerminal(client) {
  const luaCode = `return require("cursorless.utils").mode_switch_t()`;
  await client.executeLua(luaCode, []);
}
async function showErrorMessage(client, message) {
  const luaCode = `vim.notify("${message}")`;
  await client.executeLua(luaCode, []);
}

// ../neovim-common/src/ide/neovim/NeovimCapabilities.ts
var COMMAND_CAPABILITIES = {
  clipboardCopy: { acceptsLocation: false },
  toggleLineComment: void 0,
  indentLine: void 0,
  outdentLine: void 0,
  rename: void 0,
  quickFix: void 0,
  revealDefinition: void 0,
  revealTypeDefinition: void 0,
  showHover: void 0,
  showDebugHover: void 0,
  extractVariable: void 0,
  fold: void 0,
  highlight: { acceptsLocation: true },
  unfold: void 0,
  showReferences: void 0
};
var NeovimCapabilities = class {
  constructor() {
    this.commands = COMMAND_CAPABILITIES;
  }
};

// ../neovim-common/src/ide/neovim/NeovimClipboard.ts
var NeovimClipboard = class {
  constructor(client) {
    this.client = client;
  }
  async readText() {
    return await getFromClipboard(this.client);
  }
  async writeText(value) {
    return await putToClipboard(value, this.client);
  }
};

// ../neovim-common/src/ide/neovim/NeovimConfiguration.ts
var import_lodash58 = __toESM(require_lodash(), 1);
var NeovimConfiguration = class {
  constructor() {
    this.notifier = new Notifier();
    this.mocks = {
      ...CONFIGURATION_DEFAULTS
    };
    this.scopes = [];
    this.onDidChangeConfiguration = this.notifier.registerListener;
    this.onDidChangeConfiguration = this.onDidChangeConfiguration.bind(this);
  }
  getOwnConfiguration(path8, scope) {
    if (scope != null) {
      for (const { scope: candidateScope, values: values2 } of this.scopes) {
        if (scopeMatches2(candidateScope, scope)) {
          return (0, import_lodash58.get)(values2, path8) ?? (0, import_lodash58.get)(this.mocks, path8);
        }
      }
    }
    return (0, import_lodash58.get)(this.mocks, path8);
  }
  mockConfiguration(key, value) {
    this.mocks[key] = value;
    this.notifier.notifyListeners();
  }
  mockConfigurationScope(scope, values2, noNotification = false) {
    this.scopes.push({ scope, values: values2 });
    if (!noNotification) {
      this.notifier.notifyListeners();
    }
  }
};
function scopeMatches2(candidateScope, scope) {
  return candidateScope.languageId === scope.languageId;
}

// ../neovim-common/src/ide/neovim/NeovimEdit.ts
async function neovimEdit(client, neovimIDE, window2, edits) {
  console.debug("neovimEdit() [unsorted]:");
  for (const edit of edits) {
    console.debug(
      `	range=${JSON.stringify(edit.range)}, text='${edit.text}', isReplace=${edit.isReplace}`
    );
  }
  edits.sort((a, b) => {
    if ((isInsert(a) || isReplace2(a)) && (isInsert(b) || isReplace2(b))) {
      return 1;
    }
    if (a.range.start.line === b.range.start.line) {
      return b.range.start.character - a.range.start.character;
    }
    return b.range.start.line - a.range.start.line;
  });
  console.debug("neovimEdit() [sorted]:");
  for (const edit of edits) {
    console.debug(
      `	range=${JSON.stringify(edit.range)}, text='${edit.text}', isReplace=${edit.isReplace}`
    );
  }
  const document = neovimIDE.getTextDocument(
    await client.window.buffer
  );
  const changes = [];
  for (const edit of edits) {
    changes.push({
      range: edit.range,
      rangeOffset: document.offsetAt(edit.range.start),
      rangeLength: document.offsetAt(edit.range.end) - document.offsetAt(edit.range.start),
      text: edit.text
    });
  }
  getNeovimRegistry().emitEvent("onDidChangeTextDocument", {
    document,
    contentChanges: changes
  });
  for (const edit of edits) {
    const { range: range4, text, isReplace: isReplace3 } = edit;
    if (text === "") {
      await neovimDelete(client, range4);
    } else if (range4.isEmpty && !isReplace3) {
      await neovimInsert(client, range4.start, text);
    } else {
      await neovimReplace(client, range4, text);
    }
  }
  await neovimIDE.updateTextEditor();
  return true;
}
async function neovimDelete(client, range4) {
  console.debug(`neovimDelete(): range=${JSON.stringify(range4)}`);
  const buffer = await client.window.buffer;
  const lastLine = (await buffer.getLines({
    start: range4.end.line,
    end: range4.end.line + 1,
    strictIndexing: true
  }))[0];
  const endOfLastLine = lastLine.slice(range4.end.character);
  if (range4.start.line === range4.end.line) {
    const singleLine = lastLine.slice(0, range4.start.character) + endOfLastLine;
    await buffer.setLines(singleLine, {
      start: range4.start.line,
      end: range4.start.line + 1,
      strictIndexing: true
    });
    return;
  }
  if (range4.start.character === 0) {
    await buffer.setLines(endOfLastLine, {
      start: range4.start.line,
      end: range4.end.line + 1,
      strictIndexing: true
    });
    return;
  }
  const firstLine = (await buffer.getLines({
    start: range4.start.line,
    end: range4.start.line + 1,
    strictIndexing: true
  }))[0];
  const startOfFirstLine = firstLine.slice(0, range4.start.character);
  if (range4.start.character <= firstLine.length) {
    await buffer.setLines(startOfFirstLine + endOfLastLine, {
      start: range4.start.line,
      end: range4.end.line + 1,
      strictIndexing: true
    });
    return;
  }
  await buffer.setLines([startOfFirstLine, endOfLastLine], {
    start: range4.start.line,
    end: range4.end.line + 1,
    strictIndexing: true
  });
}
async function neovimInsert(client, position, text) {
  console.debug(
    `neovimInsert(): position=${JSON.stringify(position)}, text='${text}'`
  );
  const newLines = text.replace(/(?:\r\n|\r|\n)/g, "\n").split("\n");
  const buffer = await client.window.buffer;
  const lineWhereInsertion = (await buffer.getLines({
    start: position.line,
    end: position.line + 1,
    strictIndexing: true
  }))[0];
  const startOfFirstLine = lineWhereInsertion.slice(0, position.character);
  const endOfLastLine = lineWhereInsertion.slice(position.character);
  if (newLines.length == 1) {
    const singleLine = startOfFirstLine + newLines[0] + endOfLastLine;
    await buffer.setLines(singleLine, {
      start: position.line,
      end: position.line + 1,
      strictIndexing: true
    });
    return;
  }
  const firstLine = startOfFirstLine + newLines[0];
  const lastLine = newLines[newLines.length - 1] + endOfLastLine;
  await buffer.setLines(
    [firstLine, ...newLines.slice(1, newLines.length - 1), lastLine],
    {
      start: position.line,
      end: position.line + 1,
      strictIndexing: true
    }
  );
}
async function neovimReplace(client, range4, text) {
  console.debug(
    `neovimReplace(): range=${JSON.stringify(range4)}, text='${text}'`
  );
  await neovimDelete(client, range4);
  await neovimInsert(client, range4.start, text);
}
function isInsert(edit) {
  return edit.range.isEmpty && !edit.isReplace;
}
function isReplace2(edit) {
  return edit.text !== "" && (!edit.range.isEmpty || edit.isReplace ? true : false);
}

// ../neovim-common/src/ide/neovim/NeovimEvents.ts
function neovimOnDidChangeTextDocument(listener) {
  getNeovimRegistry().onEvent("onDidChangeTextDocument", listener);
  return dummyEvent2();
}
function neovimOnDidOpenTextDocument(listener, thisArgs, disposables) {
  getNeovimRegistry().onEvent("onDidOpenTextDocument", listener);
  return dummyEvent2();
}
function dummyEvent2() {
  return {
    dispose() {
    }
  };
}

// ../neovim-common/src/ide/neovim/NeovimFileSystem.ts
var import_path6 = require("path");
var fs = __toESM(require("fs"), 1);
var NeovimFileSystem = class {
  constructor(runMode, cursorlessDir) {
    this.runMode = runMode;
    this.cursorlessDir = cursorlessDir;
    this.cursorlessTalonStateJsonPath = (0, import_path6.join)(this.cursorlessDir, "state.json");
    this.cursorlessCommandHistoryDirPath = (0, import_path6.join)(
      this.cursorlessDir,
      "commandHistory"
    );
  }
  async initialize() {
    if (!fs.existsSync(this.cursorlessDir)) {
      try {
        fs.mkdirSync(this.cursorlessDir);
      } catch (err) {
        console.debug("Cannot create cursorlessDir", this.cursorlessDir, err);
      }
    }
  }
  /**
   * Reads a file that comes bundled with Cursorless, with the utf-8 encoding.
   * {@link path} is expected to be relative to the root of the extension
   * bundle. If the file doesn't exist, returns `undefined`.
   *
   * Note that in development mode, it is possible to supply an absolute path to
   * a file on the local filesystem, for things like hot-reloading.
   *
   * @param path The path of the file to read
   * @returns The contents of path, decoded as UTF-8
   */
  async readBundledFile(path8) {
    console.debug("readBundledFile() Not implemented");
    return void 0;
  }
  resolveBundledPath(path8) {
    throw Error("resolveBundledPath() Not implemented");
  }
  watchDir(path8, onDidChange) {
    return dummyEvent3();
  }
};
function dummyEvent3() {
  return {
    dispose() {
    }
  };
}

// ../neovim-common/src/ide/neovim/NeovimGlobalState.ts
var NeovimGlobalState = class {
  constructor() {
    this.data = { ...STATE_DEFAULTS };
  }
  get(key) {
    return this.data[key];
  }
  set(key, value) {
    this.data[key] = value;
    return Promise.resolve();
  }
};

// ../neovim-common/src/ide/neovim/NeovimIDE.ts
var import_lodash59 = __toESM(require_lodash(), 1);

// ../neovim-common/src/ide/neovim/NeovimMessages.ts
var NeovimMessages = class {
  async showMessage(_type, _id, _message, ..._options) {
    return void 0;
  }
};

// ../neovim-common/src/neovimHelpers.ts
async function neovimClipboardCopy(client, ide2) {
  const editor = ide2.activeTextEditor;
  const window2 = await client.window;
  const selections = await bufferGetSelections(window2, client);
  const data = editor.document.getText(selections[0]);
  await putToClipboard(data, client);
}
async function neovimClipboardPaste(client, ide2) {
  await pasteFromClipboard(client);
}

// ../neovim-common/src/ide/neovim/NeovimTextEditorImpl.ts
var NeovimTextEditorImpl = class {
  constructor(id, client, neovimIDE, window2, doc, visibleRanges, selections) {
    this.id = id;
    this.client = client;
    this.neovimIDE = neovimIDE;
    this.window = window2;
    this._document = doc;
    this._selections = selections;
    this._visibleRanges = visibleRanges;
  }
  get document() {
    return this._document;
  }
  updateDocument(visibleRanges, selections, doc, lines) {
    if (doc) {
      this._document = doc;
    } else if (lines) {
      this._document.update(lines);
    } else {
      throw Error("updateDocument(): invalid arguments");
    }
    this._selections = selections;
    this._visibleRanges = visibleRanges;
    return this._document;
  }
  get selections() {
    return this._selections;
  }
  async setSelections(selections) {
    this._selections = selections;
    await bufferSetSelections(this.client, selections);
  }
  get visibleRanges() {
    return this._visibleRanges;
  }
  get options() {
    throw Error("get options Not implemented");
  }
  set options(options2) {
    throw Error("set options Not implemented");
  }
  get isActive() {
    return true;
  }
  isEqual(other) {
    return this.id === other.id;
  }
  async revealRange(range4) {
  }
  revealLine(lineNumber, at) {
    throw Error("revealLine Not implemented");
  }
  async edit(edits) {
    return await neovimEdit(this.client, this.neovimIDE, this.window, edits);
  }
  focus() {
    return Promise.resolve();
  }
  editNewNotebookCellAbove() {
    throw Error("editNewNotebookCellAbove Not implemented");
  }
  editNewNotebookCellBelow() {
    throw Error("editNewNotebookCellBelow Not implemented");
  }
  openLink(location) {
    throw Error("openLink Not implemented");
  }
  fold(ranges) {
    throw Error("fold Not implemented");
  }
  unfold(ranges) {
    throw Error("unfold Not implemented");
  }
  toggleBreakpoint(descriptors) {
    throw Error("toggleBreakpoint Not implemented");
  }
  async toggleLineComment(_ranges) {
    throw Error("toggleLineComment Not implemented");
  }
  async clipboardCopy(_ranges) {
    await neovimClipboardCopy(this.client, this.neovimIDE);
  }
  async clipboardPaste(_ranges) {
    await neovimClipboardPaste(this.client, this.neovimIDE);
  }
  async indentLine(_ranges) {
    throw Error("indentLine Not implemented");
  }
  async outdentLine(_ranges) {
    throw Error("outdentLine Not implemented");
  }
  async insertLineAfter(ranges) {
    throw Error("insertLineAfter Not implemented");
  }
  insertSnippet(snippet2, ranges) {
    throw Error("insertSnippet Not implemented");
  }
  async rename(_range) {
    throw Error("rename Not implemented");
  }
  async showReferences(_range) {
    throw Error("showReferences Not implemented");
  }
  async quickFix(_range) {
    throw Error("quickFix Not implemented");
  }
  async revealDefinition(_range) {
    throw Error("revealDefinition Not implemented");
  }
  async revealTypeDefinition(_range) {
    throw Error("revealTypeDefinition Not implemented");
  }
  async showHover(_range) {
    throw Error("showHover Not implemented");
  }
  async showDebugHover(_range) {
    throw Error("showDebugHover Not implemented");
  }
  async extractVariable(_range) {
    throw Error("extractVariable Not implemented");
  }
};

// ../neovim-common/src/ide/neovim/NeovimIDE.ts
var import_path7 = __toESM(require("path"), 1);

// ../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  "use strict";
  var t = { 470: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3)
        throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {
        if (h < t3.length)
          r3 = t3.charCodeAt(h);
        else {
          if (47 === r3)
            break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o === h - 1 || 1 === s)
            ;
          else if (o !== h - 1 && 2 === s) {
            if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a = n3.lastIndexOf("/");
                if (a !== n3.length - 1) {
                  -1 === a ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf("/"), o = h, s = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i = 0, o = h, s = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
          } else
            n3.length > 0 ? n3 += "/" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;
          o = h, s = 0;
        } else
          46 === r3 && -1 !== s ? ++s : s = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
        var s;
        o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
      }
      return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length)
        return ".";
      var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length)
        return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i = arguments[r3];
        e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3)
        return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
        return "";
      for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i)
        ;
      for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h)
        ;
      for (var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u) {
        if (u === c) {
          if (a > c) {
            if (47 === r3.charCodeAt(h + u))
              return r3.slice(h + u + 1);
            if (0 === u)
              return r3.slice(h + u);
          } else
            s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
          break;
        }
        var l = t3.charCodeAt(i + u);
        if (l !== r3.charCodeAt(h + u))
          break;
        47 === l && (f = u);
      }
      var g = "";
      for (u = i + f + 1; u <= o; ++u)
        u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
      return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length)
        return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s)
        if (47 === (r3 = t3.charCodeAt(s))) {
          if (!o) {
            i = s;
            break;
          }
        } else
          o = false;
      return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3)
        throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i = 0, o = -1, s = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3)
          return "";
        var h = r3.length - 1, a = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c = t3.charCodeAt(n3);
          if (47 === c) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else
            -1 === a && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a));
        }
        return i === o ? o = a : -1 === o && (o = t3.length), t3.slice(i, o);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3)
        if (47 === t3.charCodeAt(n3)) {
          if (!s) {
            i = n3 + 1;
            break;
          }
        } else
          -1 === o && (s = false, o = n3 + 1);
      return -1 === o ? "" : t3.slice(i, o);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {
        var a = t3.charCodeAt(h);
        if (47 !== a)
          -1 === i && (o = false, i = h + 1), 46 === a ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
        else if (!o) {
          n3 = h + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3)
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      }(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length)
        return r3;
      var n3, i = t3.charCodeAt(0), o = 47 === i;
      o ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
        if (47 !== (i = t3.charCodeAt(f)))
          -1 === a && (c = false, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
        else if (!c) {
          h = f + 1;
          break;
        }
      return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a) : t3.slice(h, a)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i = e[n2];
    if (void 0 !== i)
      return i.exports;
    var o = e[n2] = { exports: {} };
    return t[n2](o, o.exports, r), o.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2)
      r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  (() => {
    let t2;
    if (r.r(n), r.d(n, { URI: () => f, Utils: () => P }), "object" == typeof process)
      t2 = "win32" === process.platform;
    else if ("object" == typeof navigator) {
      let e3 = navigator.userAgent;
      t2 = e3.indexOf("Windows") >= 0;
    }
    const e2 = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
    function s(t3, r2) {
      if (!t3.scheme && r2)
        throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
      if (t3.scheme && !e2.test(t3.scheme))
        throw new Error("[UriError]: Scheme contains illegal characters.");
      if (t3.path) {
        if (t3.authority) {
          if (!i.test(t3.path))
            throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (o.test(t3.path))
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    class f {
      static isUri(t3) {
        return t3 instanceof f || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
      }
      scheme;
      authority;
      path;
      query;
      fragment;
      constructor(t3, e3, r2, n2, i2, o2 = false) {
        "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ function(t4, e4) {
          return t4 || e4 ? t4 : "file";
        }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
          switch (t4) {
            case "https":
            case "http":
            case "file":
              e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;
          }
          return e4;
        }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));
      }
      get fsPath() {
        return m(this, false);
      }
      with(t3) {
        if (!t3)
          return this;
        let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;
        return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);
      }
      static parse(t3, e3 = false) {
        const r2 = c.exec(t3);
        return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);
      }
      static file(e3) {
        let r2 = h;
        if (t2 && (e3 = e3.replace(/\\/g, a)), e3[0] === a && e3[1] === a) {
          const t3 = e3.indexOf(a, 2);
          -1 === t3 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);
        }
        return new l("file", r2, e3, h, h);
      }
      static from(t3) {
        const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
        return s(e3, true), e3;
      }
      toString(t3 = false) {
        return y(this, t3);
      }
      toJSON() {
        return this;
      }
      static revive(t3) {
        if (t3) {
          if (t3 instanceof f)
            return t3;
          {
            const e3 = new l(t3);
            return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;
          }
        }
        return t3;
      }
    }
    const u = t2 ? 1 : void 0;
    class l extends f {
      _formatted = null;
      _fsPath = null;
      get fsPath() {
        return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;
      }
      toString(t3 = false) {
        return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
      }
      toJSON() {
        const t3 = { $mid: 1 };
        return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
      }
    }
    const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function d(t3, e3, r2) {
      let n2, i2 = -1;
      for (let o2 = 0; o2 < t3.length; o2++) {
        const s2 = t3.charCodeAt(o2);
        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2)
          -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));
        else {
          void 0 === n2 && (n2 = t3.substr(0, o2));
          const e4 = g[s2];
          void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);
        }
      }
      return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;
    }
    function p(t3) {
      let e3;
      for (let r2 = 0; r2 < t3.length; r2++) {
        const n2 = t3.charCodeAt(r2);
        35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);
      }
      return void 0 !== e3 ? e3 : t3;
    }
    function m(e3, r2) {
      let n2;
      return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
    }
    function y(t3, e3) {
      const r2 = e3 ? p : d;
      let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;
      if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += a, n2 += a), o2) {
        let t4 = o2.indexOf("@");
        if (-1 !== t4) {
          const e4 = o2.substr(0, t4);
          o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += ":", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += "@";
        }
        o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));
      }
      if (s2) {
        if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
          const t4 = s2.charCodeAt(1);
          t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
        } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
          const t4 = s2.charCodeAt(0);
          t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
        }
        n2 += r2(s2, true, false);
      }
      return h2 && (n2 += "?", n2 += r2(h2, false, false)), c2 && (n2 += "#", n2 += e3 ? c2 : d(c2, false, false)), n2;
    }
    function v(t3) {
      try {
        return decodeURIComponent(t3);
      } catch {
        return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;
      }
    }
    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function C(t3) {
      return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;
    }
    var A = r(470);
    const w = A.posix || A, x = "/";
    var P;
    !function(t3) {
      t3.joinPath = function(t4, ...e3) {
        return t4.with({ path: w.join(t4.path, ...e3) });
      }, t3.resolvePath = function(t4, ...e3) {
        let r2 = t4.path, n2 = false;
        r2[0] !== x && (r2 = x + r2, n2 = true);
        let i2 = w.resolve(r2, ...e3);
        return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
      }, t3.dirname = function(t4) {
        if (0 === t4.path.length || t4.path === x)
          return t4;
        let e3 = w.dirname(t4.path);
        return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
      }, t3.basename = function(t4) {
        return w.basename(t4.path);
      }, t3.extname = function(t4) {
        return w.extname(t4.path);
      };
    }(P || (P = {}));
  })(), LIB = n;
})();
var { URI, Utils } = LIB;

// ../neovim-common/src/ide/neovim/NeovimTextLineImpl.ts
var NeovimTextLineImpl = class {
  constructor(lineNumber, text, isLastLine) {
    this._lineNumber = lineNumber;
    this._text = text;
    this._isLastLine = isLastLine;
  }
  get lineNumber() {
    return this._lineNumber;
  }
  get text() {
    return this._text;
  }
  get range() {
    return new Range(this._lineNumber, 0, this._lineNumber, this._text.length);
  }
  get rangeIncludingLineBreak() {
    if (this._isLastLine) {
      return this.range;
    }
    return new Range(this._lineNumber, 0, this._lineNumber + 1, 0);
  }
  get firstNonWhitespaceCharacterIndex() {
    const index = /^(\s*)/.exec(this._text)[1].length;
    return index;
  }
  get lastNonWhitespaceCharacterIndex() {
    const index = this.text.trimEnd().length;
    return index;
  }
  get isEmptyOrWhitespace() {
    return this.firstNonWhitespaceCharacterIndex === this._text.length;
  }
};

// ../neovim-common/src/ide/neovim/NeovimTextDocumentImpl.ts
var NeovimTextDocumentImpl = class {
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  get lineCount() {
    return this._lineCount;
  }
  get range() {
    const { end } = this.lineAt(this.lineCount - 1).range;
    const range4 = new Range(0, 0, end.line, end.character);
    return range4;
  }
  get eol() {
    return this._eol === "\n" ? "LF" : "CRLF";
  }
  constructor(uri, languageId, version2, eol, lines) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version2;
    this._eol = eol;
    this._lines = lines;
    this._lineCount = lines.length;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  update(lines) {
    this._lines = lines;
    this._lineCount = lines.length;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  lineAt(lineOrPosition) {
    let line;
    if (lineOrPosition instanceof Position) {
      line = lineOrPosition.line;
    } else if (typeof lineOrPosition === "number") {
      line = lineOrPosition;
    }
    if (typeof line !== "number" || line < 0 || line >= this._lines.length || Math.floor(line) !== line) {
      throw new Error("Illegal value for `line`");
    }
    return new NeovimTextLineImpl(
      line,
      this._lines[line],
      line === this._lines.length - 1
    );
  }
  offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getPrefixSum(position.line - 1) + position.character;
  }
  positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    const out = this._lineStarts.getIndexOf(offset);
    const lineLength = this._lines[out.index].length;
    return new Position(out.index, Math.min(out.remainder, lineLength));
  }
  getText(range4) {
    if (range4 === void 0) {
      if (this._cachedTextValue == null) {
        this._cachedTextValue = this._lines.join(this._eol);
      }
      return this._cachedTextValue;
    } else {
    }
    range4 = this._validateRange(range4);
    if (range4.isEmpty) {
      return "";
    }
    if (range4.isSingleLine) {
      return this._lines[range4.start.line].substring(
        range4.start.character,
        range4.end.character
      );
    }
    const lineEnding = this._eol, startLineIndex = range4.start.line, endLineIndex = range4.end.line, resultLines = [];
    resultLines.push(
      this._lines[startLineIndex].substring(range4.start.character)
    );
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(
      this._lines[endLineIndex].substring(0, range4.end.character)
    );
    return resultLines.join(lineEnding);
  }
  // ---- range math
  _validateRange(range4) {
    if (!(range4 instanceof Range)) {
      throw new Error("Invalid argument");
    }
    const start = this._validatePosition(range4.start);
    const end = this._validatePosition(range4.end);
    if (start === range4.start && end === range4.end) {
      return range4;
    }
    return new Range(start.line, start.character, end.line, end.character);
  }
  _validatePosition(position) {
    if (!(position instanceof Position)) {
      throw new Error("Invalid argument");
    }
    if (this._lines.length === 0) {
      return position.with(0, 0);
    }
    let { line, character } = position;
    let hasChanged = false;
    if (line < 0) {
      line = 0;
      character = 0;
      hasChanged = true;
    } else if (line >= this._lines.length) {
      line = this._lines.length - 1;
      character = this._lines[line].length;
      hasChanged = true;
    } else {
      const maxCharacter = this._lines[line].length;
      if (character < 0) {
        character = 0;
        hasChanged = true;
      } else if (character > maxCharacter) {
        character = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    }
    return new Position(line, character);
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const eolLength = this._eol.length;
      const linesLength = this._lines.length;
      const lineStartValues = new Uint32Array(linesLength);
      for (let i = 0; i < linesLength; i++) {
        lineStartValues[i] = this._lines[i].length + eolLength;
      }
      this._lineStarts = new PrefixSumComputer(lineStartValues);
    }
  }
};
function toUint32(v) {
  if (v < 0) {
    return 0;
  }
  const maxUint32 = 4294967295;
  if (v > maxUint32) {
    return maxUint32;
  }
  return v | 0;
}
var PrefixSumComputer = class {
  constructor(values2) {
    this.values = values2;
    this.prefixSum = new Uint32Array(values2.length);
    this.prefixSumValidIndex = new Int32Array(1);
    this.prefixSumValidIndex[0] = -1;
  }
  getCount() {
    return this.values.length;
  }
  getTotalSum() {
    if (this.values.length === 0) {
      return 0;
    }
    return this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(index) {
    if (index < 0) {
      return 0;
    }
    index = toUint32(index);
    return this._getPrefixSum(index);
  }
  _getPrefixSum(index) {
    if (index <= this.prefixSumValidIndex[0]) {
      return this.prefixSum[index];
    }
    let startIndex = this.prefixSumValidIndex[0] + 1;
    if (startIndex === 0) {
      this.prefixSum[0] = this.values[0];
      startIndex++;
    }
    if (index >= this.values.length) {
      index = this.values.length - 1;
    }
    for (let i = startIndex; i <= index; i++) {
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    }
    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
    return this.prefixSum[index];
  }
  getIndexOf(sum2) {
    sum2 = Math.floor(sum2);
    this.getTotalSum();
    let low = 0;
    let high = this.values.length - 1;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStop = this.prefixSum[mid];
      midStart = midStop - this.values[mid];
      if (sum2 < midStart) {
        high = mid - 1;
      } else if (sum2 >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    return new PrefixSumIndexOfResult(mid, sum2 - midStart);
  }
};
var PrefixSumIndexOfResult = class {
  constructor(index, remainder) {
    this.index = index;
    this.remainder = remainder;
    this._prefixSumIndexOfResultBrand = void 0;
    this.index = index;
    this.remainder = remainder;
  }
};

// ../neovim-common/src/ide/neovim/NeovimIDE.ts
var NeovimIDE = class {
  constructor(client) {
    this.client = client;
    this.cursorlessVersion = "0.0.0";
    this.workspaceFolders = void 0;
    this.disposables = [];
    this.quickPickReturnValue = void 0;
    this.onDidCloseTextDocument = dummyEvent4;
    this.onDidChangeActiveTextEditor = dummyEvent4;
    this.onDidChangeVisibleTextEditors = dummyEvent4;
    this.onDidChangeTextEditorSelection = dummyEvent4;
    this.onDidChangeTextEditorVisibleRanges = dummyEvent4;
    this.configuration = new NeovimConfiguration();
    this.globalState = new NeovimGlobalState();
    this.messages = new NeovimMessages();
    this.clipboard = new NeovimClipboard(this.client);
    this.capabilities = new NeovimCapabilities();
    this.editorMap = /* @__PURE__ */ new Map();
    this.documentMap = /* @__PURE__ */ new Map();
    this.activeWindow = void 0;
    this.activeBuffer = void 0;
  }
  async init() {
    const rootPath = await getCursorlessNvimPath(this.client);
    this.assetsRoot_ = import_path7.default.join(rootPath, "assets");
    this.cursorlessNeovimPath = import_path7.default.join(
      rootPath,
      "node",
      "cursorless-neovim"
    );
  }
  async showQuickPick(_items, _options) {
    throw Error("showQuickPick Not implemented");
  }
  async setHighlightRanges(_highlightId, _editor, _ranges) {
    throw Error("setHighlightRanges Not implemented");
  }
  async flashRanges(_flashDescriptors) {
    console.debug("flashRanges Not implemented");
  }
  get assetsRoot() {
    if (this.assetsRoot_ == null) {
      throw Error("Field `assetsRoot` has not yet been mocked");
    }
    return this.assetsRoot_;
  }
  // See https://code.visualstudio.com/api/references/vscode-api#ExtensionMode
  get runMode() {
    const runMode = process.env.CURSORLESS_MODE;
    const ret = runMode == null ? "production" : runMode === "test" ? "test" : runMode == "development" ? "development" : "unknown";
    if (ret === "unknown") {
      throw Error("Invalid runMode");
    }
    return ret;
  }
  get activeTextEditor() {
    return this.getActiveTextEditor();
  }
  get activeEditableTextEditor() {
    return this.getActiveTextEditor();
  }
  getActiveTextEditor() {
    const editor = this.activeWindow ? this.getTextEditor(this.activeWindow) : void 0;
    if (editor === void 0) {
      console.debug("getActiveTextEditor: editor is undefined");
    }
    return editor;
  }
  getTextEditor(w) {
    for (const [window2, textEditor] of this.editorMap) {
      if (window2.id === w.id) {
        return textEditor;
      }
    }
    return void 0;
  }
  getTextDocument(b) {
    for (const [buffer, textDocument] of this.documentMap) {
      if (buffer.id === b.id) {
        return textDocument;
      }
    }
    return void 0;
  }
  get visibleTextEditors() {
    return Array.from(this.editorMap.values());
  }
  getEditableTextEditor(editor) {
    return editor;
  }
  async findInDocument(_query, _editor) {
    throw Error("findInDocument Not implemented");
  }
  async findInWorkspace(_query) {
    throw Error("findInWorkspace Not implemented");
  }
  async openTextDocument(_path) {
    throw Error("openTextDocument Not implemented");
  }
  async openUntitledTextDocument(_options) {
    throw Error("openUntitledTextDocument Not implemented");
  }
  async showInputBox(_options) {
    throw Error("TextDocumentChangeEvent Not implemented");
  }
  async executeCommand(_command, ..._args) {
    throw new Error("executeCommand Method not implemented.");
  }
  onDidChangeTextDocument(listener) {
    return neovimOnDidChangeTextDocument(listener);
  }
  onDidOpenTextDocument(listener, thisArgs, disposables) {
    return neovimOnDidOpenTextDocument(listener, thisArgs, disposables);
  }
  /**
   * Initialize the current editor (and current document).
   * If the current editor already exists, it will only update the current document of that editor.
   *
   * when we receive our first cursorless command, we will initialize an editor an document for it.
   * for the following commands, we will only update the document.
   *
   * Atm, we only initialize one editor(current window) with one document(current buffer)
   */
  async updateTextEditor(minimal = false) {
    const window2 = await this.client.window;
    const buffer = await window2.buffer;
    const lines = await buffer.lines;
    let linesShown = lines;
    if (lines.length >= 30) {
      linesShown = lines.slice(0, 15).concat(["..."]).concat(lines.slice(-15));
    }
    console.debug(
      `updateTextEditor(): window:${window2.id}, buffer:${buffer.id}, lines=${JSON.stringify(linesShown)}`
    );
    let selections;
    let visibleRanges;
    if (!minimal) {
      selections = await bufferGetSelections(window2, this.client);
      visibleRanges = await windowGetVisibleRanges(window2, this.client, lines);
    } else {
      selections = [];
      visibleRanges = [];
    }
    const editor = this.toNeovimEditor(
      window2,
      buffer,
      lines,
      visibleRanges,
      selections
    );
    getNeovimRegistry().emitEvent("onDidOpenTextDocument", editor.document);
    return editor;
  }
  toNeovimEditor(window2, buffer, lines, visibleRanges, selections) {
    let document = this.getTextDocument(buffer);
    let editor = this.getTextEditor(window2);
    if (!document) {
      console.debug(
        `toNeovimEditor(): creating new document: buffer=${buffer.id}`
      );
      document = new NeovimTextDocumentImpl(
        URI.parse(`neovim://${buffer.id}`),
        // URI.parse(`file://${buffer.id}`),
        "plaintext",
        1,
        "\n",
        // "\r\n",
        lines
      );
      this.documentMap.set(buffer, document);
    } else {
      console.debug(`toNeovimEditor(): updating document: buffer=${buffer.id}`);
      document.update(lines);
    }
    if (!editor) {
      console.debug(
        `toNeovimEditor(): creating new editor: window=${window2.id}`
      );
      editor = new NeovimTextEditorImpl(
        v4(),
        this.client,
        this,
        window2,
        document,
        visibleRanges,
        selections
      );
      this.editorMap.set(window2, editor);
    } else {
      console.debug(`toNeovimEditor(): updating editor: window=${window2.id}`);
      editor.updateDocument(visibleRanges, selections, document);
    }
    this.activeBuffer = buffer;
    this.activeWindow = window2;
    return this.activeTextEditor;
  }
  handleCommandError(err) {
    showErrorMessage(this.client, err.message);
  }
  disposeOnExit(...disposables) {
    this.disposables.push(...disposables);
    return () => (0, import_lodash59.pull)(this.disposables, ...disposables);
  }
};
function dummyEvent4() {
  return {
    dispose() {
    }
  };
}

// ../neovim-common/src/ide/neovim/hats/NeovimHats.ts
var NeovimHats = class {
  constructor(ide2) {
    this.ide = ide2;
    this.enabledHatStyleNotifier = new Notifier();
    this.isEnabledNotifier = new Notifier();
    this.enabledHatStyles = {};
    this.isEnabled = false;
  }
  async init() {
  }
  async setHatRanges(hatRanges) {
  }
  onDidChangeEnabledHatStyles(listener) {
    return this.enabledHatStyleNotifier.registerListener(listener);
  }
  onDidChangeIsEnabled(listener) {
    return this.isEnabledNotifier.registerListener(listener);
  }
};

// src/extension.ts
var crypto = __toESM(require("crypto"));
var os = __toESM(require("os"));
var path7 = __toESM(require("path"));

// src/NeovimCommandServerApi.ts
var NeovimCommandServerApi = class {
  constructor(client) {
    this.client = client;
    this.signals = { prePhrase: { getVersion: async () => null } };
  }
  // for vscode, it is actually stored into the command-server
  // but for neovim, it is stored in cursorless
  // https://github.com/pokey/command-server/blob/main/src/extension.ts#L32
  async getFocusedElementType() {
    const currentMode = await this.client.mode;
    if (currentMode.mode === "t" || currentMode.mode === "nt") {
      return "terminal";
    } else {
      return "textEditor";
    }
  }
};

// src/constructTestHelpers.ts
function constructTestHelpers(commandServerApi, storedTargets, hatTokenMap, neovimIDE, normalizedIde, fileSystem, scopeProvider, injectIde2, runIntegrationTests2) {
  return {
    commandServerApi,
    ide: normalizedIde,
    neovimIDE,
    injectIde: injectIde2,
    scopeProvider,
    // FIXME: Remove this once we have a better way to get this function
    // accessible from our tests
    takeSnapshot(excludeFields, extraFields, editor, ide2, marks2, forceRealClipboard) {
      return takeSnapshot(
        storedTargets,
        excludeFields,
        extraFields,
        editor,
        ide2,
        marks2,
        void 0,
        void 0,
        forceRealClipboard ? neovimIDE.clipboard : void 0
      );
    },
    cursorlessTalonStateJsonPath: fileSystem.cursorlessTalonStateJsonPath,
    cursorlessCommandHistoryDirPath: fileSystem.cursorlessCommandHistoryDirPath,
    setStoredTarget(editor, key, targets) {
      storedTargets.set(
        key,
        targets?.map((target) => plainObjectToTarget(editor, target))
      );
    },
    hatTokenMap,
    runIntegrationTests: runIntegrationTests2
  };
}

// src/registerCommands.ts
async function registerCommands(client, neovimIDE, commandApi, commandServerApi) {
  const commands = {
    // The core Cursorless command
    [CURSORLESS_COMMAND_ID]: async (...args) => {
      const originalMode = await client.mode;
      if (originalMode.mode === "t") {
        modeSwitchNormalTerminal(client);
      }
      try {
        await neovimIDE.updateTextEditor();
        const result = await commandApi.runCommandSafe(...args);
        const command = ensureCommandShape(args);
        const focusedElementType = await commandServerApi.getFocusedElementType();
        if (focusedElementType === "terminal" && clientSupportsFallback(command)) {
          const commandResponse = result;
          if ("fallback" in commandResponse && commandResponse.fallback.action === "insert") {
            modeSwitchTerminal(client);
          }
        }
        return result;
      } catch (e) {
        if (neovimIDE.runMode !== "test") {
          const err = e;
          console.error(err.stack);
          neovimIDE.handleCommandError(err);
        }
        throw e;
      }
    },
    // Cheatsheet commands
    ["cursorless.showCheatsheet"]: dummyCommandHandler,
    ["cursorless.internal.updateCheatsheetDefaults"]: dummyCommandHandler,
    // Testcase recorder commands
    ["cursorless.recordTestCase"]: dummyCommandHandler,
    ["cursorless.recordOneTestCaseThenPause"]: dummyCommandHandler,
    ["cursorless.pauseRecording"]: dummyCommandHandler,
    ["cursorless.resumeRecording"]: dummyCommandHandler,
    ["cursorless.takeSnapshot"]: dummyCommandHandler,
    // Other commands
    ["cursorless.showQuickPick"]: dummyCommandHandler,
    ["cursorless.showDocumentation"]: dummyCommandHandler,
    ["cursorless.private.logQuickActions"]: dummyCommandHandler,
    // Hats
    ["cursorless.toggleDecorations"]: dummyCommandHandler,
    ["cursorless.recomputeDecorationStyles"]: dummyCommandHandler,
    // Scope visualizer
    ["cursorless.showScopeVisualizer"]: dummyCommandHandler,
    ["cursorless.hideScopeVisualizer"]: dummyCommandHandler,
    // Command history
    ["cursorless.analyzeCommandHistory"]: dummyCommandHandler,
    // General keyboard commands
    ["cursorless.keyboard.escape"]: dummyCommandHandler,
    // Targeted keyboard commands
    ["cursorless.keyboard.targeted.targetHat"]: dummyCommandHandler,
    ["cursorless.keyboard.targeted.targetScope"]: dummyCommandHandler,
    ["cursorless.keyboard.targeted.targetSelection"]: dummyCommandHandler,
    ["cursorless.keyboard.targeted.clearTarget"]: dummyCommandHandler,
    ["cursorless.keyboard.targeted.runActionOnTarget"]: dummyCommandHandler,
    // Modal keyboard commands
    ["cursorless.keyboard.modal.modeOn"]: dummyCommandHandler,
    ["cursorless.keyboard.modal.modeOff"]: dummyCommandHandler,
    ["cursorless.keyboard.modal.modeToggle"]: dummyCommandHandler
  };
  Object.entries(commands).map(
    ([commandId, callback2]) => getNeovimRegistry().registerCommand(commandId, callback2)
  );
}
async function dummyCommandHandler(...args) {
  console.debug(`dummyCommandHandler(): args=${args}`);
}

// src/extension.ts
async function activate(plugin) {
  const client = plugin.nvim;
  const { neovimIDE, hats, fileSystem } = await createNeovimIde(client);
  const normalizedIde = neovimIDE.runMode === "production" ? neovimIDE : new NormalizedIDE(
    neovimIDE,
    new FakeIDE(),
    neovimIDE.runMode === "test"
  );
  const fakeCommandServerApi = new FakeCommandServerApi();
  const neovimCommandServerApi = new NeovimCommandServerApi(client);
  const commandServerApi = neovimIDE.runMode === "test" ? fakeCommandServerApi : neovimCommandServerApi;
  const treeSitter = createTreeSitter();
  const {
    commandApi,
    storedTargets,
    hatTokenMap,
    scopeProvider,
    snippets,
    injectIde: injectIde2,
    runIntegrationTests: runIntegrationTests2,
    addCommandRunnerDecorator,
    customSpokenFormGenerator
  } = await createCursorlessEngine(
    treeSitter,
    normalizedIde,
    hats,
    commandServerApi,
    fileSystem
  );
  await registerCommands(client, neovimIDE, commandApi, commandServerApi);
  const cursorlessApi = {
    testHelpers: neovimIDE.runMode === "test" ? constructTestHelpers(
      fakeCommandServerApi,
      storedTargets,
      hatTokenMap,
      neovimIDE,
      normalizedIde,
      fileSystem,
      scopeProvider,
      injectIde2,
      runIntegrationTests2
    ) : void 0,
    experimental: {
      registerThirdPartySnippets: snippets.registerThirdPartySnippets
    }
  };
  getNeovimRegistry().registerExtensionApi(EXTENSION_ID, cursorlessApi);
  console.log("activate(): Cursorless extension loaded");
}
async function createNeovimIde(client) {
  const neovimIDE = new NeovimIDE(client);
  await neovimIDE.init();
  const hats = new NeovimHats(neovimIDE);
  await hats.init();
  const cursorlessDir = neovimIDE.runMode === "test" ? path7.join(os.tmpdir(), crypto.randomBytes(16).toString("hex")) : path7.join(os.homedir(), ".cursorless");
  const fileSystem = new NeovimFileSystem(neovimIDE.runMode, cursorlessDir);
  await fileSystem.initialize();
  return { neovimIDE, hats, fileSystem };
}
function createTreeSitter() {
  return {
    getNodeAtLocation(document, range4) {
      throw new UnsupportedLanguageError2(document.languageId);
    },
    getTree(document) {
      return null;
    },
    loadLanguage(languageId) {
      return Promise.resolve(false);
    },
    getLanguage(languageId) {
      return void 0;
    }
  };
}
var UnsupportedLanguageError2 = class extends Error {
  constructor(language) {
    super(
      `Language '${language}' not supported by parse tree extension.  See https://github.com/pokey/vscode-parse-tree#adding-a-new-language`
    );
    this.name = "UnsupportedLanguageError";
  }
};

// src/index.ts
function entry(plugin) {
  plugin.setOptions({ dev: false });
  plugin.registerFunction(
    "CursorlessLoadExtension",
    async () => await loadExtension(plugin),
    { sync: false }
  );
}
async function loadExtension(plugin) {
  console.log(
    "==============================================================================================="
  );
  console.log("loadExtension(cursorless-neovim): start");
  await activate(plugin);
  console.log("loadExtension(cursorless-neovim): done");
}
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

is-plain-object/dist/is-plain-object.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

itertools/dist/index.js:
  (* istanbul ignore else -- @preserve *)
  (* istanbul ignore if -- @preserve *)
*/
//# sourceMappingURL=index.cjs.map
