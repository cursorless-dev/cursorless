;; https://github.com/tree-sitter/tree-sitter-rust/blob/master/src/grammar.json

;; Generated by the following command:
;; `curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-rust/36ae187ed6dd3803a8a89dbb54f3124c8ee74662/src/node-types.STATEMENT_TYPES | jq '[.[] | select(.type == "_declaration_statement") | .subtypes[].type, "expression_statement"]'`
(
  (_
    [
      (associated_type)
      (attribute_item)
      (const_item)
      (empty_statement)
      (enum_item)
      (extern_crate_declaration)
      (foreign_mod_item)
      (impl_item)
      (inner_attribute_item)
      (let_declaration)
      (macro_definition)
      (macro_invocation)
      (function_item)
      (function_signature_item)
      (mod_item)
      (static_item)
      (struct_item)
      (trait_item)
      (type_item)
      (union_item)
      (use_declaration)
      (expression_statement)
    ] @statement
  ) @_dummy
  (#type? @_dummy source_file block declaration_list)
)

;;!! if v < 0 {}
;;!  ^^^^^^^^^^^
(if_expression) @ifStatement

;;!! if let Some(i) = number {}
;;!  ^^^^^^^^^^^^^^^^^^^^^^^^^^
;;!         ^^^^^^^^^^^^^^^^
(if_let_expression
  "let" @condition.start
  value: (_) @condition.end
) @ifStatement @_.domain

;;!! if true {}
;;!  ^^^^^^^^^^
(_
  (if_expression
    "if" @branch.start @branch.removal.start
    condition: (_) @condition
    consequence: (_) @branch.end @branch.removal.end
    alternative: (else_clause
      (if_expression) @branch.removal.end.startOf
    )?
  ) @condition.domain
  (#not-parent-type? @condition.domain else_clause)
)

;;!! else if true {}
;;!  ^^^^^^^^^^^^^^^
(else_clause
  "else" @branch.start @condition.domain.start
  (if_expression
    condition: (_) @condition
    consequence: (_) @branch.end @condition.domain.end
  )
)

;;!! else {}
;;!  ^^^^^^^
(
  (else_clause
    (block)
  ) @branch
)

;;!! "hello"
(
  (string_literal) @string @textFragment
  (#child-range! @textFragment 0 -1 true true)
)

;;!! r#"foobar"#
(
  (raw_string_literal) @string @textFragment
  (#shrink-to-match! @textFragment "r#+\"(?<keep>.*)\"#+")

)

[
  (line_comment)
  (block_comment)
] @comment @textFragment

[
  (struct_item
    name: (_) @className @name
  )
  (enum_item
    name: (_) @className @name
  )
] @class @_.domain

(struct_expression) @class

(enum_variant
  name: (_) @name
) @_.domain

(trait_item
  name: (_) @className @name
) @_.domain

;;!! fn foo() {}
;;!  ^^^^^^^^^^^
(function_item
  name: (_) @functionName @name
) @namedFunction @_.domain

;;!! fn foo() -> int {}
;;!              ^^^
(function_item
  parameters: (_) @_.leading.endOf
  return_type: (_)? @type
) @_.domain

;;!! fn foo<T: Display>() {}
;;!         ^
;;!            ^^^^^^^
(constrained_type_parameter
  left: (_) @name @collectionKey
  (trait_bounds
    ":" @value.leading.endOf
    (_) @value.start
    (_) @value.end
  )
) @_.domain

;;!! where T: Display
;;!        ^
;;!           ^^^^^^^
(where_predicate
  left: (_) @name @collectionKey
  (trait_bounds
    ":" @value.leading.endOf
    (_) @value.start
    (_) @value.end
  )
) @_.domain

(field_declaration
  name: (_) @name @type.leading.endOf
  type: (_) @type
) @_.domain

;;!! (t: &T, u: &U)
;;!   ^      ^
(parameter
  pattern: (_) @name @type.leading.endOf
  type: (_) @type
) @_.domain

[
  (call_expression)
  (macro_invocation)
  (struct_expression)
] @functionCall

(call_expression
  function: (_) @functionCallee
) @_.domain

(closure_expression) @anonymousFunction

[
  (array_expression)
  (tuple_expression)
] @list

(match_expression
  value: (_) @private.switchStatementSubject
) @_.domain

;;!! #[derive(Debug)]
;;!  ^^^^^^^^^^^^^^^^
(attribute_item) @attribute

;;!! &mut x;
;;!   ^^^
(_
  (mutable_specifier) @attribute
  .
  (_) @_.trailing.startOf
) @_.domain

;;!! let Foo {aaa: 1, bbb: 2}
;;!           ^^^     ^^^
;;!                ^       ^
(field_initializer
  name: (_) @collectionKey @value.leading.endOf
  value: (_) @value @collectionKey.trailing.startOf
) @_.domain

;;!! Foo {aaa: 1, bbb: 2}
;;!       ^^^     ^^^
;;!            ^       ^
(field_pattern
  name: (_) @collectionKey @value.leading.endOf
  pattern: (_) @value @collectionKey.trailing.startOf
) @_.domain

;;!! const foo: u8 = 2;
;;!                  ^
(const_item
  name: (_) @name @type.leading.endOf
  type: (_) @type @value.leading.endOf
  value: (_) @value
) @_.domain

;;!! let foo = 2;
;;!      ^^^
;;!            ^
(let_declaration
  pattern: (_) @name @value.leading.start.endOf
  .
  value: (_) @value
) @_.domain

;;!! let foo: u8 = 2;
;;!      ^^^
;;!            ^
(let_declaration
  pattern: (_) @name @type.leading.endOf
  type: (_) @type @value.leading.start.endOf
  value: (_) @value
) @_.domain

;;!! #[cfg_attr(feature = "foo")]
;;!             ^^^^^^^
;;!                       ^^^^^
(meta_item
  (identifier) @name @value.leading.endOf
  value: (_) @value
) @_.domain

;;!! return 2;
;;!         ^
(return_expression
  (_) @value
) @_.domain

;; Implicit return value at end of function body
(function_item
  body: (_
    (_) @value
    .
  )
  (#not-type?
    @value
    ;; Exclude return expression
    return_expression
    ;; Exclude all statements
    associated_type
    attribute_item
    const_item
    empty_statement
    enum_item
    extern_crate_declaration
    foreign_mod_item
    impl_item
    inner_attribute_item
    let_declaration
    macro_definition
    macro_invocation
    function_item
    function_signature_item
    mod_item
    static_item
    struct_item
    trait_item
    type_item
    union_item
    use_declaration
    expression_statement
  )
)

;;!! while v < 0 {}
;;!        ^^^^^
(while_expression
  condition: (_) @condition
) @_.domain

;;!! while let Some(i) = number {}
;;!        ^^^^^^^^^^^^^^^^^^^^
(while_let_expression
  "let" @condition.start
  value: (_) @condition.end
) @_.domain

;;!! User { value } if value.use() => {}
;;!                    ^^^^^^^^^^^
(_
  (match_pattern
    (_) @_.leading.endOf
    .
    condition: (_) @condition
  )
) @_.domain

;;!! match value { 5 => {} }
;;!                ^^^^^^^
(match_arm) @branch

[
  (struct_item)
  (trait_item)
  (impl_item)
] @type

(impl_item
  type: (_) @type
)

(array_type
  element: (_) @type
) @_.domain
;;!! fn foo(a: u32, b: u32) -> {}
;;!         ^^^^^^  ^^^^^^
(_
  (parameters
    (_)? @_.leading.endOf
    .
    (_) @argumentOrParameter
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @argumentOrParameter @_dummy ", " ",\n")
)

;;!! fn foo(a: u32, b: u32) -> {}
;;!         ^^^^^^^^^^^^^^
(_
  (parameters
    "(" @argumentList.start.endOf @argumentOrParameter.iteration.start.endOf
    ")" @argumentList.end.startOf @argumentOrParameter.iteration.end.startOf
  ) @_dummy
  (#empty-single-multi-delimiter! @argumentList.start.endOf @_dummy "" ", " ",\n")
) @argumentList.domain @argumentOrParameter.iteration.domain

;;!! foo(aaa, bbb)
;;!      ^^^  ^^^
(_
  (arguments
    (_)? @_.leading.endOf
    .
    (_) @argumentOrParameter
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @argumentOrParameter @_dummy ", " ",\n")
)

;;!! foo(aaa, bbb)
;;!      ^^^^^^^^
(_
  (arguments
    "(" @argumentList.start.endOf @argumentOrParameter.iteration.start.endOf
    ")" @argumentList.end.startOf @argumentOrParameter.iteration.end.startOf
  ) @_dummy
  (#empty-single-multi-delimiter! @argumentList.start.endOf @_dummy "" ", " ",\n")
) @argumentList.domain @argumentOrParameter.iteration.domain

;;!! enum E { C(u16, u16) }
;;!             ^^^  ^^^
(_
  (ordered_field_declaration_list
    (_)? @_.leading.endOf
    .
    (_) @argumentOrParameter
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @argumentOrParameter @_dummy ", " ",\n")
)

;;!! enum E { C(u16, u16) }
;;!             ^^^^^^^^
(_
  (ordered_field_declaration_list
    "(" @argumentList.start.endOf @argumentOrParameter.iteration.start.endOf
    ")" @argumentList.end.startOf @argumentOrParameter.iteration.end.startOf
  ) @_dummy
  (#empty-single-multi-delimiter! @argumentList.start.endOf @_dummy "" ", " ",\n")
) @argumentList.domain @argumentOrParameter.iteration.domain

;;!! #[derive(aaa, bbb)]
;;!           ^^^  ^^^
(_
  (meta_arguments
    (_)? @_.leading.endOf
    .
    (_) @argumentOrParameter
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @argumentOrParameter @_dummy ", " ",\n")
)

;;!! #[derive(aaa, bbb)]
;;!           ^^^^^^^^
(_
  (meta_arguments
    "(" @argumentList.start.endOf @argumentOrParameter.iteration.start.endOf
    ")" @argumentList.end.startOf @argumentOrParameter.iteration.end.startOf
  ) @_dummy
  (#empty-single-multi-delimiter! @argumentList.start.endOf @_dummy "" ", " ",\n")
) @argumentList.domain @argumentOrParameter.iteration.domain

;;!! fn foo<T: Display, U: Clone>() {}
;;!         ^^^^^^^^^^  ^^^^^^^^
(_
  (type_parameters
    (_)? @_.leading.endOf
    .
    (_) @type
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @type @_dummy ", " ",\n")
)

;;!! fn foo<T: Display, U: Clone>() {}
;;!         ^^^^^^^^^^^^^^^^^^^^
(_
  (type_parameters
    "<" @type.iteration.start.endOf
    ">" @type.iteration.end.startOf
  )
) @type.iteration.domain

;;!! where T: Display, U: Clone
;;!        ^^^^^^^^^^  ^^^^^^^^
(
  (where_clause
    (_)? @_.leading.endOf
    .
    (_) @type
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @type @_dummy ", " ",\n")
)

;;!! where T: Display, U: Clone
;;!        ^^^^^^^^^^^^^^^^^^^^
(where_clause
  "where" @type.iteration.start.endOf
) @type.iteration.end.endOf @type.iteration.domain

operator: [
  "<"
  "<<"
  "<<="
  "<="
  ">"
  ">="
  ">>"
  ">>="
] @disqualifyDelimiter
(function_item
  "->" @disqualifyDelimiter
)
(match_arm
  "=>" @disqualifyDelimiter
)
(macro_rule
  "=>" @disqualifyDelimiter
)
(lifetime
  "'" @disqualifyDelimiter
)
