;; https://github.com/tree-sitter/tree-sitter-go/blob/master/src/grammar.json

;; @statement generated by the following command:
;;  curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-go/master/src/node-types.json | jq '[.[] | select(.type == "_statement" or .type == "_simple_statement") | .subtypes[].type]' | grep -v '\"_' | sed -n '1d;p' | sed '$d' | sort
;; and then cleaned up.
[
  (break_statement)
  (const_declaration)
  (continue_statement)
  (defer_statement)
  (empty_statement)
  (expression_statement)
  (expression_switch_statement)
  (fallthrough_statement)
  (for_statement)
  (go_statement)
  (goto_statement)
  (labeled_statement)
  (return_statement)
  (select_statement)
  (send_statement)
  (type_declaration)
  (type_switch_statement)

  ;; Disabled on purpose. We have a better definition of this below.
  ;; (if_statement)
  ;; omit block for now, as it is not clear that it matches Cursorless user expectations
  ;; (block)
] @statement

;; Exclude statements that are part of for clauses
(
  [
    (assignment_statement)
    (short_var_declaration)
    (var_declaration)
    (inc_statement)
    (dec_statement)
  ] @statement
  (#not-parent-type? @statement for_clause)
)

(
  (source_file) @statement.iteration @class.iteration @namedFunction.iteration
  (#document-range! @statement.iteration @class.iteration @namedFunction.iteration)
)
(
  (source_file) @name.iteration @value.iteration @type.iteration
  (#document-range! @name.iteration @value.iteration @type.iteration)
)

(block
  "{" @class.iteration.start.endOf @statement.iteration.start.endOf
  "}" @class.iteration.end.startOf @statement.iteration.end.startOf
)
(block
  "{" @name.iteration.start.endOf @value.iteration.start.endOf @type.iteration.start.endOf
  "}" @name.iteration.end.startOf @value.iteration.end.startOf @type.iteration.end.startOf
)

;;!! { }
;;!   ^
(_
  .
  "{" @interior.start.endOf
  "}" @interior.end.startOf
  .
)

(
  (interpreted_string_literal) @string @textFragment
  (#child-range! @textFragment 0 -1 true true)
)

(
  (raw_string_literal) @string @textFragment
  (#character-range! @textFragment 1 -1)
)

;; // Hello world
(comment) @comment @textFragment

;;!! type Foo struct {}
(type_declaration
  (type_spec
    name: (_) @name
    type: (struct_type
      (field_declaration_list
        "{" @statement.iteration.start.endOf @name.iteration.start.endOf @type.iteration.start.endOf
        "}" @statement.iteration.end.startOf @name.iteration.end.startOf @type.iteration.end.startOf
      )
    )
  )
) @class @type @name.domain

(struct_type
  (field_declaration_list
    "{" @namedFunction.iteration.start.endOf
    "}" @namedFunction.iteration.end.startOf
  )
)

;;!! type Foo interface {}
(type_declaration
  (type_spec
    name: (_) @name
    type: (interface_type
      "{" @statement.iteration.start.endOf @name.iteration.start.endOf
      "}" @statement.iteration.end.startOf @name.iteration.end.startOf
    )
  )
) @type @name.domain

;;!! type Foo interface { bar() }
(method_spec
  name: (_) @name
) @statement @name.domain

;;!! type Foo struct { bar int }
;;!! type Foo interface { bar() }
(field_declaration
  name: (_) @name
  type: (_) @type
) @statement @_.domain

;;!! T{a: 1}
;;!   ^^^^^^
(composite_literal
  body: (literal_value
    (keyed_element)
  ) @map
)

;;!! T{1, 2}
;;!   ^^^^^^
(composite_literal
  body: (literal_value
    (literal_element)
  ) @list
)

;;!! T{}
;;!   ^^
(composite_literal
  body: (literal_value
    "{"
    .
    "}"
  ) @list @map
)

;; Functions

;; function declaration, generic function declaration, function stub
;; func foo() {}
;; func foo[]() {}
;; func foo()
(function_declaration
  name: (_) @name
) @namedFunction @statement @name.domain

;; method declaration
;; func (X) foo() {}
(method_declaration
  name: (_) @name
) @namedFunction @statement @name.domain

;;!! func() {}
(func_literal) @anonymousFunction

;;!! foo = func() {}
(assignment_statement
  right: (expression_list
    .
    (func_literal)
    .
  )
) @namedFunction

(
  [
    ;;!! default:
    (default_case)

    ;;!! case 0:
    (expression_case
      value: (_) @condition
    )

    ;;!! case int:
    (type_case
      type: (_) @condition
    )
  ] @branch @condition.domain
  (#trim-end! @branch @condition.domain)
  (#insertion-delimiter! @branch "\n")
)

;; The parent object has trailing whitespace that we want to exclude.
;; Our trim predicate can't operate on positions only ranges.
(_
  [
    "case"
    "default"
  ]
  ":" @interior.start.endOf
  .
  (_) @_dummy
  (_) @interior.end.endOf
  .
  (#not-type? @_dummy block)
)
(_
  [
    "case"
    "default"
  ]
  ":" @interior.start.endOf
  .
  (_) @interior.end.endOf
  .
  (#not-type? @interior.end.endOf block)
)

;;!! switch foo {}
(expression_switch_statement
  value: (_) @value
  "{" @interior.start.endOf @branch.iteration.start.endOf @condition.iteration.start.endOf
  "}" @interior.end.startOf @branch.iteration.end.startOf @condition.iteration.end.startOf
) @value.domain

;;!! switch v := x.(type) {}
(type_switch_statement
  "switch"
  .
  _ @value.start
  _ @value.end
  .
  "{" @interior.start.endOf @branch.iteration.start.endOf @condition.iteration.start.endOf
  "}" @interior.end.startOf @branch.iteration.end.startOf @condition.iteration.end.startOf
) @value.domain

;; The outermost if statement
(
  (if_statement) @ifStatement @statement @branch.iteration
  (#not-parent-type? @ifStatement if_statement)
)

;; first if in an if-else chain
(
  (if_statement
    consequence: (block) @branch.end.endOf
  ) @branch.start.startOf
  (#not-parent-type? @branch.start.startOf if_statement)
  (#insertion-delimiter! @branch.start.startOf " ")
)

;; internal if in an if-else chain
(if_statement
  "else" @branch.start
  alternative: (if_statement
    consequence: (block) @branch.end
  )
  (#insertion-delimiter! @branch.start " ")
)

;; final else branch in an if-else chain
(
  (if_statement
    "else" @branch.start.startOf
    alternative: (block)
  ) @branch.end.endOf
  (#insertion-delimiter! @branch.start.startOf " ")
)

[
  (call_expression)
  (composite_literal)
] @functionCall

(call_expression
  function: (_) @functionCallee
) @_.domain

(composite_literal
  type: (_) @functionCallee
) @_.domain

(return_statement
  (expression_list) @value
) @_.domain

;;!! map[string]int{"aaa": 1, "bbb": 2}
;;!                 ^^^^^     ^^^^^
;;!                        ^         ^
(keyed_element
  .
  (_) @collectionKey
  .
  (_) @value
) @_.domain

;;!! map[string]int{"aaa": 1, "bbb": 2}
;;!                 ^^^^^^^^^^^^^^^^^^
(literal_value
  "{" @collectionKey.iteration.start.endOf @value.iteration.start.endOf
  "}" @collectionKey.iteration.end.startOf @value.iteration.end.startOf
)

[
  (pointer_type)
  (qualified_type)
] @type

;;!! type Foo = Bar
(type_declaration
  (type_alias
    name: (_) @name @value.leading.endOf
    type: (_) @value
  )
) @type @_.domain

;;!! var foo Bar[int, string]
;;!              ^^^  ^^^^^^
(generic_type
  (type_arguments
    (_) @type
  )
)

;;!! var foo Bar[int, string]
;;!              ^^^^^^^^^^^
(generic_type
  (type_arguments
    "[" @type.iteration.start.endOf
    "]" @type.iteration.end.startOf
  )
)

(function_declaration
  result: (_) @type
) @_.domain

(method_declaration
  result: (_) @type
) @_.domain

;;!! if true {}
(
  (_
    condition: (_) @condition
  ) @_.domain
  (#not-type? @condition parenthesized_expression)
  (#not-type? @_.domain for_clause)
)

;;!! if (true) {}
(
  (_
    condition: (parenthesized_expression) @condition
  ) @_.domain
  (#child-range! @condition 0 -1 true true)
)

;;!! for i := 0; i < size; i++ {}
;;!              ^^^^^^^^
(for_statement
  (for_clause
    condition: (_) @condition
  )
) @condition.domain

;;!! for i, v := range values {}
;;!      ^^^^
;;!                    ^^^^^^
(for_statement
  (range_clause
    left: (_) @name
    right: (_) @value
  )
) @_.domain

;;!! foo, bar := 1, 2
;;!  ^^^  ^^^    ^  ^
(
  (expression_list
    (_)? @collectionItem.leading.endOf
    .
    (_) @collectionItem
    .
    (_)? @collectionItem.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @collectionItem @_dummy ", " ",\n")
)

(expression_list) @collectionItem.iteration

;;!! func add(x int, y int) int {}
(
  (parameter_list
    (_)? @_.leading.endOf
    .
    (_) @argumentOrParameter
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#not-type? @argumentOrParameter "comment")
  (#single-or-multi-line-delimiter! @argumentOrParameter @_dummy ", " ",\n")
)

;;!! add(1, 2)
(
  (argument_list
    (_)? @_.leading.endOf
    .
    (_) @argumentOrParameter
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#not-type? @argumentOrParameter "comment")
  (#single-or-multi-line-delimiter! @argumentOrParameter @_dummy ", " ",\n")
)

;;!! func bar( ) {}
;;!           ^
(_
  parameters: (parameter_list
    "(" @argumentList.removal.start.endOf @argumentOrParameter.iteration.start.endOf
    ")" @argumentList.removal.end.startOf @argumentOrParameter.iteration.end.startOf
  ) @argumentList
  (#empty-single-multi-delimiter! @argumentList @argumentList "" ", " ",\n")
  (#child-range! @argumentList 1 -2)
) @argumentList.domain @argumentOrParameter.iteration.domain

(_
  parameters: (parameter_list
    "(" @name.iteration.start.endOf @type.iteration.start.endOf
    ")" @name.iteration.end.startOf @type.iteration.end.startOf
  )
)

;;!! foo( )
;;!      ^
(_
  (argument_list
    "(" @argumentList.removal.start.endOf @argumentOrParameter.iteration.start.endOf
    ")" @argumentList.removal.end.startOf @argumentOrParameter.iteration.end.startOf
  ) @argumentList
  (#empty-single-multi-delimiter! @argumentList @argumentList "" ", " ",\n")
  (#child-range! @argumentList 1 -2)
) @argumentList.domain @argumentOrParameter.iteration.domain

;;!! func foo(aaa int) {}
(parameter_declaration
  name: (_) @name
  type: (_) @type
) @_.domain

;;!! var foo int = 0
;;!      ^^^
;;!          ^^^
;;!               ^
(var_declaration
  (var_spec
    name: (_) @name
    type: (_) @type @value.leading.endOf
    value: (_)? @value
  )
) @_.domain

;;!! var foo = 0
;;!      ^^^
;;!            ^
(var_declaration
  (var_spec
    name: (_) @name @value.leading.endOf
    !type
    value: (_) @value
  )
) @_.domain

;;!! foo := 0
;;!  ^^^
;;!         ^
(short_var_declaration
  left: (_) @name @value.leading.endOf
  right: (_) @value
) @_.domain

;;!! foo = 0
;;!  ^^^
;;!        ^
(assignment_statement
  left: (_) @name @value.leading.endOf
  right: (_) @value
) @_.domain

operator: [
  "<-"
  "<"
  "<<"
  "<<="
  "<="
  ">"
  ">="
  ">>"
  ">>="
] @disqualifyDelimiter
(send_statement
  "<-" @disqualifyDelimiter
)
