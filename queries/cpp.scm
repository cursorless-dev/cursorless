;; import c.scm

;; https://github.com/tree-sitter/tree-sitter-cpp/blob/master/src/grammar.json

;; Generated by the following command:
;;  >  curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-cpp/master/src/node-types.json | jq '[.[] | select(.type == "compound_statement") | .children.types[].type] + [.[] | select(.type == "_statement") | .subtypes[].type]'
[
  (alias_declaration)
  (namespace_definition)
  (static_assert_declaration)
  (template_declaration)
  (template_instantiation)
  (using_declaration)
  (for_range_loop)
  (throw_statement)
  (try_statement)
] @statement

(_
  (class_specifier
    name: (_) @className @name
    body: (_)
  ) @_.domain.start @class.start @type.start
  .
  ";"? @_.domain.end @class.end @type.end
)

(_
  (class_specifier
    name: (_)
    body: (_)
  ) @statement.start
  .
  ";"? @statement.end
)

(field_declaration_list
  "{" @namedFunction.iteration.start.endOf @functionName.iteration.start.endOf
  "}" @namedFunction.iteration.end.startOf @functionName.iteration.end.startOf
) @_.domain

;;!! int aaa = 0;
;;!            ^
(field_declaration
  declarator: (_) @_.leading.endOf
  default_value: (_) @value
) @_.domain

;;!! void ClassName::method() {}
(function_definition
  declarator: (_
    declarator: (_
      scope: (_) @className
    )
  )
) @_.domain

;;!! []() {}
;;!  ^^^^^^^
(lambda_expression) @anonymousFunction

;;!! [[attribute]]
(attribute_declaration) @attribute

;; >  curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-cpp/master/src/node-types.json | jq '[.[] | select(.type == "_type_specifier") | .subtypes[].type]'
[
  (auto)
  (decltype)
  (dependent_type)
] @type

;;!! void foo(int value = 0) {}
;;!               ^^^^^
;;!                       ^
(optional_parameter_declaration
  declarator: (_) @name @value.leading.endOf
  default_value: (_) @value
) @_.domain

(declaration
  type: (_) @functionCallee @functionCall.start @_.domain.start
  declarator: (init_declarator
    value: (argument_list)
  ) @functionCall.end @_.domain.end
)

;;!! try {}
;;!  ^^^^^^
(try_statement
  "try" @branch.start
  body: (_) @branch.end
) @branch.iteration

;;!! catch (const std::exception& e) {}
(catch_clause) @branch

;;!! new Foo()
;;!  ^^^^^^^^^
;;!  ^^^^^^^
(new_expression
  "new" @functionCallee.start
  type: (_) @functionCallee.end
) @functionCall @functionCallee.domain

;;!! Map<string, int> foo;
;;!      ^^^^^^  ^^^
(
  (template_argument_list
    (_)? @_.leading.endOf
    .
    (type_descriptor) @type
    .
    (_)? @_.trailing.startOf
  ) @_dummy
  (#single-or-multi-line-delimiter! @type @_dummy ", " ",\n")
)

;;!! Map<string, int> foo;
;;!      ^^^^^^^^^^^
(template_argument_list
  "<" @type.iteration.start.endOf
  ">" @type.iteration.end.startOf
)

;;!! for (int value : values) {}
;;!           ^^^^^
;;!                   ^^^^^^
(for_range_loop
  declarator: (_) @name
  right: (_) @value
) @_.domain

(trailing_return_type
  "->" @disqualifyDelimiter
)
