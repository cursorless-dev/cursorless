import { SyntaxNode } from "web-tree-sitter";
import { getPojoMatchers } from "./getPojoMatchers";
import {
  cascadingMatcher,
  composedMatcher,
  matcher,
  notSupported,
  typeMatcher,
} from "../nodeMatchers";
import { NodeFinder, NodeMatcher, ScopeType } from "../Types";
import {
  getDefinitionNode,
  getLeftNode,
  getNameNode,
} from "../treeSitterUtils";
import {
  nodeFinder,
  typedNodeFinder,
  findPossiblyWrappedNode,
} from "../nodeFinders";
import {
  delimitedSelector,
  selectWithLeadingDelimiter,
} from "../nodeSelectors";

// TODO figure out how to properly use super types
// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-python/d6210ceab11e8d812d4ab59c07c81458ec6e5184/src/node-types.json \
//   | jq '[.[] | select(.type == primary_expression or .type == expression) | .subtypes[].type]'
const EXPRESSION_TYPES = [
  "attribute",
  "await",
  "binary_operator",
  "boolean_operator",
  "call",
  "comparison_operator",
  "concatenated_string",
  "conditional_expression",
  "dictionary",
  "dictionary_comprehension",
  "ellipsis",
  "false",
  "float",
  "generator_expression",
  "identifier",
  "integer",
  "lambda",
  "list",
  "list_comprehension",
  "named_expression",
  "none",
  "not_operator",
  "parenthesized_expression",
  "primary_expression",
  "set",
  "set_comprehension",
  "string",
  "subscript",
  "true",
  "tuple",
  "unary_operator",
];

function isExpression(node: SyntaxNode) {
  return EXPRESSION_TYPES.includes(node.type);
}

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-python/d6210ceab11e8d812d4ab59c07c81458ec6e5184/src/node-types.json \
//   | jq '[.[] | select(.type == "_simple_statement" or .type == "_compound_statement") | .subtypes[].type]'
const STATEMENT_TYPES = [
  "assert_statement",
  "break_statement",
  "class_definition",
  "continue_statement",
  "decorated_definition",
  "delete_statement",
  "exec_statement",
  "expression_statement",
  "for_statement",
  "function_definition",
  "future_import_statement",
  "global_statement",
  "if_statement",
  "import_from_statement",
  "import_statement",
  "nonlocal_statement",
  "pass_statement",
  "print_statement",
  "raise_statement",
  "return_statement",
  "try_statement",
  "while_statement",
  "with_statement",
];

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-python/d6210ceab11e8d812d4ab59c07c81458ec6e5184/src/node-types.json \
//   | jq '[.[] | select(.type == "parameter") | .subtypes[].type]'
const PARAMETER_TYPES = [
  "default_parameter",
  "dictionary_splat_pattern",
  "identifier",
  "list_splat_pattern",
  "tuple_pattern",
  "typed_default_parameter",
  "typed_parameter",
];

const PARAMETER_LIST_TYPES = ["lambda_parameters", "parameters"];

// TODO: Don't hard code this
const LIST_ELEMENT_TYPES = [
  ...EXPRESSION_TYPES,
  "list_splat",
  "parenthesized_list_splat",
  "yield",
];

// TODO: Don't hard code this
const ARGUMENT_TYPES = [
  ...EXPRESSION_TYPES,
  "list_splat",
  "dictionary_splat",
  "parenthesized_expression",
  "keyword_argument",
];

function possiblyDecoratedDefinition(...typeNames: string[]): NodeFinder {
  return findPossiblyWrappedNode(
    typedNodeFinder("decorated_definition"),
    typedNodeFinder(...typeNames),
    (node) => [getDefinitionNode(node)]
  );
}

export const getTypeNode = (node: SyntaxNode) =>
  node.children.find((child) => child.type === "type") ?? null;

const nodeMatchers: Record<ScopeType, NodeMatcher> = {
  ...getPojoMatchers(
    ["dictionary", "dictionary_comprehension"],
    ["list", "list_comprehension"],
    (node) => LIST_ELEMENT_TYPES.includes(node.type)
  ),
  ifStatement: typeMatcher("if_statement"),
  class: matcher(possiblyDecoratedDefinition("class_definition")),
  statement: typeMatcher(...STATEMENT_TYPES),
  name: cascadingMatcher(
    matcher(getNameNode),
    matcher((node) => (node.type === "assignment" ? getLeftNode(node) : null))
  ),
  functionName: composedMatcher([
    typedNodeFinder("function_definition"),
    getNameNode,
  ]),
  className: composedMatcher([
    typedNodeFinder("class_definition"),
    getNameNode,
  ]),
  arrowFunction: typeMatcher("lambda"),
  functionCall: typeMatcher("call"),
  argumentOrParameter: matcher(
    nodeFinder(
      (node) =>
        (node.parent?.type === "argument_list" &&
          ARGUMENT_TYPES.includes(node.type)) ||
        (PARAMETER_LIST_TYPES.includes(node.parent?.type ?? "") &&
          PARAMETER_TYPES.includes(node.type))
    ),
    delimitedSelector(
      (node) => node.type === "," || node.type === "(" || node.type === ")",
      ", "
    )
  ),
  namedFunction: matcher(possiblyDecoratedDefinition("function_definition")),
  comment: typeMatcher("comment"),
  regex: typeMatcher("regex"),
  type: matcher(getTypeNode, selectWithLeadingDelimiter),
};

export default nodeMatchers;
