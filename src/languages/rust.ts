import {
    createPatternMatchers,
    argumentMatcher,
    leadingMatcher,
    conditionMatcher,
    trailingMatcher,
    childAtIndexMatcher,
    cascadingMatcher,
    patternMatcher,
  } from "../util/nodeMatchers";
  import {
    NodeMatcherAlternative,
    ScopeType,
    SelectionWithEditor,
  } from "../typings/Types";
  import { getNodeRange } from "../util/nodeSelectors";
  import { SyntaxNode } from "web-tree-sitter";
  
  // Generated by the following command:
  // `curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-rust/master/src/node-types.json | jq '[.[] | select(.type == "_declaration_statement" or .type == "_expression") | .subtypes[].type]'`
  const STATEMENT_TYPES = [
    "associated_type",
    "attribute_item",
    "const_item",
    "empty_statement",
    "enum_item",
    "extern_crate_declaration",
    "foreign_mod_item",
    "function_item",
    "function_signature_item",
    "impl_item",
    "inner_attribute_item",
    "let_declaration",
    "macro_definition",
    "macro_invocation",
    "mod_item",
    "static_item",
    "struct_item",
    "trait_item",
    "type_item",
    "union_item",
    "use_declaration",
    "_literal",
    "array_expression",
    "assignment_expression",
    "async_block",
    "await_expression",
    "binary_expression",
    "block",
    "break_expression",
    "call_expression",
    "closure_expression",
    "compound_assignment_expr",
    "const_block",
    "continue_expression",
    "field_expression",
    "for_expression",
    "generic_function",
    "identifier",
    "if_expression",
    "if_let_expression",
    "index_expression",
    "loop_expression",
    "macro_invocation",
    "match_expression",
    "metavariable",
    "parenthesized_expression",
    "range_expression",
    "reference_expression",
    "return_expression",
    "scoped_identifier",
    "self",
    "struct_expression",
    "try_expression",
    "tuple_expression",
    "type_cast_expression",
    "unary_expression",
    "unit_expression",
    "unsafe_block",
    "while_expression",
    "while_let_expression"
  ];
  
  const nodeMatchers: Partial<Record<ScopeType, NodeMatcherAlternative>> = {
    // map: "composite_literal",
    // list: ["composite_literal", "slice_type", "array_type"],
    statement: STATEMENT_TYPES,
//     string: ["interpreted_string_literal", "raw_string_literal"],
//     ifStatement: "if_statement",
    functionCall: ["call_expression", "macro_invocation"],
//     comment: "comment",1
//     namedFunction: ["function_declaration", "method_declaration"],
//     type: [
//       "pointer_type",
//       "qualified_type",
//       "type_identifier",
//       "function_declaration[result]",
//       "method_declaration[result]",
//     ],
//     functionName: ["function_declaration[name]", "method_declaration[name]"],
//     anonymousFunction: "func_literal",
//     condition: conditionMatcher("*[condition]"),
    argumentOrParameter: cascadingMatcher(
        argumentMatcher("arguments"),
        trailingMatcher(["parameter"], [","]),
    ),
//     collectionItem: ["keyed_element", "element"],
//     collectionKey: childAtIndexMatcher(["keyed_element"], 0),
//     value: cascadingMatcher(
//       childAtIndexMatcher(["keyed_element"], 1),
//       patternMatcher("return_statement.expression_list!")
//     )
   };
  
  export default createPatternMatchers(nodeMatchers);