import { TextEditor } from "vscode";
import { SyntaxNode } from "web-tree-sitter";
import { getPojoMatchers } from "./getPojoMatchers";
import {
  matcher,
  cascadingMatcher,
  patternMatcher,
  createPatternMatchers,
  argumentMatcher,
  notSupported,
} from "../nodeMatchers";
import { NodeMatcherAlternative, ScopeType } from "../Types";
import { patternFinder } from "../nodeFinders";
import {
  //   delimitersSelector,
  selectWithLeadingDelimiter,
  simpleSelectionExtractor,
} from "../nodeSelectors";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-java/master/src/node-types.json | jq '[.[] | select(.type == "primary_expression" or .type == "expression") | .subtypes[].type]'
const EXPRESSION_TYPES = [
  "assignment_expression",
  "binary_expression",
  "cast_expression",
  "instanceof_expression",
  "lambda_expression",
  "primary_expression",
  "switch_expression",
  "ternary_expression",
  "unary_expression",
  "update_expression",
  "_literal",
  "array_access",
  "array_creation_expression",
  "class_literal",
  "field_access",
  "identifier",
  "method_invocation",
  "method_reference",
  "object_creation_expression",
  "parenthesized_expression",
  "this",
];

function isExpression(node: SyntaxNode) {
  return EXPRESSION_TYPES.includes(node.type);
}

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-java/master/src/node-types.json | jq '[.[] | select(.type == "statement" or .type == "declaration") | .subtypes[].type]'
const STATEMENT_TYPES = [
  "annotation_type_declaration",
  "class_declaration",
  "enum_declaration",
  "import_declaration",
  "interface_declaration",
  "module_declaration",
  "package_declaration",
  //   ";",
  "assert_statement",
  "block",
  "break_statement",
  "continue_statement",
  "declaration",
  "do_statement",
  "enhanced_for_statement",
  "expression_statement",
  "for_statement",
  "if_statement",
  "labeled_statement",
  "local_variable_declaration",
  "return_statement",
  "switch_expression",
  "synchronized_statement",
  "throw_statement",
  "try_statement",
  "try_with_resources_statement",
  "while_statement",
  "yield_statement",
];

const nodeMatchers: Record<ScopeType, NodeMatcherAlternative> = {
  class: "class_declaration",
  className: "class_declaration[name]",
  namedFunction: ["method_declaration", "constructor_declaration"],
  functionName: [
    "method_declaration.identifier!",
    "constructor_declaration.identifier!",
  ],
  ifStatement: "if_statement",
  string: "string_literal",
  name: ["*[name]", "formal_parameter.identifier!"],
  type: [
    "type_identifier",
    "local_variable_declaration[type]",
    "array_creation_expression[type]",
    "formal_parameter[type]",
  ],
  comment: "comment",
  arrowFunction: "lambda_expression",
  list: "array_initializer",
  functionCall: "method_invocation",

  dictionary: notSupported,
  collectionKey: notSupported,
  // value: matcher(getValueNode, selectWithLeadingDelimiter),
  value: notSupported,
  collectionItem: notSupported,
  // collectionItem: matcher(
  //   nodeFinder(
  //     (node) =>
  //       (listTypes.includes(node.parent?.type ?? "") &&
  //         listElementMatcher(node)) ||
  //       node.type === "pair" ||
  //       node.type === "shorthand_property_identifier" || // Property shorthand
  //       node.type === "shorthand_property_identifier_pattern" // Deconstructed object
  //   ),
  //   delimitersSelector(",", "[", "]", "{", "}")
  // ),

  regex: notSupported,
  statement: STATEMENT_TYPES.map((type) => `export_statement?.${type}`),

  //   type: cascadingMatcher(
  //     // Typed parameters, properties, and functions
  //     matcher(findTypeNode, selectWithLeadingDelimiter),
  //     // Type alias/interface declarations
  //     patternMatcher(
  //       "export_statement?.type_alias_declaration",
  //       "export_statement?.interface_declaration"
  //     )
  //   ),

  // TODO
  //   argumentOrParameter: ""
  argumentOrParameter: argumentMatcher(
    "formal_parameters",
    "array_initializer"
  ),
  //   argumentOrParameter: matcher(
  //     patternFinder("array_initializer.*!", "formal_parameter", "array_initializer"),
  //     delimitersSelector
  //     // delimitersSelector(",", "(", ")", "{", "}")
  //   ),
};

export default createPatternMatchers(nodeMatchers);
