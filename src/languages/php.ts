import { Selection, TextEditor } from "vscode";
import { SyntaxNode } from "web-tree-sitter";
import {
  NodeMatcherAlternative,
  ScopeType,
  SelectionWithContext,
  SelectionWithEditor,
} from "../typings/Types";
import { patternFinder } from "../util/nodeFinders";
import {
  argumentMatcher,
  cascadingMatcher,
  createPatternMatchers,
  leadingMatcher,
  matcher,
  trailingMatcher,
} from "../util/nodeMatchers";
import { getNodeRange } from "../util/nodeSelectors";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-php/0ce134234214427b6aeb2735e93a307881c6cd6f/src/node-types.json \
//   | jq '[.[] | select(.type == "_statement") | .subtypes[].type]'
const STATEMENT_TYPES = [
  "break_statement",
  "class_declaration",
  "compound_statement",
  "const_declaration",
  "continue_statement",
  "declare_statement",
  "do_statement",
  "echo_statement",
  "empty_statement",
  "enum_declaration",
  "expression_statement",
  "for_statement",
  "foreach_statement",
  "function_definition",
  "function_static_declaration",
  "global_declaration",
  "goto_statement",
  "if_statement",
  "interface_declaration",
  "named_label_statement",
  "namespace_definition",
  "namespace_use_declaration",
  "return_statement",
  "switch_statement",
  "trait_declaration",
  "try_statement",
  "unset_statement",
  "while_statement",
];

// Taken from https://www.php.net/manual/en/language.operators.assignment.php
const assignmentOperators = [
  "=",
  // Arithmetic
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "**=",
  // Bitwise
  "&=",
  "|=",
  "^=",
  "<<=",
  ">>=",
  // Other
  ".=",
  "??=",
];

/**
 * Given a node representing the text of a type cast, will return the
 * content range as the text inner type, and the outside range includes
 * the surrounding parentheses, so that "chuck type" deletes the parens
 * @param editor The editor containing the node
 * @param node The node to extract from; will be the content of the type cast without the surrounding parens
 * @returns The selection with context
 */
function castTypeExtractor(
  editor: TextEditor,
  node: SyntaxNode
): SelectionWithContext {
  const range = getNodeRange(node);
  const contentRange = range;
  const leftParenRange = getNodeRange(node.previousSibling!);
  const rightParenRange = getNodeRange(node.nextSibling!.nextSibling!);
  const outerRange = range.with(leftParenRange.start, rightParenRange.start);

  return {
    selection: new Selection(contentRange.start, contentRange.end),
    context: {
      outerSelection: new Selection(outerRange.start, outerRange.end),
    },
  };
}

const nodeMatchers: Partial<Record<ScopeType, NodeMatcherAlternative>> = {
  statement: STATEMENT_TYPES,
  ifStatement: "if_statement",
  class: "class_declaration",
  className: "class_declaration[name]",
  name: [
    "assignment_expression[left]",
    "class_declaration[name]",
    "function_definition[name]",
    "method_declaration[name]",
  ],
  comment: "comment",
  string: "string",
  type: cascadingMatcher(
    trailingMatcher(["~cast_expression[type]"]),
    matcher(patternFinder("cast_expression[type]"), castTypeExtractor)
  ),

  namedFunction: trailingMatcher(
    [
      "function_definition",
      "assignment_expression.anonymous_function_creation_expression",
      "assignment_expression.arrow_function",
    ],
    [";"]
  ),
  anonymousFunction: [
    "anonymous_function_creation_expression",
    "arrow_function",
  ],
  functionCall: ["function_call_expression", "object_creation_expression"],
  functionName: ["function_definition[name]", "method_declaration[name]"],

  value: leadingMatcher(
    [
      "array_element_initializer[1]",
      "assignment_expression[right]",
      "augmented_assignment_expression[right]",
      "return_statement[0]",
      "yield_expression[0]",
    ],
    assignmentOperators.concat(["=>"])
  ),

  collectionKey: trailingMatcher(["array_element_initializer[0]"], ["=>"]),
  collectionItem: argumentMatcher("array_creation_expression"),

  argumentOrParameter: argumentMatcher("arguments", "formal_parameters"),
};
export default createPatternMatchers(nodeMatchers);

export function stringTextFragmentExtractor(
  node: SyntaxNode,
  _selection: SelectionWithEditor
) {
  if (node.type === "string") {
    return getNodeRange(node);
  }

  return null;
}
